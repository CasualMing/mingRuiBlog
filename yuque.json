[
  {
    "id": 1557123,
    "slug": "gbwkwa",
    "title": "12. HTML资源替换型元素",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [资源引入]<br />categories: 重学前端系列笔记<br />cover: \"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg\"\n\n---\n<a name=\"jVJwW\"></a>\n## 前言\n我们在做网站的时候，需要写 **`JavaScript`** 和 **`css`** 以及引入其他的资源。 **`css`** 是可以写 内联样式、嵌入式样式、外部样式。\n<a name=\"script\"></a>\n### script\n像是 **`JavaScript`** 可以使用 src 引入外部 **`JS`** 文件\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/vue\" type=\"text/javascript\"></script>\n```\n但是如果是这样\n```html\n<script src=\"https://cdn.jsdelivr.net/npm/vue\" type=\"text/javascript\">\n   var time  = new Date();\n   console.log(time);\n</script>\n```\n\n上面这种写法，引入的文件会将 **`script`** 里的内容覆盖，使得里面的代码不生效，我们通常将这种类型的标签，称之为**替换型标签 ：**凡是替换型元素，都是使用 src 属性来引用文件的\n<a name=\"link\"></a>\n### link\n像 **`style`** 这种**非替换型标签，**不能使用 **`src`**  引入外部文件，就这样我们需要借助 **`link`** 标签\n\n```html\n<link rel=\"stylesheet\" href=\"style.css\">\n```\n\n<a name=\"img\"></a>\n### img\n> 这个标签的意义是引入外部的图片资源，使用 **`src`** 链接，如果没有 **`src`** 属性，这个标签将毫无用处\n\n```html\n <img src=\"/images/temp.jpg\" alt=\"\" sizes=\"\" srcset=\"\" width=\"300px\">\n```\n上面的代码显示，引入了一个 **`temp`** 的图片，并规定了图片的宽， **`W3C`**  规定 **`img`** 标签，宽高属性如果只给一个，那么将会进行等比例缩放处理<br />**`srcset`**  提供了根据屏幕条件选取图片的能力，但是其实更好 是使用 **`picture`** \n<a name=\"d569162d\"></a>\n###  picture\n> **`picture`**`src`**  链接\n\n\n```html\n<picture>\n  <source srcset=\"image-wide.png\" media=\"(min-width: 600px)\">\n  <img src=\"image-narrow.png\">\n</picture>\n```\n 它使用 source 元素来指定图片源，并且支持多个图片， **`picture`** 标签里包裹 **`img`** 是为了兼容，当 不支持 **`source`** 或者不支持 **`picture`** 的时候， **`img`** 作为最后一道屏障， **`source`** 标签中的 **`media`** 属性跟 **`@media`** 具有同样的功能。<br />同样支持 **`source`** 标签的，还有 **`video、audio`** 、\n<a name=\"video\"></a>\n### video\n```html\n// 兼容完整版写法\n<video controls=\"controls\" >\n  <source src=\"movie.webm\" type=\"video/webm\" >\n  <source src=\"movie.ogg\" type=\"video/ogg\" >\n  <source src=\"movie.mp4\" type=\"video/mp4\">\n  你的浏览器暂不支持视频，请更换浏览器查看\n</video>\n// 普通版写法\n<video controls=\"controls\" src=\"movie.mp4\"></video>\n```\n如果是需要兼容老版本的浏览器，需要加上 **`object、embed`**  标签，其中 [**`<object>`**](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object)  使用 **`data`** 属性链接资源 ，而 [**`embed`**](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed)  是使用 **`src`** 链接资源\n<a name=\"audio\"></a>\n### audio\n> 写法跟上面的差不多\n\n```html\n// 兼容完整版写法\n<audio controls>\n  <source src=\"song.mp3\" type=\"audio/mpeg\">\n  <source src=\"song.ogg\" type=\"audio/ogg\">\n  <p>你的平台不支持音频，请更换浏览器再查看</p>\n</audio>\n// 普通版写法\n<audio controls=\"controls\" src=\"movie.mp3\"></audio>\n```\n<a name=\"iframe\"></a>\n### iframe\n> 这个标签可以将页面完整的引入到当前页面\n\n\n```html\n    <iframe>\n        <!DOCTYPE html>\n        <html lang=\"en\">\n        <head>\n            <meta charset=\"UTF-8\">\n            <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n            <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n            <title>Document</title>\n        </head>\n        <body>\n            <p>故人心尚永，故人心不现</p>\n        </body>\n        </html>\n    </iframe>\n```\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [<span style=\"color: #222222;\">资源引入</span>]</p><p>categories<span>:</span> 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><hr /><h2 id=\"jVJwW\"><span style=\"background-color: transparent;\">前言</span></h2><p>我们在做网站的时候，需要写 <strong><code>JavaScript</code></strong> 和 <strong><code>css</code></strong> 以及引入其他的资源。 <strong><code>css</code></strong> 是可以写 <span class=\"lake-fontsize-12\">内联样式、</span><span class=\"lake-fontsize-12\" style=\"background-color: \"rgba(0, 0, 0, 0)\";\">嵌入式样式、</span><span class=\"lake-fontsize-12\" style=\"background-color: \"rgba(0, 0, 0, 0)\";\">外部样式。</span></p><h3 id=\"script\">script</h3><p>像是 <strong><code>JavaScript</code></strong> 可以使用 src 引入外部 <strong><code>JS</code></strong> 文件</p><pre data-lang=\"html\"><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></pre><p>但是如果是这样</p><pre data-lang=\"html\"><code>&lt;script src=&quot;https://cdn.jsdelivr.net/npm/vue&quot; type=&quot;text/javascript&quot;&gt;\n   var time  = new Date();\n   console.log(time);\n&lt;/script&gt;</code></pre><p><br /></p><p><span class=\"lake-fontsize-12\">上面这种写法，引入的文件会将 </span><span class=\"lake-fontsize-12\"><strong><code>script</code></strong></span><span class=\"lake-fontsize-12\"> 里的内容覆盖，使得里面的代码不生效，我们通常将这种类型的标签，称之为</span><strong><span class=\"lake-fontsize-12\">替换型标签 ：</span></strong><span class=\"lake-fontsize-12\">凡是替换型元素，都是使用 src 属性来引用文件的</span></p><h3 id=\"link\">link</h3><p><span class=\"lake-fontsize-12\">像 </span><span class=\"lake-fontsize-12\"><strong><code>style</code></strong></span><span class=\"lake-fontsize-12\"> 这种</span><span class=\"lake-fontsize-12\"><strong>非替换型标签，</strong>不能使用 </span><strong><code><span class=\"lake-fontsize-12\">src</span></code></strong> <span class=\"lake-fontsize-12\"> 引入外部文件，就这样我们需要借助 </span><strong><code><span class=\"lake-fontsize-12\">link</span></code></strong> <span class=\"lake-fontsize-12\">标签</span></p><p><br /></p><pre data-lang=\"html\"><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt;</code></pre><p><br /></p><h3 id=\"img\">img</h3><blockquote><p><span class=\"lake-fontsize-12\">这个标签的意义是引入外部的图片资源，使用 </span><span class=\"lake-fontsize-12\"><strong><code>src</code></strong></span><span class=\"lake-fontsize-12\"> 链接，如果没有 </span><strong><code><span class=\"lake-fontsize-12\">src</span></code></strong> <span class=\"lake-fontsize-12\">属性，</span><span class=\"lake-fontsize-12\">这个标签将毫无用处</span></p></blockquote><pre data-lang=\"html\"><code> &lt;img src=&quot;/images/temp.jpg&quot; alt=&quot;&quot; sizes=&quot;&quot; srcset=&quot;&quot; width=&quot;300px&quot;&gt;</code></pre><p><span class=\"lake-fontsize-12\">上面的代码显示，引入了一个 </span><span class=\"lake-fontsize-12\"><strong><code>temp</code></strong></span><span class=\"lake-fontsize-12\"> 的图片，并规定了图片的宽， </span><span class=\"lake-fontsize-12\"><strong><code>W3C</code></strong></span><span class=\"lake-fontsize-12\">  规定 </span><span class=\"lake-fontsize-12\"><strong><code>img</code></strong></span><span class=\"lake-fontsize-12\"> 标签，宽高属性如果只给一个，那么将会进行等比例缩放处理</span></p><p><strong><code><span class=\"lake-fontsize-12\">srcset</span></code></strong> <span class=\"lake-fontsize-12\"> 提供了根据屏幕条件选取图片的能力，但是其实更好 是使用 </span><strong><code><span class=\"lake-fontsize-12\">picture</span></code></strong><span class=\"lake-fontsize-12\"> </span></p><h3 id=\"d569162d\"> picture</h3><blockquote><p><strong><code>picture</code></strong> 元素可以根据不同屏幕尺寸选择展示不同尺寸的图片，也是使用 <strong><code>src</code></strong>  链接</p></blockquote><p><br /></p><pre data-lang=\"html\"><code>&lt;picture&gt;\n  &lt;source srcset=&quot;image-wide.png&quot; media=&quot;(min-width: 600px)&quot;&gt;\n  &lt;img src=&quot;image-narrow.png&quot;&gt;\n&lt;/picture&gt;</code></pre><p><span class=\"lake-fontsize-12\"> 它使用 source 元素来指定图片源，并且支持多个图片， </span><strong><code><span class=\"lake-fontsize-12\">picture</span></code></strong> 标签里包裹 <strong><code>img</code></strong> 是为了兼容，当 不支持 <strong><code>source</code></strong> 或者<span>不支持</span> <strong><code>picture</code></strong> 的时候， <strong><code>img</code></strong> 作为最后一道屏障， <strong><code>source</code></strong> 标签中的 <strong><code>media</code></strong> 属性跟 <strong><code>@media</code></strong> 具有同样的功能。</p><p>同样支持 <strong><code>source</code></strong> 标签的，还有 <strong><code>video、audio</code></strong> 、</p><h3 id=\"video\">video</h3><pre data-lang=\"html\"><code>// 兼容完整版写法\n&lt;video controls=&quot;controls&quot; &gt;\n  &lt;source src=&quot;movie.webm&quot; type=&quot;video/webm&quot; &gt;\n  &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot; &gt;\n  &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt;\n  你的浏览器暂不支持视频，请更换浏览器查看\n&lt;/video&gt;\n// 普通版写法\n&lt;video controls=&quot;controls&quot; src=&quot;movie.mp4&quot;&gt;&lt;/video&gt;</code></pre><p>如果是需要兼容老版本的浏览器，需要加上 <strong><code>object、embed</code></strong>  标签，其中 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object\" target=\"_blank\"><strong><code>&lt;object&gt;</code></strong></a>  使用 <strong><code>data</code></strong> 属性链接资源 ，而 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed\" target=\"_blank\"><strong><code>embed</code></strong></a>  是使用 <strong><code>src</code></strong> 链接资源</p><h3 id=\"audio\">audio</h3><blockquote><p>写法跟上面的差不多</p></blockquote><pre data-lang=\"html\"><code>// 兼容完整版写法\n&lt;audio controls&gt;\n  &lt;source src=&quot;song.mp3&quot; type=&quot;audio/mpeg&quot;&gt;\n  &lt;source src=&quot;song.ogg&quot; type=&quot;audio/ogg&quot;&gt;\n  &lt;p&gt;你的平台不支持音频，请更换浏览器再查看&lt;/p&gt;\n&lt;/audio&gt;\n// 普通版写法\n&lt;audio controls=&quot;controls&quot; src=&quot;movie.mp3&quot;&gt;&lt;/audio&gt;</code></pre><h3 id=\"iframe\">iframe</h3><blockquote><p>这个标签可以将页面完整的引入到当前页面</p></blockquote><p><br /></p><pre data-lang=\"html\"><code>    &lt;iframe&gt;\n        &lt;!DOCTYPE html&gt;\n        &lt;html lang=&quot;en&quot;&gt;\n        &lt;head&gt;\n            &lt;meta charset=&quot;UTF-8&quot;&gt;\n            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n            &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n            &lt;title&gt;Document&lt;/title&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            &lt;p&gt;故人心尚永，故人心不现&lt;/p&gt;\n        &lt;/body&gt;\n        &lt;/html&gt;\n    &lt;/iframe&gt;</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [<span style=\"color: #222222;\">资源引入</span>]</p><p>categories<span>:</span> 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22ihmXg%22%7D\"></card><h2 id=\"jVJwW\"><span style=\"background-color: transparent;\">前言<cursor /></span></h2><p>我们在做网站的时候，需要写 <strong><code>JavaScript</code></strong> 和 <strong><code>css</code></strong> 以及引入其他的资源。 <strong><code>css</code></strong> 是可以写 <span class=\"lake-fontsize-12\">内联样式、</span><span class=\"lake-fontsize-12\" style=\"background-color: rgba(0, 0, 0, 0);\">嵌入式样式、</span><span class=\"lake-fontsize-12\" style=\"background-color: rgba(0, 0, 0, 0);\">外部样式。</span></p><h3 id=\"script\">script</h3><p>像是 <strong><code>JavaScript</code></strong> 可以使用 src 引入外部 <strong><code>JS</code></strong> 文件</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20src%3D%5C%22https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2Fvue%5C%22%20type%3D%5C%22text%2Fjavascript%5C%22%3E%3C%2Fscript%3E%22%2C%22id%22%3A%22Jiq2p%22%7D\"></card><p>但是如果是这样</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20src%3D%5C%22https%3A%2F%2Fcdn.jsdelivr.net%2Fnpm%2Fvue%5C%22%20type%3D%5C%22text%2Fjavascript%5C%22%3E%5Cn%20%20%20var%20time%20%20%3D%20new%20Date()%3B%5Cn%20%20%20console.log(time)%3B%5Cn%3C%2Fscript%3E%22%2C%22id%22%3A%22c52Mm%22%7D\"></card><p><br /></p><p><span class=\"lake-fontsize-12\">上面这种写法，引入的文件会将 </span><span class=\"lake-fontsize-12\"><strong><code>script</code></strong></span><span class=\"lake-fontsize-12\"> 里的内容覆盖，使得里面的代码不生效，我们通常将这种类型的标签，称之为</span><strong><span class=\"lake-fontsize-12\">替换型标签 ：</span></strong><span class=\"lake-fontsize-12\">凡是替换型元素，都是使用 src 属性来引用文件的</span></p><h3 id=\"link\">link</h3><p><span class=\"lake-fontsize-12\">像 </span><span class=\"lake-fontsize-12\"><strong><code>style</code></strong></span><span class=\"lake-fontsize-12\"> 这种</span><span class=\"lake-fontsize-12\"><strong>非替换型标签，</strong>不能使用 </span><strong><code><span class=\"lake-fontsize-12\">src</span></code></strong> <span class=\"lake-fontsize-12\"> 引入外部文件，就这样我们需要借助 </span><strong><code><span class=\"lake-fontsize-12\">link</span></code></strong> <span class=\"lake-fontsize-12\">标签</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Clink%20rel%3D%5C%22stylesheet%5C%22%20href%3D%5C%22style.css%5C%22%3E%22%2C%22id%22%3A%22VHsVV%22%7D\"></card><p><br /></p><h3 id=\"img\">img</h3><blockquote><p><span class=\"lake-fontsize-12\">这个标签的意义是引入外部的图片资源，使用 </span><span class=\"lake-fontsize-12\"><strong><code>src</code></strong></span><span class=\"lake-fontsize-12\"> 链接，如果没有 </span><strong><code><span class=\"lake-fontsize-12\">src</span></code></strong> <span class=\"lake-fontsize-12\">属性，</span><span class=\"lake-fontsize-12\">这个标签将毫无用处</span></p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%20%3Cimg%20src%3D%5C%22%2Fimages%2Ftemp.jpg%5C%22%20alt%3D%5C%22%5C%22%20sizes%3D%5C%22%5C%22%20srcset%3D%5C%22%5C%22%20width%3D%5C%22300px%5C%22%3E%22%2C%22id%22%3A%22w3lTB%22%7D\"></card><p><span class=\"lake-fontsize-12\">上面的代码显示，引入了一个 </span><span class=\"lake-fontsize-12\"><strong><code>temp</code></strong></span><span class=\"lake-fontsize-12\"> 的图片，并规定了图片的宽， </span><span class=\"lake-fontsize-12\"><strong><code>W3C</code></strong></span><span class=\"lake-fontsize-12\">  规定 </span><span class=\"lake-fontsize-12\"><strong><code>img</code></strong></span><span class=\"lake-fontsize-12\"> 标签，宽高属性如果只给一个，那么将会进行等比例缩放处理</span></p><p><strong><code><span class=\"lake-fontsize-12\">srcset</span></code></strong> <span class=\"lake-fontsize-12\"> 提供了根据屏幕条件选取图片的能力，但是其实更好 是使用 </span><strong><code><span class=\"lake-fontsize-12\">picture</span></code></strong><span class=\"lake-fontsize-12\"> </span></p><h3 id=\"d569162d\"> picture</h3><blockquote><p><strong><code>picture</code></strong> 元素可以根据不同屏幕尺寸选择展示不同尺寸的图片，也是使用 <strong><code>src</code></strong>  链接</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cpicture%3E%5Cn%20%20%3Csource%20srcset%3D%5C%22image-wide.png%5C%22%20media%3D%5C%22(min-width%3A%20600px)%5C%22%3E%5Cn%20%20%3Cimg%20src%3D%5C%22image-narrow.png%5C%22%3E%5Cn%3C%2Fpicture%3E%22%2C%22id%22%3A%22UAV7z%22%7D\"></card><p><span class=\"lake-fontsize-12\"> 它使用 source 元素来指定图片源，并且支持多个图片， </span><strong><code><span class=\"lake-fontsize-12\">picture</span></code></strong> 标签里包裹 <strong><code>img</code></strong> 是为了兼容，当 不支持 <strong><code>source</code></strong> 或者<span>不支持</span> <strong><code>picture</code></strong> 的时候， <strong><code>img</code></strong> 作为最后一道屏障， <strong><code>source</code></strong> 标签中的 <strong><code>media</code></strong> 属性跟 <strong><code>@media</code></strong> 具有同样的功能。</p><p>同样支持 <strong><code>source</code></strong> 标签的，还有 <strong><code>video、audio</code></strong> 、</p><h3 id=\"video\">video</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%2F%2F%20%E5%85%BC%E5%AE%B9%E5%AE%8C%E6%95%B4%E7%89%88%E5%86%99%E6%B3%95%5Cn%3Cvideo%20controls%3D%5C%22controls%5C%22%20%3E%5Cn%20%20%3Csource%20src%3D%5C%22movie.webm%5C%22%20type%3D%5C%22video%2Fwebm%5C%22%20%3E%5Cn%20%20%3Csource%20src%3D%5C%22movie.ogg%5C%22%20type%3D%5C%22video%2Fogg%5C%22%20%3E%5Cn%20%20%3Csource%20src%3D%5C%22movie.mp4%5C%22%20type%3D%5C%22video%2Fmp4%5C%22%3E%5Cn%20%20%E4%BD%A0%E7%9A%84%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9A%82%E4%B8%8D%E6%94%AF%E6%8C%81%E8%A7%86%E9%A2%91%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%8D%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E6%9F%A5%E7%9C%8B%5Cn%3C%2Fvideo%3E%5Cn%2F%2F%20%E6%99%AE%E9%80%9A%E7%89%88%E5%86%99%E6%B3%95%5Cn%3Cvideo%20controls%3D%5C%22controls%5C%22%20src%3D%5C%22movie.mp4%5C%22%3E%3C%2Fvideo%3E%22%2C%22id%22%3A%22NzND4%22%7D\"></card><p>如果是需要兼容老版本的浏览器，需要加上 <strong><code>object、embed</code></strong>  标签，其中 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/object\" target=\"_blank\"><strong><code>&lt;object&gt;</code></strong></a>  使用 <strong><code>data</code></strong> 属性链接资源 ，而 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/embed\" target=\"_blank\"><strong><code>embed</code></strong></a>  是使用 <strong><code>src</code></strong> 链接资源</p><h3 id=\"audio\">audio</h3><blockquote><p>写法跟上面的差不多</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%2F%2F%20%E5%85%BC%E5%AE%B9%E5%AE%8C%E6%95%B4%E7%89%88%E5%86%99%E6%B3%95%5Cn%3Caudio%20controls%3E%5Cn%20%20%3Csource%20src%3D%5C%22song.mp3%5C%22%20type%3D%5C%22audio%2Fmpeg%5C%22%3E%5Cn%20%20%3Csource%20src%3D%5C%22song.ogg%5C%22%20type%3D%5C%22audio%2Fogg%5C%22%3E%5Cn%20%20%3Cp%3E%E4%BD%A0%E7%9A%84%E5%B9%B3%E5%8F%B0%E4%B8%8D%E6%94%AF%E6%8C%81%E9%9F%B3%E9%A2%91%EF%BC%8C%E8%AF%B7%E6%9B%B4%E6%8D%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%8D%E6%9F%A5%E7%9C%8B%3C%2Fp%3E%5Cn%3C%2Faudio%3E%5Cn%2F%2F%20%E6%99%AE%E9%80%9A%E7%89%88%E5%86%99%E6%B3%95%5Cn%3Caudio%20controls%3D%5C%22controls%5C%22%20src%3D%5C%22movie.mp3%5C%22%3E%3C%2Faudio%3E%22%2C%22id%22%3A%223gIp3%22%7D\"></card><h3 id=\"iframe\">iframe</h3><blockquote><p>这个标签可以将页面完整的引入到当前页面</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%20%20%20%20%3Ciframe%3E%5Cn%20%20%20%20%20%20%20%20%3C!DOCTYPE%20html%3E%5Cn%20%20%20%20%20%20%20%20%3Chtml%20lang%3D%5C%22en%5C%22%3E%5Cn%20%20%20%20%20%20%20%20%3Chead%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cmeta%20charset%3D%5C%22UTF-8%5C%22%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cmeta%20name%3D%5C%22viewport%5C%22%20content%3D%5C%22width%3Ddevice-width%2C%20initial-scale%3D1.0%5C%22%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cmeta%20http-equiv%3D%5C%22X-UA-Compatible%5C%22%20content%3D%5C%22ie%3Dedge%5C%22%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Ctitle%3EDocument%3C%2Ftitle%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fhead%3E%5Cn%20%20%20%20%20%20%20%20%3Cbody%3E%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%3Cp%3E%E6%95%85%E4%BA%BA%E5%BF%83%E5%B0%9A%E6%B0%B8%EF%BC%8C%E6%95%85%E4%BA%BA%E5%BF%83%E4%B8%8D%E7%8E%B0%3C%2Fp%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fbody%3E%5Cn%20%20%20%20%20%20%20%20%3C%2Fhtml%3E%5Cn%20%20%20%20%3C%2Fiframe%3E%22%2C%22id%22%3A%22hgVAm%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:59:02.000Z",
    "deleted_at": null,
    "created_at": "2019-04-18T08:12:46.000Z",
    "updated_at": "2019-04-28T01:59:02.000Z",
    "published_at": "2019-04-28T01:59:02.000Z",
    "first_published_at": "2019-04-18T10:05:52.000Z",
    "word_count": 899,
    "cover": null,
    "description": "tags: [资源引入]categories: 重学前端系列笔记cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1548763,
    "slug": "qq05c3",
    "title": "11. HTML中链接标签有哪些",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [链接标签]<br />categories: 重学前端系列笔记<br />cover: \"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg\"\n\n---\n<a name=\"ZCbTT\"></a>\n## 前言\n> 链接其实就是连接两个文件的桥梁，链接总的来说可以分两种。 **超链接型标签、文件资源引入型标签** \n\n**<br />![caab7832c425b3af2b3adae747e6f551.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1555469185096-fc36ed29-149e-4def-879c-850913f101b6.png#align=left&display=inline&height=1100&name=caab7832c425b3af2b3adae747e6f551.png&originHeight=1100&originWidth=702&size=89168&status=done&width=702)**<br />**\n\n<a name=\"1e199231\"></a>\n### link 标签\n> **`link`** 标签作为元信息的一种。有些是写给浏览器机器看的，为了让机器更好的了解该网站。\n\n- **canonical 型 link** ：这个标签提示页面它的主 URL，在网站中常常有多个 URL 指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个 link 会提示搜索引擎保留哪一个 URL。\n- **alternate 型 link** ：这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种 link 通常也是提供给搜索引擎来使用的。\n- **author 型 link** ：链接到本页面的作者，一般是 mailto: 协议\n- **help 型 link** ：链接到本页面的帮助页\n- **license 型 link** ：链接到本页面的版权信息页\n- **search 型 link** ：链接到本页面的搜索页面（一般是站内提供搜索时使用）\n- **icon 型 link** ：这个是用作指明页面的ico图标，用作在用户收藏时区分\n- **modulepreload 型的 link** ：预先加载一个 JavaScript 的模块。这可以保证 JS 模块不必等到执行时才加载。\n- **stylesheet 型 link** ：最常用的引入 CSS 文件\n- **预处理类 link** ：\n  - **dns-prefetch 型 link** ：提前对一个域名做 dns 查询，这样的 link 里面的 href 实际上只有域名有意义。\n  - **preconnect 型 link** ：提前对一个服务器建立 tcp 连接。\n  - **prefetch 型 link** ：提前取 href 指定的 url 的内容。\n  - **preload 型 link** ：提前加载 href 指定的 url。\n  - **prerender 型 link** ：提前渲染 href 指定的 url。\n<a name=\"48e042c7\"></a>\n### a 标签\n> 这个标签充当了链接和目标点的角色，具体的可以查找 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a)\n\n<a name=\"ac9eaf18\"></a>\n### area 标签\n\n- **`area`**  标签与 a 标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接。\n- 它的属性支持程度，跟 **`link,a`** 差不多\n- **`area`**  是整个 html 规则中唯一支持非矩形热区的标签\n- **`<area>`** 元素仅在 **<map> **元素内部使用。\n- 这个暂时没搞懂具体的用法，详情请看 [MDN的area标签](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/area)\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [<span style=\"color: #222222;\">链接标签</span>]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><hr /><h2 id=\"ZCbTT\"><span style=\"background-color: transparent;\">前言</span></h2><blockquote><p><span class=\"lake-fontsize-12\">链接其实就是连接两个文件的桥梁，链接总的来说可以分两种。 </span><strong><span class=\"lake-fontsize-12\">超链接型标签、文件资源引入型标签</span></strong> </p></blockquote><p><strong><br /><img alt=\"caab7832c425b3af2b3adae747e6f551.png\" title=\"caab7832c425b3af2b3adae747e6f551.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1555469185096-fc36ed29-149e-4def-879c-850913f101b6.png#align=left&amp;display=inline&amp;height=1100&amp;name=caab7832c425b3af2b3adae747e6f551.png&amp;originHeight=1100&amp;originWidth=702&amp;size=89168&amp;status=done&amp;width=702\" style=\"max-width: 600px; width: 702px;\" /></strong></p><p><strong><br /></strong></p><p><br /></p><h3 id=\"1e199231\">link 标签</h3><blockquote><p><span class=\"lake-fontsize-12\"><strong><code>link</code></strong></span><span class=\"lake-fontsize-12\"> 标签作为元信息的一种。有些是写给浏览器机器看的，为了让机器更好的了解该网站。</span></p></blockquote><ul><li><strong>canonical 型 link</strong> ：<span class=\"lake-fontsize-12\" style=\"color: #222222;\">这个标签提示页面它的主 URL，在网站中常常有多个 URL 指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个 link 会提示搜索引擎保留哪一个 URL。</span></li><li><strong>alternate 型 link</strong> ：<span class=\"lake-fontsize-12\" style=\"color: #222222;\">这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种 link 通常也是提供给搜索引擎来使用的。</span></li><li><strong>author 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的作者，一般是 mailto: 协议</span></li><li><strong>help 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的帮助页</span></li><li><strong>license 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的版权信息页</span></li><li><strong>search 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的搜索页面（一般是站内提供搜索时使用）</span></li><li><strong>icon 型 link</strong> ：这个是用作指明页面的ico图标，用作在用户收藏时区分</li><li><strong>modulepreload 型的 link</strong> ：<span class=\"lake-fontsize-12\" style=\"color: #222222;\">预先加载一个 JavaScript 的模块。这可以保证 JS 模块不必等到执行时才加载。</span></li><li><strong>stylesheet 型 link</strong> ：最常用的引入 CSS 文件</li><li><strong>预处理类 link</strong> ：</li></ul><ul data-lake-indent=\"1\"><li><strong>dns-prefetch 型 link</strong> ：<span class=\"lake-fontsize-12\">提前对一个域名做 dns 查询，这样的 link 里面的 href 实际上只有域名有意义。</span></li><li><strong>preconnect 型 link</strong> ：<span class=\"lake-fontsize-12\">提前对一个服务器建立 tcp 连接。</span></li><li><strong>prefetch 型 link</strong> ：<span class=\"lake-fontsize-12\">提前取 href 指定的 url 的内容。</span></li><li><strong>preload 型 link</strong> ：<span class=\"lake-fontsize-12\">提前加载 href 指定的 url。</span></li><li><strong>prerender 型 link</strong> ：<span class=\"lake-fontsize-12\">提前渲染 href 指定的 url。</span></li></ul><h3 id=\"48e042c7\">a 标签</h3><blockquote><p><span class=\"lake-fontsize-14\">这个标签充当了链接和目标点的角色，具体的可以查找 </span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a\" target=\"_blank\"><span class=\"lake-fontsize-14\">MDN</span></a></p></blockquote><h3 id=\"ac9eaf18\">area 标签</h3><ul><li><strong><code><span class=\"lake-fontsize-12\" style=\"color: #222222;\">area</span></code></strong> <span class=\"lake-fontsize-12\" style=\"color: #222222;\"> 标签与 a 标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接</span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">。</span></li><li><span class=\"lake-fontsize-12\">它的属性支持程度，跟 </span><span class=\"lake-fontsize-12\"><strong><code>link,a</code></strong></span><span class=\"lake-fontsize-12\"> 差不多</span></li><li><strong><code>area</code></strong>  <span class=\"lake-fontsize-12\">是整个 html 规则中唯一支持非矩形热区的标签</span></li><li><span class=\"lake-fontsize-12\"><strong><code>&lt;area&gt;</code></strong></span><span class=\"lake-fontsize-12\"> 元素仅在</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><strong>&lt;map&gt; </strong></span><span class=\"lake-fontsize-12\">元素内部使用。</span></li><li><span class=\"lake-fontsize-12\">这个暂时没搞懂具体的用法，详情请看 </span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/area\" target=\"_blank\"><span class=\"lake-fontsize-12\">MDN的area标签</span></a></li></ul><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [<span style=\"color: #222222;\">链接标签</span>]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%220qnoL%22%7D\"></card><h2 id=\"ZCbTT\"><span style=\"background-color: transparent;\"><cursor />前言</span></h2><blockquote><p><span class=\"lake-fontsize-12\">链接其实就是连接两个文件的桥梁，链接总的来说可以分两种。 </span><strong><span class=\"lake-fontsize-12\">超链接型标签、文件资源引入型标签</span></strong> </p></blockquote><p><strong><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1555469185096-fc36ed29-149e-4def-879c-850913f101b6.png%22%2C%22originWidth%22%3A702%2C%22originHeight%22%3A1100%2C%22name%22%3A%22caab7832c425b3af2b3adae747e6f551.png%22%2C%22size%22%3A89168%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A702%2C%22height%22%3A1100%7D\"></card></strong></p><p><strong><br /></strong></p><p><br /></p><h3 id=\"1e199231\">link 标签</h3><blockquote><p><span class=\"lake-fontsize-12\"><strong><code>link</code></strong></span><span class=\"lake-fontsize-12\"> 标签作为元信息的一种。有些是写给浏览器机器看的，为了让机器更好的了解该网站。</span></p></blockquote><ul><li><strong>canonical 型 link</strong> ：<span class=\"lake-fontsize-12\" style=\"color: #222222;\">这个标签提示页面它的主 URL，在网站中常常有多个 URL 指向同一页面的情况，搜索引擎访问这类页面时会去掉重复的页面，这个 link 会提示搜索引擎保留哪一个 URL。</span></li><li><strong>alternate 型 link</strong> ：<span class=\"lake-fontsize-12\" style=\"color: #222222;\">这个标签提示页面它的变形形式，这个所谓的变形可能是当前页面内容的不同格式、不同语言或者为不同的设备设计的版本，这种 link 通常也是提供给搜索引擎来使用的。</span></li><li><strong>author 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的作者，一般是 mailto: 协议</span></li><li><strong>help 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的帮助页</span></li><li><strong>license 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的版权信息页</span></li><li><strong>search 型 link</strong> ：<span class=\"lake-fontsize-12\">链接到本页面的搜索页面（一般是站内提供搜索时使用）</span></li><li><strong>icon 型 link</strong> ：这个是用作指明页面的ico图标，用作在用户收藏时区分</li><li><strong>modulepreload 型的 link</strong> ：<span class=\"lake-fontsize-12\" style=\"color: #222222;\">预先加载一个 JavaScript 的模块。这可以保证 JS 模块不必等到执行时才加载。</span></li><li><strong>stylesheet 型 link</strong> ：最常用的引入 CSS 文件</li><li><strong>预处理类 link</strong> ：</li></ul><ul data-lake-indent=\"1\"><li><strong>dns-prefetch 型 link</strong> ：<span class=\"lake-fontsize-12\">提前对一个域名做 dns 查询，这样的 link 里面的 href 实际上只有域名有意义。</span></li><li><strong>preconnect 型 link</strong> ：<span class=\"lake-fontsize-12\">提前对一个服务器建立 tcp 连接。</span></li><li><strong>prefetch 型 link</strong> ：<span class=\"lake-fontsize-12\">提前取 href 指定的 url 的内容。</span></li><li><strong>preload 型 link</strong> ：<span class=\"lake-fontsize-12\">提前加载 href 指定的 url。</span></li><li><strong>prerender 型 link</strong> ：<span class=\"lake-fontsize-12\">提前渲染 href 指定的 url。</span></li></ul><h3 id=\"48e042c7\">a 标签</h3><blockquote><p><span class=\"lake-fontsize-14\">这个标签充当了链接和目标点的角色，具体的可以查找 </span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a\" target=\"_blank\"><span class=\"lake-fontsize-14\">MDN</span></a></p></blockquote><h3 id=\"ac9eaf18\">area 标签</h3><ul><li><strong><code><span class=\"lake-fontsize-12\" style=\"color: #222222;\">area</span></code></strong> <span class=\"lake-fontsize-12\" style=\"color: #222222;\"> 标签与 a 标签非常相似，不同的是，它不是文本型的链接，而是区域型的链接</span><span class=\"lake-fontsize-11\" style=\"color: #222222;\">。</span></li><li><span class=\"lake-fontsize-12\">它的属性支持程度，跟 </span><span class=\"lake-fontsize-12\"><strong><code>link,a</code></strong></span><span class=\"lake-fontsize-12\"> 差不多</span></li><li><strong><code>area</code></strong>  <span class=\"lake-fontsize-12\">是整个 html 规则中唯一支持非矩形热区的标签</span></li><li><span class=\"lake-fontsize-12\"><strong><code>&lt;area&gt;</code></strong></span><span class=\"lake-fontsize-12\"> 元素仅在</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><strong>&lt;map&gt; </strong></span><span class=\"lake-fontsize-12\">元素内部使用。</span></li><li><span class=\"lake-fontsize-12\">这个暂时没搞懂具体的用法，详情请看 </span><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/area\" target=\"_blank\"><span class=\"lake-fontsize-12\">MDN的area标签</span></a></li></ul><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:59:11.000Z",
    "deleted_at": null,
    "created_at": "2019-04-17T01:50:32.000Z",
    "updated_at": "2019-04-28T01:59:11.000Z",
    "published_at": "2019-04-28T01:59:11.000Z",
    "first_published_at": "2019-04-17T02:51:22.000Z",
    "word_count": 624,
    "cover": null,
    "description": "tags: [链接标签]categories: 重学前端系列笔记cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1535604,
    "slug": "wry07p",
    "title": "10.DOM的API",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [DOM的API]<br />categories: 重学前端系列笔记<br />cover: \"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555293932589-c499b920-7e29-4340-847f-940e83b14666.jpeg\"\n\n---\n<a name=\"NXGn0\"></a>\n## 前言\n我们前端所操控的方法 **`API`** 总的来说分两大类\n\n- **浏览器对象模型：**就是我们经常依赖的环境-浏览器。浏览器会提供一些  **`API`** ，方便我们操作，但是并不是所有的方法都是标准里面的，需要区分哪些是浏览器这个环境提供的，哪些是 **`ECMA`** 标准里面的\n- **文档对象模型：**也就是我们经常使用的 **`DOM API`** ，用来操作页面元素\n<a name=\"1301fe28\"></a>\n## DOM的API分类\n\n- **节点**：节点操作\n- **事件**：触发或者监听方面的 `API` \n- **`Range`** ：操作文字方面的 `API` \n- **遍历 ：**遍历 `DOM` 需要的 `API` \n<a name=\"21b9f161\"></a>\n### 节点API\n<a name=\"a6967bfc\"></a>\n#### Node节点\n![6e278e450d8cc7122da3616fd18b9cf6.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1555299624515-0b283c44-3013-45f3-a03a-84102129c400.png#align=left&display=inline&height=495&name=6e278e450d8cc7122da3616fd18b9cf6.png&originHeight=634&originWidth=955&size=96882&status=done&width=746)\n\n> 一般来说。我们工作中经常碰到的有两种节点：文本节点或者元素节点\n\n\n<a name=\"ec4b57af\"></a>\n#### 元素节点关系API\n\n- **`parentNode`** :可以获取父级元素节点\n- **`childNodes`** :可以获取子级所有节点，包括元素节点，文本节点\n- **`firstChild`** :可以获取当前元素的第一个节点，一般是文本节点\n- **`lastChild`** ：可以获取当前元素的最后一个节点，一般是文本节点\n- **`nextSibling`** ：可以获取当前元素同级的下一个节点，一般是文本节点\n- **`previousSibling`** ：可以获取当前元素同级的上一个节点，一般是文本节点\n<a name=\"e057f953\"></a>\n#### 元素操作API\n\n- **`appendChild`** ：这个是追加子元素\n- **`insertBefore`** ：这个是在指定元素之前插入元素\n```javascript\nvar insertedNode = parentNode.insertBefore(newNode, referenceNode);\n/** \n* parentNode:要插入的父节点\n* newNode: 用于插入的节点\n* referenceNode: 要插入在什么节点之前\n*/\n```\n\n- **`removeChild`** ：移除指定元素\n- **`replaceChild`** ：替换指定元素节点\n```javascript\nvar replacedNode = parentNode.replaceChild(newChild, oldChild);\n/** replacedNode为返回被替换掉的节点。\n*如果 newChild 以及在页面的dom元素内，会从原来的位置删除，移动到要替换的位置\n*/\n```\n\n- **`cloneNode`**`true Or false`**`false`** \n<a name=\"9ed04098\"></a>\n#### 创建节点API\n\n- **`createElement`** ：创建指定的元素节点\n- **`createTextNode`** ：创建指定的文本节点\n- **`createCDATASection`** ：可以创建CDATA 区段节点，该方法返回 CDATASection 对象。\n```javascript\ncreateCDATASection(data) // data:字符串，这个字符串为节点规定数据。\n```\n\n- **`createComment`** ： 可创建注释节点, 并插入HTML文档\n- **`createProcessingInstruction`** ：创建一个新的处理指令节点，并返回\n```javascript\nvar docu = new DOMParser().parseFromString('<xml></xml>',  \"application/xml\")\nvar pi = docu.createProcessingInstruction('xml-stylesheet', 'href=\"mycss.css\" type=\"text/css\"');\ndocu.insertBefore(pi, docu.firstChild);\nalert(new XMLSerializer().serializeToString(docu));\n// 弹出框内容: <?xml-stylesheet href=\"mycss.css\" type=\"text/css\"?><xml/>\n```\n\n- **`createDocumentFragment`** ：创建一个新的空白的文档片段\n> 通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。\n\n```javascript\nlet fragment = document.createDocumentFragment();\n```\n\n\n- **`createDocumentType`** ：创建一个 DocumentType 节点\n<a name=\"f56853d9\"></a>\n#### 属性操作API\n\n- **`getAttribute` ：**获取指定元素上指定的属性\n- **`setAttribute` ：**设置指定元素上指定的属性<br />\n- **`removeAttribute` ：**移除指定元素上指定的属性\n- **`hasAttribute` ：**判断指定元素上是否有指定的属性\n\n如果追求性能，可以把Attribute 当作节点\n\n- **`getAttributeNode`** \n- **`setAttributeNode` **\n<a name=\"f99cb3ed\"></a>\n#### 查找元素\n\n- **`querySelector`** \n- **`querySelectorAll`** \n- **`getElementById`** \n- **`getElementsByName`** \n- **`getElementsByTagName`** \n- **`getElementsByClassName`** \n<a name=\"5c5c679f\"></a>\n### 事件API\n<a name=\"89a275cc\"></a>\n#### （0）鼠标事件\n\n- **`mousedown`** ：鼠标的键钮被按下。\n- **`mouseup`** ：鼠标离开监听的元素上是触发\n- **`mouseenter`** ：鼠标移动到元素上时就会触发（不会冒泡）\n- **`mouseleave`** ：指针移出元素范围外（不冒泡）\n- **`click`** ：单击鼠标的键钮。\n- **`dblclick`** ：在单个元素上单击两次鼠标的指针设备按钮 (通常是小鼠的主按钮) 时。\n- **`contextmenu`**  ：弹出右键菜单。\n- **`mouseover`** ：鼠标经过元素上方就会触发（会冒泡）\n- **`mouseout`** ：鼠标移出监听的元素时触发（会冒泡）\n- **`mousemove`** ：鼠标移动的时候触发\n<a name=\"f35f8583\"></a>\n#### （1）键盘事件\n\n- **`keydown`** ：按下键盘的任意键触发\n- **`keypress`** ：除 Shift, Fn, CapsLock 外任意键被按住. (连续触发)（不常用）\n- **`keyup`**  ：按键抬起触发\n<a name=\"e17fc0b0\"></a>\n#### （2）****页面事件****\n\n- **`load`** ：页面加载，一般可以看做是页面及资源加载完之后吃法\n- **`pageshow`** ：该事件在页面每次加载时都会触发，也就是说，即使页面是从浏览器中读取的，也会触发这个事件\n- **`unload`** ：离开页面时触发的事件，触发后无法缓存页面\n- **`pagehide`** ：离开页面时触发的事件，触发后依然可以对页面进行缓存\n> 如果同时使用 `unload`  和 `pagehide` 这两个方法的话，会发现 `onpagehide` 会先于 `onunload` 被触发，并且在这两个事件中都无法使用 `alert`\n\n- **`beforeunload`** ：页面关闭之前触发的事件，先于上面的两个离开页面事件被触发，同样无法使用 `alert`\n> **浏览器执行顺序**\n> onload -> onpageshow -> onbeforeunload -> onpagehide -> onunload\n\n<a name=\"2015eb00\"></a>\n#### （3）表单事件\n\n- **`reset`** ：重置事件\n- **`submit`** ：提交事件\n<a name=\"4cec4a1d\"></a>\n#### （4）剪贴板事件\n\n- **`cut`**  ：已经剪贴选中的文本内容并且复制到了剪贴板（剪切）\n- **`copy`**：已经把选中的文本内容复制到了剪贴板（复制）\n- **`paste`**：从剪贴板复制的文本内容被粘贴（粘贴）\n<a name=\"15aac593\"></a>\n#### （5）打印事件\n\n- **`beforeprint`** ：打印机已经就绪时触发\n- **`afterprint`**：打印机关闭时触发\n<a name=\"a566118f\"></a>\n#### （6）拖动事件\n\n- **`dragstart`**  ：用户准备拖动元素，也就是按住元素拖动前触发，这个时候元素未被拖动\n- **`drag`**  ：正在拖动元素或文本选区（在此过程中持续触发，每350ms触发一次）（也就相当于 mousemove）\n- **`dragend`** ： 拖放操作结束 （松开鼠标按钮或按下Esc键）\n- **`dragenter`**：被拖动的元素或文本选区移入有效释放目标区\n- **`dragover`**：被拖动的元素或文本选区正在有效释放目标上被拖动 （在此过程中持续触发，每350ms触发一次）\n- **`dragleave`**：被拖动的元素或文本选区移出有效释放目标区\n- **`drop`**：元素在有效释放目标区上释放\n<a name=\"1e6ba787\"></a>\n#### （7）多媒体（Media）事件\n\n- **`play`** ：音视频播放\n- **`pause`**：音视频暂停\n- **`ended`**：监听音视频是否播放完结\n<a name=\"797b0edc\"></a>\n#### （8）动画事件\n\n- **`animationstart`**：某个CSS动画开始时触发\n- **`animationend`**：某个CSS动画完成时触发\n- **`animationiteration`**：某个CSS动画完成后重新开始时触发\n<a name=\"7e2f3f3a\"></a>\n#### （9）过渡事件\n\n- **`transitionstart`**：过渡开始\n- **`transitioncancel`**：过渡去掉\n- **`transitionend`**：过渡结束\n- **`transitionrun`**：过渡运行时触发\n<a name=\"1c960ba0\"></a>\n#### （10）其他事件\n\n- **`cached`**：manifest中列出的资源已经下载，应用程序现在已缓存。\n- **`error`**：资源加载失败时\n- **`abort`**：正在加载资源已经被中止时\n- **`load`**：资源及其相关资源已完成加载。\n- **`beforeunload`**：window，document 及其资源即将被卸载。\n- **`unload`**： 文档或一个依赖资源正在被卸载。\n<a name=\"bf13c833\"></a>\n### Range  API（一般应用在富文本领域）\n> `Range API`  表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。\n> 只有做底层框架和富文本编辑对它有强需求\n\n<a name=\"54898fa9\"></a>\n### 遍历\n> 如果需要遍历 DOM 的时候，直接使用递归和 Node 的属性。\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [<span style=\"color: #222222;\">DOM的API</span>]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555293932589-c499b920-7e29-4340-847f-940e83b14666.jpeg&quot;</p><hr /><h2 id=\"NXGn0\"><span style=\"background-color: transparent;\">前言</span></h2><p>我们前端所操控的方法 <strong><code>API</code></strong> 总的来说分两大类</p><ul><li><strong><span class=\"lake-fontsize-12\">浏览器对象模型：</span></strong><span class=\"lake-fontsize-12\">就是我们经常依赖的环境-浏览器。浏览器会提供一些  </span><strong><code><span class=\"lake-fontsize-12\">API</span></code></strong> <span class=\"lake-fontsize-12\">，方便我们操作，但是并不是所有的方法都是标准里面的，需要区分哪些是浏览器这个环境提供的，哪些是 </span><strong><code><span class=\"lake-fontsize-12\">ECMA</span></code></strong> <span class=\"lake-fontsize-12\">标准里面的</span></li><li><strong><span class=\"lake-fontsize-12\">文档对象模型：</span></strong><span class=\"lake-fontsize-12\">也就是我们经常使用的 </span><strong><code><span class=\"lake-fontsize-12\">DOM API</span></code></strong> ，用来操作页面元素</li></ul><h2 id=\"1301fe28\">DOM的API分类</h2><ul><li><strong>节点</strong>：节点操作</li><li><strong>事件</strong>：触发或者监听方面的 <code>API</code> </li><li><strong><code>Range</code></strong> ：操作文字方面的 <code>API</code> </li><li><strong>遍历 ：</strong>遍历 <code>DOM</code> 需要的 <code>API</code> </li></ul><h3 id=\"21b9f161\">节点API</h3><h4 id=\"a6967bfc\">Node节点</h4><p><img alt=\"6e278e450d8cc7122da3616fd18b9cf6.png\" title=\"6e278e450d8cc7122da3616fd18b9cf6.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1555299624515-0b283c44-3013-45f3-a03a-84102129c400.png#align=left&amp;display=inline&amp;height=495&amp;name=6e278e450d8cc7122da3616fd18b9cf6.png&amp;originHeight=634&amp;originWidth=955&amp;size=96882&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><blockquote><p>一般来说。我们工作中经常碰到的有两种节点：文本节点或者元素节点</p></blockquote><p><br /></p><h4 id=\"ec4b57af\">元素节点关系API</h4><ul><li><strong><code>parentNode</code></strong> :可以获取父级元素节点</li><li><strong><code>childNodes</code></strong> <span>:可以获取子级所有节点，包括元素节点，文本节点</span></li><li><strong><code>firstChild</code></strong> <span>:可以获取当前元素的第一个节点，一般是文本节点</span></li><li><strong><code>lastChild</code></strong> ：<span>可以获取当前元素的最后一个节点，一般是文本节点</span></li><li><strong><code>nextSibling</code></strong> ：<span>可以获取当前元素同级的下一个节点，一般是文本节点</span></li><li><strong><code>previousSibling</code></strong><span style=\"background-color: \"rgba(0, 0, 0, 0)\";\"> ：</span><span>可以获取当前元素同级的上一个节点，一般是文本节点</span></li></ul><h4 id=\"e057f953\">元素操作API</h4><ul><li><strong><code>appendChild</code></strong> ：这个是追加子元素</li><li><strong><code>insertBefore</code></strong> ：这个是在指定元素之前插入元素</li></ul><pre data-lang=\"javascript\"><code>var insertedNode = parentNode.insertBefore(newNode, referenceNode);\n/** \n* parentNode:要插入的父节点\n* newNode: 用于插入的节点\n* referenceNode: 要插入在什么节点之前\n*/</code></pre><ul><li><strong><code>removeChild</code></strong> ：移除指定元素</li><li><strong><code>replaceChild</code></strong><span style=\"background-color: \"rgba(0, 0, 0, 0)\";\"> ：替换指定元素节点</span></li></ul><pre data-lang=\"javascript\"><code>var replacedNode = parentNode.replaceChild(newChild, oldChild);\n/** replacedNode为返回被替换掉的节点。\n*如果 newChild 以及在页面的dom元素内，会从原来的位置删除，移动到要替换的位置\n*/</code></pre><ul><li><strong><code>cloneNode</code></strong> ：克隆指定节点，可以传入 <strong><code>true Or false</code></strong> ，代表是深克隆，还是浅克隆，默认是 <strong><code>false</code></strong> </li></ul><h4 id=\"9ed04098\">创建节点API</h4><ul><li><strong><code>createElement</code></strong> ：创建指定的元素节点</li><li><strong><code>createTextNode</code></strong> ：创建指定的文本节点</li><li><strong><code>createCDATASection</code></strong> ：可以创建<span class=\"lake-fontsize-10\" style=\"color: #333333;\">CDATA 区段节点，该方法返回 CDATASection 对象。</span></li></ul><pre data-lang=\"javascript\"><code>createCDATASection(data) // data:字符串，这个字符串为节点规定数据。</code></pre><ul><li><strong><code>createComment</code></strong> ： 可创建注释节点, 并插入HTML文档</li><li><strong><code>createProcessingInstruction</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">创建一个新的处理指令节点，并返回</span></li></ul><pre data-lang=\"javascript\"><code>var docu = new DOMParser().parseFromString('&lt;xml&gt;&lt;/xml&gt;',  &quot;application/xml&quot;)\nvar pi = docu.createProcessingInstruction('xml-stylesheet', 'href=&quot;mycss.css&quot; type=&quot;text/css&quot;');\ndocu.insertBefore(pi, docu.firstChild);\nalert(new XMLSerializer().serializeToString(docu));\n// 弹出框内容: &lt;?xml-stylesheet href=&quot;mycss.css&quot; type=&quot;text/css&quot;?&gt;&lt;xml/&gt;</code></pre><ul><li><strong><code>createDocumentFragment</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">创建一个新的空白的文档片段</span></li></ul><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</span></p></blockquote><pre data-lang=\"javascript\"><code>let fragment = document.createDocumentFragment();</code></pre><ul><p><br /></p><li><strong><code>createDocumentType</code></strong> ：<span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: #FDFCF8;\">创建一个 DocumentType 节点</span></li></ul><h4 id=\"f56853d9\">属性操作API</h4><ul><li><strong><code>getAttribute</code> ：</strong>获取指定元素上指定的属性</li><li><strong><code>setAttribute</code></strong><strong> ：</strong>设置指定元素上指定的属性<br /></li><li><strong><code>removeAttribute</code></strong><strong> ：</strong>移除指定元素上指定的属性</li><li><strong><code>hasAttribute</code></strong><strong> ：</strong>判断指定元素上是否有指定的属性</li></ul><p>如果追求性能，可以把<span>Attribute 当作节点</span></p><ul><li><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">getAttributeNode</span></code></strong> </li><li><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">setAttributeNode</span></code></strong><strong> </strong></li></ul><h4 id=\"f99cb3ed\">查找元素</h4><ul><li><strong><code>querySelector</code></strong> </li><li><strong><code>querySelectorAll</code></strong> </li><li><strong><code>getElementById</code></strong> </li><li><strong><code>getElementsByName</code></strong> </li><li><strong><code>getElementsByTagName</code></strong> </li><li><strong><code>getElementsByClassName</code></strong> </li></ul><h3 id=\"5c5c679f\">事件API</h3><h4 id=\"89a275cc\">（0）鼠标事件</h4><ul><li><strong><code>mousedown</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">鼠标的键钮被按下</span>。</li><li><strong><code>mouseup</code></strong> ：<span class=\"lake-fontsize-12\">鼠标离开监听的元素上是触发</span></li><li><strong><code>mouseenter</code></strong> ：<span class=\"lake-fontsize-12\">鼠标</span><span class=\"lake-fontsize-12\" style=\"color: #333333;\">移动到元素上时就会触发（不会冒泡）</span></li><li><strong><code>mouseleave</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">指针移出元素范围外（不冒泡）</span></li><li><strong><code>click</code></strong> ：<span class=\"lake-fontsize-12\">单击鼠标的键钮。</span></li><li><strong><code>dblclick</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">在单个元素上单击两次鼠标的指针设备按钮 (通常是小鼠的主按钮) 时</span>。</li><li><strong><code>contextmenu</code></strong>  ：<span class=\"lake-fontsize-12\">弹出右键菜单。</span></li><li><strong><code>mouseover</code></strong> ：<span class=\"lake-fontsize-12\">鼠标经过元素上方就会触发（会冒泡）</span></li><li><strong><code>mouseout</code></strong> ：<span class=\"lake-fontsize-12\">鼠标移出监听的元素时触发（会冒泡）</span></li><li><strong><code>mousemove</code></strong> ：<span class=\"lake-fontsize-12\">鼠标移动的时候触发</span></li></ul><h4 id=\"f35f8583\">（1）键盘事件</h4><ul><li><strong><code>keydown</code></strong> ：<span class=\"lake-fontsize-12\">按下键盘的任意键触发</span></li><li><strong><code>keypress</code></strong> ：<span class=\"lake-fontsize-12\">除 Shift, Fn, CapsLock 外任意键被按住. (连续触发)（不常用）</span></li><li><strong><code>keyup</code></strong>  ：<span class=\"lake-fontsize-12\">按键抬起触发</span></li></ul><h4 id=\"e17fc0b0\">（2）<strong><strong>页面事件</strong></strong></h4><ul><li><strong><code>load</code></strong> ：<span class=\"lake-fontsize-12\">页面加载，一般可以看做是页面及资源加载完之后吃法</span></li><li><strong><code>pageshow</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #1A1A1A;\">该事件在页面每次加载时都会触发，也就是说，即使页面是从浏览器中读取的，也会触发这个事件</span></li><li><strong><code>unload</code></strong> ：离开页面时触发的事件，触发后无法缓存页面</li><li><strong><code>pagehide</code></strong> ：<span>离开页面时触发的事件，</span><span>触发后依然可以对页面进行缓存</span></li></ul><blockquote><p><span class=\"lake-fontsize-12\">如果同时使用 </span><span class=\"lake-fontsize-12\"><code>unload</code></span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"> 和 </span><span class=\"lake-fontsize-12\"><code><span>pagehide</span></code></span><span class=\"lake-fontsize-12\"> 这两个方法的话，会发现</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><code>onpagehide</code></span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\">会先于</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><code>onunload</code></span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\">被触发，并且在这两个事件中都无法使用</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><code>alert</code></span></p></blockquote><ul><li><strong><code>beforeunload</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #1A1A1A;\">页面关闭之前触发的事件，先于上面的两个离开页面事件被触发，同样无法使用 </span><span class=\"lake-fontsize-12\"><code>alert</code></span></li></ul><blockquote><p><span style=\"color: #000000;\"><strong>浏览器执行顺序</strong></span></p><p><span class=\"lake-fontsize-12\">onload -&gt; onpageshow -&gt; onbeforeunload -&gt; onpagehide -&gt; onunload</span></p></blockquote><h4 id=\"2015eb00\">（3）表单事件</h4><ul><li><strong><code>reset</code></strong> ：重置事件</li><li><strong><code>submit</code></strong> ：提交事件</li></ul><h4 id=\"4cec4a1d\">（4）剪贴板事件</h4><ul><li><strong><code>cut</code></strong>  ：<span class=\"lake-fontsize-12\">已经剪贴选中的文本内容并且复制到了剪贴板（剪切）</span></li><li><strong><code>copy</code></strong>：<span class=\"lake-fontsize-12\">已经把选中的文本内容复制到了剪贴板（复制）</span></li><li><strong><code>paste</code></strong>：<span class=\"lake-fontsize-12\">从剪贴板复制的文本内容被粘贴（粘贴）</span></li></ul><h4 id=\"15aac593\">（5）打印事件</h4><ul><li><strong><code>beforeprint</code></strong> ：打印机已经就绪时触发</li><li><strong><code>afterprint</code></strong>：打印机关闭时触发</li></ul><h4 id=\"a566118f\">（6）拖动事件</h4><ul><li><strong><code>dragstart</code></strong>  ：<span class=\"lake-fontsize-12\">用户准备拖动元素，也就是按住元素拖动前触发，这个时候元素未被拖动</span></li><li><strong><code>drag</code></strong>  ：<span class=\"lake-fontsize-12\">正在拖动元素或文本选区（在此过程中持续触发，每350ms触发一次）（也就相当于 mousemove）</span></li><li><strong><code>dragend</code></strong> ： <span class=\"lake-fontsize-12\">拖放操作结束 （松开鼠标按钮或按下Esc键）</span></li><li><strong><code>dragenter</code></strong>：<span class=\"lake-fontsize-12\">被拖动的元素或文本选区移入有效释放目标区</span></li><li><strong><code>dragover</code></strong>：<span class=\"lake-fontsize-12\">被拖动的元素或文本选区正在有效释放目标上被拖动 （在此过程中持续触发，每350ms触发一次）</span></li><li><strong><code>dragleave</code></strong>：<span class=\"lake-fontsize-12\">被拖动的元素或文本选区移出有效释放目标区</span></li><li><strong><code>drop</code></strong>：<span class=\"lake-fontsize-12\">元素在有效释放目标区上释放</span></li></ul><h4 id=\"1e6ba787\">（7）多媒体（Media）事件</h4><ul><li><strong><code>play</code></strong> ：<span class=\"lake-fontsize-12\">音视频播放</span></li><li><strong><code>pause</code></strong>：<span class=\"lake-fontsize-12\">音视频暂停</span></li><li><strong><code>ended</code></strong>：<span class=\"lake-fontsize-12\">监听音视频是否播放完结</span></li></ul><h4 id=\"797b0edc\">（8）动画事件</h4><ul><li><strong><code>animationstart</code></strong>：某个CSS动画开始时触发</li><li><strong><code>animationend</code></strong>：某个CSS动画完成时触发</li><li><strong><code>animationiteration</code></strong>：某个CSS动画完成后重新开始时触发</li></ul><h4 id=\"7e2f3f3a\">（9）过渡事件</h4><ul><li><strong><code>transitionstart</code></strong>：过渡开始</li><li><strong><code>transitioncancel</code></strong>：过渡去掉</li><li><strong><code>transitionend</code></strong>：过渡结束</li><li><strong><code>transitionrun</code></strong>：过渡运行时触发</li></ul><h4 id=\"1c960ba0\">（10）其他事件</h4><ul><li><strong><code>cached</code></strong>：manifest中列出的资源已经下载，应用程序现在已缓存。</li><li><strong><code>error</code></strong>：资源加载失败时</li><li><strong><code>abort</code></strong>：正在加载资源已经被中止时</li><li><strong><code>load</code></strong>：资源及其相关资源已完成加载。</li><li><strong><code>beforeunload</code></strong>：window，document 及其资源即将被卸载。</li><li><strong><code>unload</code></strong>： 文档或一个依赖资源正在被卸载。</li></ul><h3 id=\"bf13c833\">Range  API（一般应用在富文本领域）</h3><blockquote><p><code><span class=\"lake-fontsize-12\" style=\"color: #222222;\">Range API</span></code> <span class=\"lake-fontsize-12\" style=\"color: #222222;\"> 表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。</span></p><p><span class=\"lake-fontsize-12\">只有做底层框架和富文本编辑对它有强需求</span></p></blockquote><h3 id=\"54898fa9\">遍历</h3><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #222222;\">如果需要遍历 DOM 的时候，直接使用递归和 Node 的属性。</span></p></blockquote><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [<span style=\"color: #222222;\">DOM的API</span>]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555293932589-c499b920-7e29-4340-847f-940e83b14666.jpeg&quot;</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%221HAPr%22%7D\"></card><h2 id=\"NXGn0\"><span style=\"background-color: transparent;\"><cursor />前言</span></h2><p>我们前端所操控的方法 <strong><code>API</code></strong> 总的来说分两大类</p><ul><li><strong><span class=\"lake-fontsize-12\">浏览器对象模型：</span></strong><span class=\"lake-fontsize-12\">就是我们经常依赖的环境-浏览器。浏览器会提供一些  </span><strong><code><span class=\"lake-fontsize-12\">API</span></code></strong> <span class=\"lake-fontsize-12\">，方便我们操作，但是并不是所有的方法都是标准里面的，需要区分哪些是浏览器这个环境提供的，哪些是 </span><strong><code><span class=\"lake-fontsize-12\">ECMA</span></code></strong> <span class=\"lake-fontsize-12\">标准里面的</span></li><li><strong><span class=\"lake-fontsize-12\">文档对象模型：</span></strong><span class=\"lake-fontsize-12\">也就是我们经常使用的 </span><strong><code><span class=\"lake-fontsize-12\">DOM API</span></code></strong> ，用来操作页面元素</li></ul><h2 id=\"1301fe28\">DOM的API分类</h2><ul><li><strong>节点</strong>：节点操作</li><li><strong>事件</strong>：触发或者监听方面的 <code>API</code> </li><li><strong><code>Range</code></strong> ：操作文字方面的 <code>API</code> </li><li><strong>遍历 ：</strong>遍历 <code>DOM</code> 需要的 <code>API</code> </li></ul><h3 id=\"21b9f161\">节点API</h3><h4 id=\"a6967bfc\">Node节点</h4><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1555299624515-0b283c44-3013-45f3-a03a-84102129c400.png%22%2C%22originWidth%22%3A955%2C%22originHeight%22%3A634%2C%22name%22%3A%226e278e450d8cc7122da3616fd18b9cf6.png%22%2C%22size%22%3A96882%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A495%7D\"></card></p><p><br /></p><blockquote><p>一般来说。我们工作中经常碰到的有两种节点：文本节点或者元素节点</p></blockquote><p><br /></p><h4 id=\"ec4b57af\">元素节点关系API</h4><ul><li><strong><code>parentNode</code></strong> :可以获取父级元素节点</li><li><strong><code>childNodes</code></strong> <span>:可以获取子级所有节点，包括元素节点，文本节点</span></li><li><strong><code>firstChild</code></strong> <span>:可以获取当前元素的第一个节点，一般是文本节点</span></li><li><strong><code>lastChild</code></strong> ：<span>可以获取当前元素的最后一个节点，一般是文本节点</span></li><li><strong><code>nextSibling</code></strong> ：<span>可以获取当前元素同级的下一个节点，一般是文本节点</span></li><li><strong><code>previousSibling</code></strong><span style=\"background-color: rgba(0, 0, 0, 0);\"> ：</span><span>可以获取当前元素同级的上一个节点，一般是文本节点</span></li></ul><h4 id=\"e057f953\">元素操作API</h4><ul><li><strong><code>appendChild</code></strong> ：这个是追加子元素</li><li><strong><code>insertBefore</code></strong> ：这个是在指定元素之前插入元素</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20insertedNode%20%3D%20parentNode.insertBefore(newNode%2C%20referenceNode)%3B%5Cn%2F**%20%5Cn*%20parentNode%3A%E8%A6%81%E6%8F%92%E5%85%A5%E7%9A%84%E7%88%B6%E8%8A%82%E7%82%B9%5Cn*%20newNode%3A%20%E7%94%A8%E4%BA%8E%E6%8F%92%E5%85%A5%E7%9A%84%E8%8A%82%E7%82%B9%5Cn*%20referenceNode%3A%20%E8%A6%81%E6%8F%92%E5%85%A5%E5%9C%A8%E4%BB%80%E4%B9%88%E8%8A%82%E7%82%B9%E4%B9%8B%E5%89%8D%5Cn*%2F%22%2C%22id%22%3A%2239E1w%22%7D\"></card><ul><li><strong><code>removeChild</code></strong> ：移除指定元素</li><li><strong><code>replaceChild</code></strong><span style=\"background-color: rgba(0, 0, 0, 0);\"> ：替换指定元素节点</span></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20replacedNode%20%3D%20parentNode.replaceChild(newChild%2C%20oldChild)%3B%5Cn%2F**%20replacedNode%E4%B8%BA%E8%BF%94%E5%9B%9E%E8%A2%AB%E6%9B%BF%E6%8D%A2%E6%8E%89%E7%9A%84%E8%8A%82%E7%82%B9%E3%80%82%5Cn*%E5%A6%82%E6%9E%9C%20newChild%20%E4%BB%A5%E5%8F%8A%E5%9C%A8%E9%A1%B5%E9%9D%A2%E7%9A%84dom%E5%85%83%E7%B4%A0%E5%86%85%EF%BC%8C%E4%BC%9A%E4%BB%8E%E5%8E%9F%E6%9D%A5%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%88%A0%E9%99%A4%EF%BC%8C%E7%A7%BB%E5%8A%A8%E5%88%B0%E8%A6%81%E6%9B%BF%E6%8D%A2%E7%9A%84%E4%BD%8D%E7%BD%AE%5Cn*%2F%22%2C%22id%22%3A%22j1DPP%22%7D\"></card><ul><li><strong><code>cloneNode</code></strong> ：克隆指定节点，可以传入 <strong><code>true Or false</code></strong> ，代表是深克隆，还是浅克隆，默认是 <strong><code>false</code></strong> </li></ul><h4 id=\"9ed04098\">创建节点API</h4><ul><li><strong><code>createElement</code></strong> ：创建指定的元素节点</li><li><strong><code>createTextNode</code></strong> ：创建指定的文本节点</li><li><strong><code>createCDATASection</code></strong> ：可以创建<span class=\"lake-fontsize-10\" style=\"color: #333333;\">CDATA 区段节点，该方法返回 CDATASection 对象。</span></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22createCDATASection(data)%20%2F%2F%20data%3A%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E8%BF%99%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%BA%E8%8A%82%E7%82%B9%E8%A7%84%E5%AE%9A%E6%95%B0%E6%8D%AE%E3%80%82%22%2C%22id%22%3A%22saqkQ%22%7D\"></card><ul><li><strong><code>createComment</code></strong> ： 可创建注释节点, 并插入HTML文档</li><li><strong><code>createProcessingInstruction</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">创建一个新的处理指令节点，并返回</span></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20docu%20%3D%20new%20DOMParser().parseFromString('%3Cxml%3E%3C%2Fxml%3E'%2C%20%20%5C%22application%2Fxml%5C%22)%5Cnvar%20pi%20%3D%20docu.createProcessingInstruction('xml-stylesheet'%2C%20'href%3D%5C%22mycss.css%5C%22%20type%3D%5C%22text%2Fcss%5C%22')%3B%5Cndocu.insertBefore(pi%2C%20docu.firstChild)%3B%5Cnalert(new%20XMLSerializer().serializeToString(docu))%3B%5Cn%2F%2F%20%E5%BC%B9%E5%87%BA%E6%A1%86%E5%86%85%E5%AE%B9%3A%20%3C%3Fxml-stylesheet%20href%3D%5C%22mycss.css%5C%22%20type%3D%5C%22text%2Fcss%5C%22%3F%3E%3Cxml%2F%3E%22%2C%22id%22%3A%22oHtD1%22%7D\"></card><ul><li><strong><code>createDocumentFragment</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">创建一个新的空白的文档片段</span></li></ul><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。</span></p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20fragment%20%3D%20document.createDocumentFragment()%3B%22%2C%22id%22%3A%22ke6oY%22%7D\"></card><ul><p><br /></p><li><strong><code>createDocumentType</code></strong> ：<span class=\"lake-fontsize-11\" style=\"color: #000000; background-color: #FDFCF8;\">创建一个 DocumentType 节点</span></li></ul><h4 id=\"f56853d9\">属性操作API</h4><ul><li><strong><code>getAttribute</code> ：</strong>获取指定元素上指定的属性</li><li><strong><code>setAttribute</code></strong><strong> ：</strong>设置指定元素上指定的属性<br /></li><li><strong><code>removeAttribute</code></strong><strong> ：</strong>移除指定元素上指定的属性</li><li><strong><code>hasAttribute</code></strong><strong> ：</strong>判断指定元素上是否有指定的属性</li></ul><p>如果追求性能，可以把<span>Attribute 当作节点</span></p><ul><li><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">getAttributeNode</span></code></strong> </li><li><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">setAttributeNode</span></code></strong><strong> </strong></li></ul><h4 id=\"f99cb3ed\">查找元素</h4><ul><li><strong><code>querySelector</code></strong> </li><li><strong><code>querySelectorAll</code></strong> </li><li><strong><code>getElementById</code></strong> </li><li><strong><code>getElementsByName</code></strong> </li><li><strong><code>getElementsByTagName</code></strong> </li><li><strong><code>getElementsByClassName</code></strong> </li></ul><h3 id=\"5c5c679f\">事件API</h3><h4 id=\"89a275cc\">（0）鼠标事件</h4><ul><li><strong><code>mousedown</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">鼠标的键钮被按下</span>。</li><li><strong><code>mouseup</code></strong> ：<span class=\"lake-fontsize-12\">鼠标离开监听的元素上是触发</span></li><li><strong><code>mouseenter</code></strong> ：<span class=\"lake-fontsize-12\">鼠标</span><span class=\"lake-fontsize-12\" style=\"color: #333333;\">移动到元素上时就会触发（不会冒泡）</span></li><li><strong><code>mouseleave</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">指针移出元素范围外（不冒泡）</span></li><li><strong><code>click</code></strong> ：<span class=\"lake-fontsize-12\">单击鼠标的键钮。</span></li><li><strong><code>dblclick</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #333333;\">在单个元素上单击两次鼠标的指针设备按钮 (通常是小鼠的主按钮) 时</span>。</li><li><strong><code>contextmenu</code></strong>  ：<span class=\"lake-fontsize-12\">弹出右键菜单。</span></li><li><strong><code>mouseover</code></strong> ：<span class=\"lake-fontsize-12\">鼠标经过元素上方就会触发（会冒泡）</span></li><li><strong><code>mouseout</code></strong> ：<span class=\"lake-fontsize-12\">鼠标移出监听的元素时触发（会冒泡）</span></li><li><strong><code>mousemove</code></strong> ：<span class=\"lake-fontsize-12\">鼠标移动的时候触发</span></li></ul><h4 id=\"f35f8583\">（1）键盘事件</h4><ul><li><strong><code>keydown</code></strong> ：<span class=\"lake-fontsize-12\">按下键盘的任意键触发</span></li><li><strong><code>keypress</code></strong> ：<span class=\"lake-fontsize-12\">除 Shift, Fn, CapsLock 外任意键被按住. (连续触发)（不常用）</span></li><li><strong><code>keyup</code></strong>  ：<span class=\"lake-fontsize-12\">按键抬起触发</span></li></ul><h4 id=\"e17fc0b0\">（2）<strong><strong>页面事件</strong></strong></h4><ul><li><strong><code>load</code></strong> ：<span class=\"lake-fontsize-12\">页面加载，一般可以看做是页面及资源加载完之后吃法</span></li><li><strong><code>pageshow</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #1A1A1A;\">该事件在页面每次加载时都会触发，也就是说，即使页面是从浏览器中读取的，也会触发这个事件</span></li><li><strong><code>unload</code></strong> ：离开页面时触发的事件，触发后无法缓存页面</li><li><strong><code>pagehide</code></strong> ：<span>离开页面时触发的事件，</span><span>触发后依然可以对页面进行缓存</span></li></ul><blockquote><p><span class=\"lake-fontsize-12\">如果同时使用 </span><span class=\"lake-fontsize-12\"><code>unload</code></span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"> 和 </span><span class=\"lake-fontsize-12\"><code><span>pagehide</span></code></span><span class=\"lake-fontsize-12\"> 这两个方法的话，会发现</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><code>onpagehide</code></span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\">会先于</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><code>onunload</code></span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\">被触发，并且在这两个事件中都无法使用</span><span class=\"lake-fontsize-12\"> </span><span class=\"lake-fontsize-12\"><code>alert</code></span></p></blockquote><ul><li><strong><code>beforeunload</code></strong> ：<span class=\"lake-fontsize-12\" style=\"color: #1A1A1A;\">页面关闭之前触发的事件，先于上面的两个离开页面事件被触发，同样无法使用 </span><span class=\"lake-fontsize-12\"><code>alert</code></span></li></ul><blockquote><p><span style=\"color: #000000;\"><strong>浏览器执行顺序</strong></span></p><p><span class=\"lake-fontsize-12\">onload -&gt; onpageshow -&gt; onbeforeunload -&gt; onpagehide -&gt; onunload</span></p></blockquote><h4 id=\"2015eb00\">（3）表单事件</h4><ul><li><strong><code>reset</code></strong> ：重置事件</li><li><strong><code>submit</code></strong> ：提交事件</li></ul><h4 id=\"4cec4a1d\">（4）剪贴板事件</h4><ul><li><strong><code>cut</code></strong>  ：<span class=\"lake-fontsize-12\">已经剪贴选中的文本内容并且复制到了剪贴板（剪切）</span></li><li><strong><code>copy</code></strong>：<span class=\"lake-fontsize-12\">已经把选中的文本内容复制到了剪贴板（复制）</span></li><li><strong><code>paste</code></strong>：<span class=\"lake-fontsize-12\">从剪贴板复制的文本内容被粘贴（粘贴）</span></li></ul><h4 id=\"15aac593\">（5）打印事件</h4><ul><li><strong><code>beforeprint</code></strong> ：打印机已经就绪时触发</li><li><strong><code>afterprint</code></strong>：打印机关闭时触发</li></ul><h4 id=\"a566118f\">（6）拖动事件</h4><ul><li><strong><code>dragstart</code></strong>  ：<span class=\"lake-fontsize-12\">用户准备拖动元素，也就是按住元素拖动前触发，这个时候元素未被拖动</span></li><li><strong><code>drag</code></strong>  ：<span class=\"lake-fontsize-12\">正在拖动元素或文本选区（在此过程中持续触发，每350ms触发一次）（也就相当于 mousemove）</span></li><li><strong><code>dragend</code></strong> ： <span class=\"lake-fontsize-12\">拖放操作结束 （松开鼠标按钮或按下Esc键）</span></li><li><strong><code>dragenter</code></strong>：<span class=\"lake-fontsize-12\">被拖动的元素或文本选区移入有效释放目标区</span></li><li><strong><code>dragover</code></strong>：<span class=\"lake-fontsize-12\">被拖动的元素或文本选区正在有效释放目标上被拖动 （在此过程中持续触发，每350ms触发一次）</span></li><li><strong><code>dragleave</code></strong>：<span class=\"lake-fontsize-12\">被拖动的元素或文本选区移出有效释放目标区</span></li><li><strong><code>drop</code></strong>：<span class=\"lake-fontsize-12\">元素在有效释放目标区上释放</span></li></ul><h4 id=\"1e6ba787\">（7）多媒体（Media）事件</h4><ul><li><strong><code>play</code></strong> ：<span class=\"lake-fontsize-12\">音视频播放</span></li><li><strong><code>pause</code></strong>：<span class=\"lake-fontsize-12\">音视频暂停</span></li><li><strong><code>ended</code></strong>：<span class=\"lake-fontsize-12\">监听音视频是否播放完结</span></li></ul><h4 id=\"797b0edc\">（8）动画事件</h4><ul><li><strong><code>animationstart</code></strong>：某个CSS动画开始时触发</li><li><strong><code>animationend</code></strong>：某个CSS动画完成时触发</li><li><strong><code>animationiteration</code></strong>：某个CSS动画完成后重新开始时触发</li></ul><h4 id=\"7e2f3f3a\">（9）过渡事件</h4><ul><li><strong><code>transitionstart</code></strong>：过渡开始</li><li><strong><code>transitioncancel</code></strong>：过渡去掉</li><li><strong><code>transitionend</code></strong>：过渡结束</li><li><strong><code>transitionrun</code></strong>：过渡运行时触发</li></ul><h4 id=\"1c960ba0\">（10）其他事件</h4><ul><li><strong><code>cached</code></strong>：manifest中列出的资源已经下载，应用程序现在已缓存。</li><li><strong><code>error</code></strong>：资源加载失败时</li><li><strong><code>abort</code></strong>：正在加载资源已经被中止时</li><li><strong><code>load</code></strong>：资源及其相关资源已完成加载。</li><li><strong><code>beforeunload</code></strong>：window，document 及其资源即将被卸载。</li><li><strong><code>unload</code></strong>： 文档或一个依赖资源正在被卸载。</li></ul><h3 id=\"bf13c833\">Range  API（一般应用在富文本领域）</h3><blockquote><p><code><span class=\"lake-fontsize-12\" style=\"color: #222222;\">Range API</span></code> <span class=\"lake-fontsize-12\" style=\"color: #222222;\"> 表示一个 HTML 上的范围，这个范围是以文字为最小单位的，所以 Range 不一定包含完整的节点，它可能是 Text 节点中的一段，也可以是头尾两个 Text 的一部分加上中间的元素。</span></p><p><span class=\"lake-fontsize-12\">只有做底层框架和富文本编辑对它有强需求</span></p></blockquote><h3 id=\"54898fa9\">遍历</h3><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #222222;\">如果需要遍历 DOM 的时候，直接使用递归和 Node 的属性。</span></p></blockquote><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:59:22.000Z",
    "deleted_at": null,
    "created_at": "2019-04-15T01:50:41.000Z",
    "updated_at": "2019-04-28T01:59:22.000Z",
    "published_at": "2019-04-28T01:59:22.000Z",
    "first_published_at": "2019-04-15T02:48:54.000Z",
    "word_count": 1913,
    "cover": null,
    "description": "tags: [DOM的API]categories: 重学前端系列笔记cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555293932589-c499b920-7e29-4340-847f-940e83b14666.j...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1521419,
    "slug": "xbt6pi",
    "title": "9.头部 head 里可以有哪些标签",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [head里可以放那些标签]<br />categories: 重学前端系列笔记\n\n---\n<a name=\"IUeSj\"></a>\n### title标签\n> **`title`** 标签表示的是网页的标题。\n\n![snipaste_20190412_104309.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1555037047336-a29488e6-0099-4e46-9c08-afce1bbb6bc7.png#align=left&display=inline&height=129&name=snipaste_20190412_104309.png&originHeight=64&originWidth=369&size=5897&status=done&width=746)\n\n**`title`** 在浏览器收藏夹、微信推送卡片、微博还有各种分享的时候， **`title`** 标签内的内容需要对当前页面的内容做个总的概况。\n\n<a name=\"228db434\"></a>\n### base标签\n> **`base`**  指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个  元素。\n\n\n```html\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>和我刘华强拼，你有这实力嘛</title>\n    <base href=\"wuxin.netlify.com\" target=\"_blank/_parent/_self/_top/framename\">\n</head>\n```\n\n- 可以使用 **`document.baseURI`** 获取当前页面的基准路径\n- **`base`**`document.baseURI=\"https://www.baidu,com`**`\"`  \n- 这个标签容易跟 **`JavaScript`** 脚本配合出错，所以不建议使用\n<a name=\"e7096204\"></a>\n### meta标签\n表示那些不能由其它HTML元相关元素 > ` `> **`(<base>, <link>, <script>, <style> 或 <title>)`**  之一表示的任何元数据信息，通常是那种键值对形式的。他除了一些基础用法，还包括一些变体，主要是用来简化书写方式以及简化自动化行为\n<a name=\"851d084c\"></a>\n#### charset属性\n\n- 这个元素描述了这个 **`HTML`** 文档是以何种文档编码的。\n- **`charset`**`meta`**`head`** 标签的最前面，这样在页面解析的时候不会乱码。\n```html\n<head>\n    <meta charset=\"UTF-8\">\n</head>\n```\n\n<a name=\"7c550811\"></a>\n#### http-equiv属性\n> 这个枚举属性定义了能改变服务器和用户引擎行为的编译\n\n\n他的值有很多 **`content-language（过时,已经使用lang属性代替）、content-type（）、content-security-policy（内容安全策略）`** \n\n<a name=\"content-security-policy\"></a>\n##### content-security-policy\n> 用于指定的服务端源以及脚本端点，有助于防止脚本攻击\n\n```html\n<meta http-equiv=\"content-security-policy\" content=\"default-src https:地址\">\n```\n具体的值很多，详情可以参照 [MDN的Content-Security-Policy](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid)\n\n<a name=\"content-type\"></a>\n##### content-type\n> 用于指定文档的 **`MIME TYPE`** \n\n\n```html\n/*这个指定http协议下，文件的编码格式/\n<meta http-equiv=\"content-type\" content=\"text/html; charset=UTF-8\"> \n```\n\n- 因为是写在 **`HTML`**`text/html`** 才有效果。设置其他的起不了作用\n- 这类 **`meta`**`charset`**`lang`** 给代替了\n\n<a name=\"default-style\"></a>\n##### **default-style**\n\n- 这个属性可以定义，页面加载的首选样式\n<a name=\"5ebf7738\"></a>\n##### **refresh（刷新）**\n这个属性指定:\n\n  - 如果  **`[content](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content)`** 只包含一个正整数,则是重新载入页面的时间间隔(秒);\n  - 如果  **`[content](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content)` **包含一个正整数并且跟着一个字符串,则是重定向到指定链接的时间间隔(秒)\n<a name=\"4fd242dc\"></a>\n##### **set-cookie(已经被废弃，由JavaScript脚本控制)**\n<a name=\"9eb346ba\"></a>\n##### x-ua-compatible：模拟 http 头 x-ua-compatible，声明 ua 兼容\n<a name=\"3b3099f3\"></a>\n#### viewport属性\n> 它提供有关视口初始大小的提示，仅供移动设备使用。\n\n<br />\n```html\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n```\n它的值有：\n\n- **`width`**`device-width`** ，表示跟设备宽度相等。\n- **`height`**`device-height`** ，表示跟设备高度相等。\n- **`initial-scale`** ：初始缩放比例。\n- **`minimum-scale`** ：最小缩放比例。\n- **`maximum-scale`** ：最大缩放比例。\n- **`user-scalable`** ：是否允许用户缩放。\n\n**这个属性不是HTML标准里的，是行业规范的**\n\n<a name=\"4c07161c\"></a>\n#### 其他的属性\n\n- **`author`** : 页面作者。\n- **`description`** ：页面描述，这个属性可能被用于搜索引擎或者其它场合。\n- **`generator`** : 生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta。\n- **`keywords`** : 页面关键字，对于 SEO 场景非常关键。\n- **`referrer`** : 跳转策略，是一种安全考量。\n- **`theme-color`** : 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）。\n<a name=\"ad6873b9\"></a>\n### 常见的meta设置\n```html\n<meta http-equiv=\"X-UA-Compatible\" content=\"IE=edge,chrome=1\">\n<!-- 默认使用最新浏览器 -->\n<meta http-equiv=\"Cache-Control\" content=\"no-siteapp\">\n<!-- 不被网页(加速)转码 -->\n<meta name=\"robots\" content=\"index,follow\">\n<!-- 搜索引擎抓取 -->\n<meta name=\"renderer\" content=\"webkit\">\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui\">\n<meta name=\"apple-mobile-web-app-capable\" content=\"yes\">\n<!-- 删除苹果默认的工具栏和菜单栏 -->\n<meta name=\"apple-mobile-web-app-status-bar-style\" content=\"black-translucent\">\n<!-- 设置苹果工具栏颜色 -->\n```\n\n关闭 **iOS **内容识别\n```html\n<meta name=\"format-detection\" content=\"telephone=no\">\n<meta name=\"format-detection\" content=\"date=no\">\n<meta name=\"format-detection\" content=\"address=no\">\n<meta name=\"format-detection\" content=\"email=no\">\n```\n\n<a name=\"a9b648bd\"></a>\n### 其他的标签\n\n1.  `Open Graph`  的标签组，包括 `title, type, URL, site_name, description`  和 `image` ，是为 `Facebook`  分享提供信息；\n1.  `Twitter`  的标签组，包括 `card, title, description`  和 `image` ，是为 `Twitter`  分享提供信息；\n1.  `msapplication`  的标签组，包括 `TileColor 和 TileImage` ，是为 `Windows 8`  以及以上系统识别 `favicons`  用的。\n",
    "body_draft": "",
    "body_html": "<p>tags: [head里可以放那些标签]</p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"IUeSj\">title标签</h3><blockquote><p><strong><code>title</code></strong> 标签表示的是网页的标题。</p></blockquote><p><img alt=\"snipaste_20190412_104309.png\" title=\"snipaste_20190412_104309.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1555037047336-a29488e6-0099-4e46-9c08-afce1bbb6bc7.png#align=left&amp;display=inline&amp;height=129&amp;name=snipaste_20190412_104309.png&amp;originHeight=64&amp;originWidth=369&amp;size=5897&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p><strong><code>title</code></strong> 在浏览器收藏夹、微信推送卡片、微博还有各种分享的时候， <strong><code>title</code></strong> 标签内的内容需要对当前页面的内容做个总的概况。</p><p><br /></p><h3 id=\"228db434\">base标签</h3><blockquote><p><span class=\"lake-fontsize-12\"><strong><code>base</code></strong></span><span class=\"lake-fontsize-12\">  指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个  元素。</span></p></blockquote><p><br /></p><pre data-lang=\"html\"><code>&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;\n    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;\n    &lt;title&gt;和我刘华强拼，你有这实力嘛&lt;/title&gt;\n    &lt;base href=&quot;wuxin.netlify.com&quot; target=&quot;_blank/_parent/_self/_top/framename&quot;&gt;\n&lt;/head&gt;</code></pre><p><br /></p><ul><li>可以使用 <strong><code>document.baseURI</code></strong> 获取当前页面的基准路径</li><li><strong><code>base</code></strong> 标签里的内容指定之后，是改变不了的。无法使用平常的 <strong><code>document.baseURI=&quot;https://www.baidu,com</code></strong><code>&quot;</code>  </li><li>这个标签容易跟 <strong><code>JavaScript</code></strong> 脚本配合出错，所以不建议使用</li></ul><h3 id=\"e7096204\">meta标签</h3><blockquote>表示那些不能由其它HTML元相关元素 <code> </code><strong><code>(&lt;base&gt;, &lt;link&gt;, &lt;script&gt;, &lt;style&gt; 或 &lt;title&gt;)</code></strong>  之一表示的任何元数据信息，通常是那种键值对形式的。他除了一些基础用法，还包括一些变体，主要是用来简化书写方式以及简化自动化行为</blockquote><h4 id=\"851d084c\">charset属性</h4><ul><li>这个元素描述了这个 <strong><code>HTML</code></strong> 文档是以何种文档编码的。</li><li><strong><code>charset</code></strong> 类型的 <strong><code>meta</code></strong> 标签，一般是写在 <strong><code>head</code></strong> 标签的最前面，这样在页面解析的时候不会乱码。</li></ul><pre data-lang=\"html\"><code>&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n&lt;/head&gt;</code></pre><p><br /></p><h4 id=\"7c550811\">http-equiv属性</h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">这个枚举属性定义了能改变服务器和用户引擎行为的编译</span></p></blockquote><p><br /></p><p>他的值有很多 <strong><code>content-language（过时,已经使用lang属性代替）、content-type（）、content-security-policy（内容安全策略）</code></strong> </p><p><br /></p><h5 id=\"content-security-policy\">content-security-policy</h5><blockquote><p>用于指定的服务端源以及脚本端点，有助于防止脚本攻击</p></blockquote><pre data-lang=\"html\"><code>&lt;meta http-equiv=&quot;content-security-policy&quot; content=&quot;default-src https:地址&quot;&gt;</code></pre><p>具体的值很多，详情可以参照 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid\" target=\"_blank\">MDN的Content-Security-Policy</a></p><p><br /></p><h5 id=\"content-type\">content-type</h5><blockquote><p>用于指定文档的 <strong><code>MIME TYPE</code></strong> </p></blockquote><p><br /></p><pre data-lang=\"html\"><code>/*这个指定http协议下，文件的编码格式/\n&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt; </code></pre><p><br /></p><ul><li>因为是写在 <strong><code>HTML</code></strong> 文件内，所以一般是只有设置为 <strong><code>text/html</code></strong> 才有效果。设置其他的起不了作用</li><li>这类 <strong><code>meta</code></strong> 属性标签，已经过时，被 <strong><code>charset</code></strong> 和 <strong><code>lang</code></strong> 给代替了</li></ul><p><br /></p><h5 id=\"default-style\"><strong>default-style</strong></h5><ul><li>这个属性可以定义，页面加载的首选样式</li></ul><h5 id=\"5ebf7738\"><strong>refresh（刷新）</strong></h5><p style=\"text-indent: 2em;\">这个属性指定:</p><ul data-lake-indent=\"1\"><li>如果  <strong><code><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content\" target=\"_blank\">content</a></code></strong> 只包含一个正整数,则是重新载入页面的时间间隔(秒);</li><li>如果  <strong><code><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content\" target=\"_blank\">content</a></code></strong><strong> </strong>包含一个正整数并且跟着一个字符串,则是重定向到指定链接的时间间隔(秒)</li></ul><h5 id=\"4fd242dc\"><strong>set-cookie(已经被废弃，由JavaScript脚本控制)</strong></h5><h5 id=\"9eb346ba\"><span class=\"lake-fontsize-10\" style=\"color: #222222;\">x-ua-compatible：模拟 http 头 x-ua-compatible，声明 ua 兼容</span></h5><h4 id=\"3b3099f3\">viewport属性</h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">它提供有关视口初始大小的提示，仅供移动设备使用。</span></p></blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\"><br /></span></p><pre data-lang=\"html\"><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></pre><p>它的值有：</p><ul><li><strong><code>width</code></strong> ：页面宽度，可以取值具体的数字，也可以是 <strong><code>device-width</code></strong> ，表示跟设备宽度相等。</li><li><strong><code>height</code></strong> ：页面高度，可以取值具体的数字，也可以是 <strong><code>device-height</code></strong> ，表示跟设备高度相等。</li><li><strong><code>initial-scale</code></strong> ：初始缩放比例。</li><li><strong><code>minimum-scale</code></strong> ：最小缩放比例。</li><li><strong><code>maximum-scale</code></strong> ：最大缩放比例。</li><li><strong><code>user-scalable</code></strong> ：是否允许用户缩放。</li></ul><p><span style=\"color: #F5222D;\"><strong><span class=\"lake-fontsize-12\">这个属性不是HTML标准里的，是行业规范的</span></strong></span></p><p><br /></p><h4 id=\"4c07161c\">其他的属性</h4><ul><li><strong><code>author</code></strong> : 页面作者。</li><li><strong><code>description</code></strong> ：页面描述，这个属性可能被用于搜索引擎或者其它场合。</li><li><strong><code>generator</code></strong> : 生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta。</li><li><strong><code>keywords</code></strong> : 页面关键字，对于 SEO 场景非常关键。</li><li><strong><code>referrer</code></strong> : 跳转策略，是一种安全考量。</li><li><strong><code>theme-color</code></strong> : 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）。</li></ul><h3 id=\"ad6873b9\">常见的meta设置</h3><pre data-lang=\"html\"><code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;\n&lt;!-- 默认使用最新浏览器 --&gt;\n&lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-siteapp&quot;&gt;\n&lt;!-- 不被网页(加速)转码 --&gt;\n&lt;meta name=&quot;robots&quot; content=&quot;index,follow&quot;&gt;\n&lt;!-- 搜索引擎抓取 --&gt;\n&lt;meta name=&quot;renderer&quot; content=&quot;webkit&quot;&gt;\n&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui&quot;&gt;\n&lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt;\n&lt;!-- 删除苹果默认的工具栏和菜单栏 --&gt;\n&lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black-translucent&quot;&gt;\n&lt;!-- 设置苹果工具栏颜色 --&gt;</code></pre><p><br /></p><p>关闭 <strong>iOS </strong>内容识别</p><pre data-lang=\"html\"><code>&lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no&quot;&gt;\n&lt;meta name=&quot;format-detection&quot; content=&quot;date=no&quot;&gt;\n&lt;meta name=&quot;format-detection&quot; content=&quot;address=no&quot;&gt;\n&lt;meta name=&quot;format-detection&quot; content=&quot;email=no&quot;&gt;</code></pre><p><br /></p><h3 id=\"a9b648bd\">其他的标签</h3><ol start=\"1\"><li><span style=\"color: #505050;\"> </span><code><span style=\"color: #505050;\">Open Graph</span></code> <span style=\"color: #505050;\"> 的标签组，包括 </span><code><span style=\"color: #505050;\">title, type, URL, site_name, description</span></code> <span style=\"color: #505050;\"> 和 </span><code><span style=\"color: #505050;\">image</span></code> <span style=\"color: #505050;\">，是为 </span><code><span style=\"color: #505050;\">Facebook</span></code> <span style=\"color: #505050;\"> 分享提供信息；</span></li><li><span style=\"color: #505050;\"> </span><code><span style=\"color: #505050;\">Twitter</span></code> <span style=\"color: #505050;\"> 的标签组，包括 </span><code><span style=\"color: #505050;\">card, title, description</span></code> <span style=\"color: #505050;\"> 和 </span><code><span style=\"color: #505050;\">image</span></code> <span style=\"color: #505050;\">，是为 </span><code><span style=\"color: #505050;\">Twitter</span></code> <span style=\"color: #505050;\"> 分享提供信息；</span></li><li><span style=\"color: #505050;\"> </span><code><span style=\"color: #505050;\">msapplication</span></code> <span style=\"color: #505050;\"> 的标签组，包括 </span><code><span style=\"color: #505050;\">TileColor 和 TileImage</span></code> <span style=\"color: #505050;\">，是为 </span><code><span style=\"color: #505050;\">Windows 8</span></code> <span style=\"color: #505050;\"> 以及以上系统识别 </span><code><span style=\"color: #505050;\">favicons</span></code> <span style=\"color: #505050;\"> 用的。</span></li></ol>",
    "body_lake": "<!doctype lake><p>tags: [head里可以放那些标签]</p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%2267Yo5%22%7D\"></card><h3 id=\"IUeSj\">title标签<cursor /></h3><blockquote><p><strong><code>title</code></strong> 标签表示的是网页的标题。</p></blockquote><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1555037047336-a29488e6-0099-4e46-9c08-afce1bbb6bc7.png%22%2C%22originWidth%22%3A369%2C%22originHeight%22%3A64%2C%22name%22%3A%22snipaste_20190412_104309.png%22%2C%22size%22%3A5897%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A129%7D\"></card></p><p><br /></p><p><strong><code>title</code></strong> 在浏览器收藏夹、微信推送卡片、微博还有各种分享的时候， <strong><code>title</code></strong> 标签内的内容需要对当前页面的内容做个总的概况。</p><p><br /></p><h3 id=\"228db434\">base标签</h3><blockquote><p><span class=\"lake-fontsize-12\"><strong><code>base</code></strong></span><span class=\"lake-fontsize-12\">  指定用于一个文档中包含的所有相对 URL 的根 URL。一份中只能有一个  元素。</span></p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Chead%3E%5Cn%20%20%20%20%3Cmeta%20charset%3D%5C%22UTF-8%5C%22%3E%5Cn%20%20%20%20%3Cmeta%20name%3D%5C%22viewport%5C%22%20content%3D%5C%22width%3Ddevice-width%2C%20initial-scale%3D1.0%5C%22%3E%5Cn%20%20%20%20%3Cmeta%20http-equiv%3D%5C%22X-UA-Compatible%5C%22%20content%3D%5C%22ie%3Dedge%5C%22%3E%5Cn%20%20%20%20%3Ctitle%3E%E5%92%8C%E6%88%91%E5%88%98%E5%8D%8E%E5%BC%BA%E6%8B%BC%EF%BC%8C%E4%BD%A0%E6%9C%89%E8%BF%99%E5%AE%9E%E5%8A%9B%E5%98%9B%3C%2Ftitle%3E%5Cn%20%20%20%20%3Cbase%20href%3D%5C%22wuxin.netlify.com%5C%22%20target%3D%5C%22_blank%2F_parent%2F_self%2F_top%2Fframename%5C%22%3E%5Cn%3C%2Fhead%3E%22%2C%22id%22%3A%22d7eM0%22%7D\"></card><p><br /></p><ul><li>可以使用 <strong><code>document.baseURI</code></strong> 获取当前页面的基准路径</li><li><strong><code>base</code></strong> 标签里的内容指定之后，是改变不了的。无法使用平常的 <strong><code>document.baseURI=&quot;https://www.baidu,com</code></strong><code>&quot;</code>  </li><li>这个标签容易跟 <strong><code>JavaScript</code></strong> 脚本配合出错，所以不建议使用</li></ul><h3 id=\"e7096204\">meta标签</h3><blockquote>表示那些不能由其它HTML元相关元素 <code> </code><strong><code>(&lt;base&gt;, &lt;link&gt;, &lt;script&gt;, &lt;style&gt; 或 &lt;title&gt;)</code></strong>  之一表示的任何元数据信息，通常是那种键值对形式的。他除了一些基础用法，还包括一些变体，主要是用来简化书写方式以及简化自动化行为</blockquote><h4 id=\"851d084c\">charset属性</h4><ul><li>这个元素描述了这个 <strong><code>HTML</code></strong> 文档是以何种文档编码的。</li><li><strong><code>charset</code></strong> 类型的 <strong><code>meta</code></strong> 标签，一般是写在 <strong><code>head</code></strong> 标签的最前面，这样在页面解析的时候不会乱码。</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Chead%3E%5Cn%20%20%20%20%3Cmeta%20charset%3D%5C%22UTF-8%5C%22%3E%5Cn%3C%2Fhead%3E%22%2C%22id%22%3A%22nfjQA%22%7D\"></card><p><br /></p><h4 id=\"7c550811\">http-equiv属性</h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">这个枚举属性定义了能改变服务器和用户引擎行为的编译</span></p></blockquote><p><br /></p><p>他的值有很多 <strong><code>content-language（过时,已经使用lang属性代替）、content-type（）、content-security-policy（内容安全策略）</code></strong> </p><p><br /></p><h5 id=\"content-security-policy\">content-security-policy</h5><blockquote><p>用于指定的服务端源以及脚本端点，有助于防止脚本攻击</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cmeta%20http-equiv%3D%5C%22content-security-policy%5C%22%20content%3D%5C%22default-src%20https%3A%E5%9C%B0%E5%9D%80%5C%22%3E%22%2C%22id%22%3A%22VFbCC%22%7D\"></card><p>具体的值很多，详情可以参照 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid\" target=\"_blank\">MDN的Content-Security-Policy</a></p><p><br /></p><h5 id=\"content-type\">content-type</h5><blockquote><p>用于指定文档的 <strong><code>MIME TYPE</code></strong> </p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%2F*%E8%BF%99%E4%B8%AA%E6%8C%87%E5%AE%9Ahttp%E5%8D%8F%E8%AE%AE%E4%B8%8B%EF%BC%8C%E6%96%87%E4%BB%B6%E7%9A%84%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F%2F%5Cn%3Cmeta%20http-equiv%3D%5C%22content-type%5C%22%20content%3D%5C%22text%2Fhtml%3B%20charset%3DUTF-8%5C%22%3E%20%22%2C%22id%22%3A%22pbmjR%22%7D\"></card><p><br /></p><ul><li>因为是写在 <strong><code>HTML</code></strong> 文件内，所以一般是只有设置为 <strong><code>text/html</code></strong> 才有效果。设置其他的起不了作用</li><li>这类 <strong><code>meta</code></strong> 属性标签，已经过时，被 <strong><code>charset</code></strong> 和 <strong><code>lang</code></strong> 给代替了</li></ul><p><br /></p><h5 id=\"default-style\"><strong>default-style</strong></h5><ul><li>这个属性可以定义，页面加载的首选样式</li></ul><h5 id=\"5ebf7738\"><strong>refresh（刷新）</strong></h5><p style=\"text-indent: 2em;\">这个属性指定:</p><ul data-lake-indent=\"1\"><li>如果  <strong><code><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content\" target=\"_blank\">content</a></code></strong> 只包含一个正整数,则是重新载入页面的时间间隔(秒);</li><li>如果  <strong><code><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/meta#attr-content\" target=\"_blank\">content</a></code></strong><strong> </strong>包含一个正整数并且跟着一个字符串,则是重定向到指定链接的时间间隔(秒)</li></ul><h5 id=\"4fd242dc\"><strong>set-cookie(已经被废弃，由JavaScript脚本控制)</strong></h5><h5 id=\"9eb346ba\"><span class=\"lake-fontsize-10\" style=\"color: #222222;\">x-ua-compatible：模拟 http 头 x-ua-compatible，声明 ua 兼容</span></h5><h4 id=\"3b3099f3\">viewport属性</h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">它提供有关视口初始大小的提示，仅供移动设备使用。</span></p></blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\"><br /></span></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cmeta%20name%3D%5C%22viewport%5C%22%20content%3D%5C%22width%3Ddevice-width%2C%20initial-scale%3D1.0%5C%22%3E%22%2C%22id%22%3A%22T6igd%22%7D\"></card><p>它的值有：</p><ul><li><strong><code>width</code></strong> ：页面宽度，可以取值具体的数字，也可以是 <strong><code>device-width</code></strong> ，表示跟设备宽度相等。</li><li><strong><code>height</code></strong> ：页面高度，可以取值具体的数字，也可以是 <strong><code>device-height</code></strong> ，表示跟设备高度相等。</li><li><strong><code>initial-scale</code></strong> ：初始缩放比例。</li><li><strong><code>minimum-scale</code></strong> ：最小缩放比例。</li><li><strong><code>maximum-scale</code></strong> ：最大缩放比例。</li><li><strong><code>user-scalable</code></strong> ：是否允许用户缩放。</li></ul><p><span style=\"color: #F5222D;\"><strong><span class=\"lake-fontsize-12\">这个属性不是HTML标准里的，是行业规范的</span></strong></span></p><p><br /></p><h4 id=\"4c07161c\">其他的属性</h4><ul><li><strong><code>author</code></strong> : 页面作者。</li><li><strong><code>description</code></strong> ：页面描述，这个属性可能被用于搜索引擎或者其它场合。</li><li><strong><code>generator</code></strong> : 生成页面所使用的工具，主要用于可视化编辑器，如果是手写 HTML 的网页，不需要加这个 meta。</li><li><strong><code>keywords</code></strong> : 页面关键字，对于 SEO 场景非常关键。</li><li><strong><code>referrer</code></strong> : 跳转策略，是一种安全考量。</li><li><strong><code>theme-color</code></strong> : 页面风格颜色，实际并不会影响页面，但是浏览器可能据此调整页面之外的 UI（如窗口边框或者 tab 的颜色）。</li></ul><h3 id=\"ad6873b9\">常见的meta设置</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cmeta%20http-equiv%3D%5C%22X-UA-Compatible%5C%22%20content%3D%5C%22IE%3Dedge%2Cchrome%3D1%5C%22%3E%5Cn%3C!--%20%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8%E6%9C%80%E6%96%B0%E6%B5%8F%E8%A7%88%E5%99%A8%20--%3E%5Cn%3Cmeta%20http-equiv%3D%5C%22Cache-Control%5C%22%20content%3D%5C%22no-siteapp%5C%22%3E%5Cn%3C!--%20%E4%B8%8D%E8%A2%AB%E7%BD%91%E9%A1%B5(%E5%8A%A0%E9%80%9F)%E8%BD%AC%E7%A0%81%20--%3E%5Cn%3Cmeta%20name%3D%5C%22robots%5C%22%20content%3D%5C%22index%2Cfollow%5C%22%3E%5Cn%3C!--%20%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%93%E5%8F%96%20--%3E%5Cn%3Cmeta%20name%3D%5C%22renderer%5C%22%20content%3D%5C%22webkit%5C%22%3E%5Cn%3Cmeta%20name%3D%5C%22viewport%5C%22%20content%3D%5C%22width%3Ddevice-width%2C%20initial-scale%3D1%2C%20maximum-scale%3D1%2C%20minimum-scale%3D1%2C%20user-scalable%3Dno%2C%20minimal-ui%5C%22%3E%5Cn%3Cmeta%20name%3D%5C%22apple-mobile-web-app-capable%5C%22%20content%3D%5C%22yes%5C%22%3E%5Cn%3C!--%20%E5%88%A0%E9%99%A4%E8%8B%B9%E6%9E%9C%E9%BB%98%E8%AE%A4%E7%9A%84%E5%B7%A5%E5%85%B7%E6%A0%8F%E5%92%8C%E8%8F%9C%E5%8D%95%E6%A0%8F%20--%3E%5Cn%3Cmeta%20name%3D%5C%22apple-mobile-web-app-status-bar-style%5C%22%20content%3D%5C%22black-translucent%5C%22%3E%5Cn%3C!--%20%E8%AE%BE%E7%BD%AE%E8%8B%B9%E6%9E%9C%E5%B7%A5%E5%85%B7%E6%A0%8F%E9%A2%9C%E8%89%B2%20--%3E%22%2C%22id%22%3A%228NMaF%22%7D\"></card><p><br /></p><p>关闭 <strong>iOS </strong>内容识别</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cmeta%20name%3D%5C%22format-detection%5C%22%20content%3D%5C%22telephone%3Dno%5C%22%3E%5Cn%3Cmeta%20name%3D%5C%22format-detection%5C%22%20content%3D%5C%22date%3Dno%5C%22%3E%5Cn%3Cmeta%20name%3D%5C%22format-detection%5C%22%20content%3D%5C%22address%3Dno%5C%22%3E%5Cn%3Cmeta%20name%3D%5C%22format-detection%5C%22%20content%3D%5C%22email%3Dno%5C%22%3E%22%2C%22id%22%3A%22Pexiu%22%7D\"></card><p><br /></p><h3 id=\"a9b648bd\">其他的标签</h3><ol start=\"1\"><li><span style=\"color: #505050;\"> </span><code><span style=\"color: #505050;\">Open Graph</span></code> <span style=\"color: #505050;\"> 的标签组，包括 </span><code><span style=\"color: #505050;\">title, type, URL, site_name, description</span></code> <span style=\"color: #505050;\"> 和 </span><code><span style=\"color: #505050;\">image</span></code> <span style=\"color: #505050;\">，是为 </span><code><span style=\"color: #505050;\">Facebook</span></code> <span style=\"color: #505050;\"> 分享提供信息；</span></li><li><span style=\"color: #505050;\"> </span><code><span style=\"color: #505050;\">Twitter</span></code> <span style=\"color: #505050;\"> 的标签组，包括 </span><code><span style=\"color: #505050;\">card, title, description</span></code> <span style=\"color: #505050;\"> 和 </span><code><span style=\"color: #505050;\">image</span></code> <span style=\"color: #505050;\">，是为 </span><code><span style=\"color: #505050;\">Twitter</span></code> <span style=\"color: #505050;\"> 分享提供信息；</span></li><li><span style=\"color: #505050;\"> </span><code><span style=\"color: #505050;\">msapplication</span></code> <span style=\"color: #505050;\"> 的标签组，包括 </span><code><span style=\"color: #505050;\">TileColor 和 TileImage</span></code> <span style=\"color: #505050;\">，是为 </span><code><span style=\"color: #505050;\">Windows 8</span></code> <span style=\"color: #505050;\"> 以及以上系统识别 </span><code><span style=\"color: #505050;\">favicons</span></code> <span style=\"color: #505050;\"> 用的。</span></li></ol>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:59:52.000Z",
    "deleted_at": null,
    "created_at": "2019-04-12T01:53:56.000Z",
    "updated_at": "2019-04-28T01:59:52.000Z",
    "published_at": "2019-04-28T01:59:52.000Z",
    "first_published_at": "2019-04-12T07:19:47.000Z",
    "word_count": 1357,
    "cover": null,
    "description": "tags: [head里可以放那些标签]categories: 重学前端系列笔记title标签title 标签表示的是网页的标题。title 在浏览器收藏夹、微信推送卡片、微博还有各种分享的时候， title 标签内的内容需要对当前页面的内容做个总的概况。base标签base  指定用于一个文...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1486157,
    "slug": "ql82hg",
    "title": "7. 浏览器是如何解析代码构建DOM树",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T01:56:39.365Z",
      "updated_at": "2019-04-28T01:56:39.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [解析构建Dom树过程]<br />\ncategories: 重学前端系列笔记\n\n---\n浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？\n\n![dom.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554713541318-2b1f1852-9f7c-4d9e-a65e-104554a4d764.png#align=left&display=inline&height=279&name=dom.png&originHeight=279&originWidth=732&size=7377&status=done&width=732)\n<a name=\"d9457fa5\"></a>\n### 解析代码\n<a name=\"ebf465eb\"></a>\n#### 词（token）拆分\n\n```html\n<p class=\"a\">text text text</p>\n```\n\n如果把整个标签当做一个词来解析。那么就会很大，因为内部可以进行嵌套，所以：\n\n- **<p :**“标签开始”的开始；\n- **class=\"a\" :** 属性；\n- **>**  ：“标签开始”的结束；\n- **text text text   :** 文本；\n- **</p>** ：标签结束。\n\n![f98444aa3ea7471d2414dd7d0f5e3a84.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554716167971-678c95cc-a83c-4e81-acf9-cca7834bfa46.png#align=left&display=inline&height=232&name=f98444aa3ea7471d2414dd7d0f5e3a84.png&originHeight=252&originWidth=624&size=25083&status=done&width=574)\n\n> 当我们通过http协议，获得一串字符流时，从接受的第一个字符开始解析，当遇到 **`<`** 的时候。判断出这是标签文本，然后再读一个 **`xx`** ，就可以判断这不是个注释节点，然后再读取 **`xx =\"xxx\"`** ，就可以将其解析为该标签的属性。当碰到 **`/>`** 就可以判断出，这个标签解析结束。可以将其展现。\n\n\n<a name=\"3a5d8e29\"></a>\n#### 状态机\n上面解析每解析一个字符，都要做一次决策。而每一次决策就要涉及到**状态机**，这就引来了另一个问题，状态机是什么？\n<a name=\"81b512f5\"></a>\n##### 状态机是什么？\n其实，绝大多数的语言的词法部分是使用**状态机**实现的，下面是一个**词**解析过程，画成**状态机<br />![8b43d598bc1f83a8a1e7e8f922013ab0.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554779834110-f769f2e5-d1f1-4dcd-b806-7e45ac6aee42.png#align=left&display=inline&height=718&name=8b43d598bc1f83a8a1e7e8f922013ab0.png&originHeight=739&originWidth=768&size=48178&status=done&width=746)**<br />**完整的状态机可以参照 **[**HTML官方词法状态机解析**](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)\n\n状态机解析过程：<br />**初始部分：**\n\n- 只区分 **`<`**`非>`**`<`**`非<`**  就进入文本状态\n\n**进入标签状态之后：**\n\n- 如果下一个字符是 \"！\"，那么就进入到了注释节点状态或者 CDATA节点\n- 如果下一个字符是 \"/ \"，那么就进入标签结束状态\n- 如果下一个字符是一个字母。那么进入标签解析开始的状态\n- 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。\n\n其实用状态机做词法解析，只是将各种特征字符拆分成单独状态，然后通过判断单独的状态，最终连成图结构输出。我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。\n\n```javascript\nvar data = function(c){\n    if(c===\"&\") {\n        return characterReferenceInData;\n    }\n    if(c===\"<\") {\n        return tagOpen;\n    }\n    else if(c===\"\\0\") {\n        error();\n        emitToken(c);\n        return data;\n    }\n    else if(c===EOF) {\n        emitToken(EOF);\n        return data;\n    }\n    else {\n        emitToken(c);\n        return data;\n    }\n};\nvar tagOpenState = function tagOpenState(c){\n    if(c===\"/\") {\n        return endTagOpenState;\n    }\n    if(c.match(/[A-Z]/)) {\n        token = new StartTagToken();\n        token.name = c.toLowerCase();\n        return tagNameState;\n    }\n    if(c.match(/[a-z]/)) {\n        token = new StartTagToken();\n        token.name = c;\n        return tagNameState;\n    }\n    if(c===\"?\") {\n        return bogusCommentState;\n    }\n    else {\n        error();\n        return dataState;\n    }\n};\n//……\n```\n\n这里通过 **`if....else`** 来区分解析的字符来进行状态迁移。状态迁移其实就是当前状态的函数通过判断返回下一个字符的状态函数。\n\n```javascript\nvar state = data;\nvar char\nwhile(char = getInput())\n    state = state(char);\n```\n> 这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。\n> \n\n```javascript\nfunction HTMLLexicalParser(){\n    // 状态函数们……\n    function data() {\n        // ……\n    }\n    function tagOpen() {\n        // ……\n    }\n    // ……\n    var state = data;\n    this.receiveInput = function(char) {\n        state = state(char);\n    }\n}\n```\n\n<a name=\"ee86bc99\"></a>\n### 构建 `DOM` 树\n通过上面的词拆分进行解析。简单的词到后来的 **`DOM`** 树。整个过程是通过栈实现的。任何语言都有栈这个东西。\n\n- 栈顶元素就是当前节点；\n- 遇到属性，就添加到当前节点；\n- 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；\n- 遇到注释节点，作为当前节点的子节点；\n- 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；\n- 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。\n\n```html\n<html maaa=a >\n    <head>\n        <title>cool</title>\n    </head>\n    <body>\n        <img src=\"a\" />\n    </body>\n</html>\n```\n\n![GIF.gif](https://cdn.nlark.com/yuque/0/2019/gif/221851/1554867046508-68bb4743-b838-408e-96f9-da392ee7c321.gif#align=left&display=inline&height=227&name=GIF.gif&originHeight=563&originWidth=1852&size=2376616&status=done&width=746)\n\n[GitHub上的HTML解析器](https://github.com/aimergenge/toy-html-parser)\n",
    "body_draft": "",
    "body_html": "<p>tags: [解析构建Dom树过程]<br />\ncategories: 重学前端系列笔记</p><hr /><p><span style=\"background-color: transparent;\">浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？</span><br /></p><p><br /><img alt=\"dom.png\" title=\"dom.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554713541318-2b1f1852-9f7c-4d9e-a65e-104554a4d764.png#align=left&amp;display=inline&amp;height=279&amp;name=dom.png&amp;originHeight=279&amp;originWidth=732&amp;size=7377&amp;status=done&amp;width=732\" style=\"max-width: 600px; width: 732px;\" /></p><h3 id=\"d9457fa5\">解析代码</h3><h4 id=\"ebf465eb\">词（token）拆分</h4><p><br /></p><pre data-lang=\"html\"><code>&lt;p class=&quot;a&quot;&gt;text text text&lt;/p&gt;</code></pre><p><br /></p><p>如果把整个标签当做一个词来解析。那么就会很大，因为内部可以进行嵌套，所以：</p><p><br /></p><ul><li><strong>&lt;p :</strong>“标签开始”的开始；</li><li><strong>class=&quot;a&quot; :</strong> 属性；</li><li><strong>&gt;</strong>  ：“标签开始”的结束；</li><li><strong>text text text   :</strong> 文本；</li><li><strong>&lt;/p&gt;</strong> ：标签结束。</li></ul><p><img alt=\"f98444aa3ea7471d2414dd7d0f5e3a84.png\" title=\"f98444aa3ea7471d2414dd7d0f5e3a84.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554716167971-678c95cc-a83c-4e81-acf9-cca7834bfa46.png#align=left&amp;display=inline&amp;height=232&amp;name=f98444aa3ea7471d2414dd7d0f5e3a84.png&amp;originHeight=252&amp;originWidth=624&amp;size=25083&amp;status=done&amp;width=574\" style=\"max-width: 600px; width: 574px;\" /></p><p><br /></p><blockquote><p><span class=\"lake-fontsize-12\">当我们通过http协议，获得一串字符流时，从接受的第一个字符开始解析，当遇到 </span><span class=\"lake-fontsize-12\"><strong><code>&lt;</code></strong></span><span class=\"lake-fontsize-12\"> 的时候。判断出这是标签文本，然后再读一个 </span><span class=\"lake-fontsize-12\"><strong><code>xx</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以判断这不是个注释节点，然后再读取 </span><span class=\"lake-fontsize-12\"><strong><code>xx =&quot;xxx&quot;</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以将其解析为该标签的属性。当碰到 </span><span class=\"lake-fontsize-12\"><strong><code>/&gt;</code></strong></span><span class=\"lake-fontsize-12\"> 就可以判断出，这个标签解析结束。可以将其展现。</span></p></blockquote><p><br /></p><h4 id=\"3a5d8e29\">状态机</h4><p>上面解析每解析一个字符，都要做一次决策。而每一次决策就要涉及到<strong>状态机</strong>，这就引来了另一个问题，状态机是什么？</p><h5 id=\"81b512f5\">状态机是什么？</h5><p>其实，绝大多数的语言的词法部分是使用<strong>状态机</strong>实现的，下面是一个<strong>词</strong>解析过程，画成<strong>状态机<br /><img alt=\"8b43d598bc1f83a8a1e7e8f922013ab0.png\" title=\"8b43d598bc1f83a8a1e7e8f922013ab0.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554779834110-f769f2e5-d1f1-4dcd-b806-7e45ac6aee42.png#align=left&amp;display=inline&amp;height=718&amp;name=8b43d598bc1f83a8a1e7e8f922013ab0.png&amp;originHeight=739&amp;originWidth=768&amp;size=48178&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></strong></p><p><strong>完整的状态机可以参照 </strong><a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\"><strong>HTML官方词法状态机解析</strong></a></p><p><br /></p><p>状态机解析过程：</p><p><span class=\"lake-fontsize-12\"><strong>初始部分：</strong></span></p><ul><li>只区分 <strong><code>&lt;</code></strong> 和 <strong><code>非&gt;</code></strong>  ，如果是 <strong><code>&lt;</code></strong> 可以进入标签状态，如果是 <strong><code>非&lt;</code></strong>  就进入文本状态</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\"><strong>进入标签状态之后：</strong></span></p><ul><li>如果下一个字符是 &quot;！&quot;，那么就进入到了注释节点状态或者 CDATA节点</li><li>如果<span>下一个字符是 &quot;/ &quot;，那么就进入标签结束状态</span></li><li>如果下一个字符是一个字母。那么进入标签解析开始的状态</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。</span></li></ul><p><br /></p><p><span class=\"lake-fontsize-14\">其实用状态机做词法解析，只是将各种特征字符拆分成单独状态，然后通过判断单独的状态，最终连成图结构输出。</span><span class=\"lake-fontsize-14\">我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。</span></p><p><br /></p><pre data-lang=\"javascript\"><code>var data = function(c){\n    if(c===&quot;&amp;&quot;) {\n        return characterReferenceInData;\n    }\n    if(c===&quot;&lt;&quot;) {\n        return tagOpen;\n    }\n    else if(c===&quot;\\0&quot;) {\n        error();\n        emitToken(c);\n        return data;\n    }\n    else if(c===EOF) {\n        emitToken(EOF);\n        return data;\n    }\n    else {\n        emitToken(c);\n        return data;\n    }\n};\nvar tagOpenState = function tagOpenState(c){\n    if(c===&quot;/&quot;) {\n        return endTagOpenState;\n    }\n    if(c.match(/[A-Z]/)) {\n        token = new StartTagToken();\n        token.name = c.toLowerCase();\n        return tagNameState;\n    }\n    if(c.match(/[a-z]/)) {\n        token = new StartTagToken();\n        token.name = c;\n        return tagNameState;\n    }\n    if(c===&quot;?&quot;) {\n        return bogusCommentState;\n    }\n    else {\n        error();\n        return dataState;\n    }\n};\n//……</code></pre><p><br /></p><p>这里通过 <strong><code>if....else</code></strong> 来区分解析的字符来进行状态迁移。状态迁移其实就是当前状态的函数通过判断返回下一个字符的状态函数。</p><p><br /></p><pre data-lang=\"javascript\"><code>var state = data;\nvar char\nwhile(char = getInput())\n    state = state(char);</code></pre><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。</span></p><p><br /></p></blockquote><pre data-lang=\"javascript\"><code>function HTMLLexicalParser(){\n    // 状态函数们……\n    function data() {\n        // ……\n    }\n    function tagOpen() {\n        // ……\n    }\n    // ……\n    var state = data;\n    this.receiveInput = function(char) {\n        state = state(char);\n    }\n}</code></pre><p><br /></p><h3 id=\"ee86bc99\">构建 <code>DOM</code> 树</h3><p>通过上面的词拆分进行解析。简单的词到后来的 <strong><code>DOM</code></strong> 树。整个过程是通过栈实现的。任何语言都有栈这个东西。</p><ul><li>栈顶元素就是当前节点；</li><li>遇到属性，就添加到当前节点；</li><li>遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；</li><li>遇到注释节点，作为当前节点的子节点；</li><li>遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；</li><li>遇到 tag end 就出栈一个节点（还可以检查是否匹配）。</li><p><br /></p></ul><pre data-lang=\"html\"><code>&lt;html maaa=a &gt;\n    &lt;head&gt;\n        &lt;title&gt;cool&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;img src=&quot;a&quot; /&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre><p><br /></p><p><img alt=\"GIF.gif\" title=\"GIF.gif\" src=\"https://cdn.nlark.com/yuque/0/2019/gif/221851/1554867046508-68bb4743-b838-408e-96f9-da392ee7c321.gif#align=left&amp;display=inline&amp;height=227&amp;name=GIF.gif&amp;originHeight=563&amp;originWidth=1852&amp;size=2376616&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p><a href=\"https://github.com/aimergenge/toy-html-parser\" target=\"_blank\">GitHub上的HTML解析器</a></p>",
    "body_lake": "<!doctype lake><p>tags: [解析构建Dom树过程]<br />\ncategories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22R2RQD%22%7D\"></card><p><span style=\"background-color: transparent;\">浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？</span><br /></p><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554713541318-2b1f1852-9f7c-4d9e-a65e-104554a4d764.png%22%2C%22originWidth%22%3A732%2C%22originHeight%22%3A279%2C%22name%22%3A%22dom.png%22%2C%22size%22%3A7377%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A732%2C%22height%22%3A279%7D\"></card><cursor /></p><h3 id=\"d9457fa5\">解析代码</h3><h4 id=\"ebf465eb\">词（token）拆分</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cp%20class%3D%5C%22a%5C%22%3Etext%20text%20text%3C%2Fp%3E%22%2C%22id%22%3A%221KfpU%22%7D\"></card><p><br /></p><p>如果把整个标签当做一个词来解析。那么就会很大，因为内部可以进行嵌套，所以：</p><p><br /></p><ul><li><strong>&lt;p :</strong>“标签开始”的开始；</li><li><strong>class=&quot;a&quot; :</strong> 属性；</li><li><strong>&gt;</strong>  ：“标签开始”的结束；</li><li><strong>text text text   :</strong> 文本；</li><li><strong>&lt;/p&gt;</strong> ：标签结束。</li></ul><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554716167971-678c95cc-a83c-4e81-acf9-cca7834bfa46.png%22%2C%22originWidth%22%3A624%2C%22originHeight%22%3A252%2C%22name%22%3A%22f98444aa3ea7471d2414dd7d0f5e3a84.png%22%2C%22size%22%3A25083%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A574%2C%22height%22%3A232%7D\"></card></p><p><br /></p><blockquote><p><span class=\"lake-fontsize-12\">当我们通过http协议，获得一串字符流时，从接受的第一个字符开始解析，当遇到 </span><span class=\"lake-fontsize-12\"><strong><code>&lt;</code></strong></span><span class=\"lake-fontsize-12\"> 的时候。判断出这是标签文本，然后再读一个 </span><span class=\"lake-fontsize-12\"><strong><code>xx</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以判断这不是个注释节点，然后再读取 </span><span class=\"lake-fontsize-12\"><strong><code>xx =&quot;xxx&quot;</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以将其解析为该标签的属性。当碰到 </span><span class=\"lake-fontsize-12\"><strong><code>/&gt;</code></strong></span><span class=\"lake-fontsize-12\"> 就可以判断出，这个标签解析结束。可以将其展现。</span></p></blockquote><p><br /></p><h4 id=\"3a5d8e29\">状态机</h4><p>上面解析每解析一个字符，都要做一次决策。而每一次决策就要涉及到<strong>状态机</strong>，这就引来了另一个问题，状态机是什么？</p><h5 id=\"81b512f5\">状态机是什么？</h5><p>其实，绝大多数的语言的词法部分是使用<strong>状态机</strong>实现的，下面是一个<strong>词</strong>解析过程，画成<strong>状态机<br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554779834110-f769f2e5-d1f1-4dcd-b806-7e45ac6aee42.png%22%2C%22originWidth%22%3A768%2C%22originHeight%22%3A739%2C%22name%22%3A%228b43d598bc1f83a8a1e7e8f922013ab0.png%22%2C%22size%22%3A48178%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A718%7D\"></card></strong></p><p><strong>完整的状态机可以参照 </strong><a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\"><strong>HTML官方词法状态机解析</strong></a></p><p><br /></p><p>状态机解析过程：</p><p><span class=\"lake-fontsize-12\"><strong>初始部分：</strong></span></p><ul><li>只区分 <strong><code>&lt;</code></strong> 和 <strong><code>非&gt;</code></strong>  ，如果是 <strong><code>&lt;</code></strong> 可以进入标签状态，如果是 <strong><code>非&lt;</code></strong>  就进入文本状态</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\"><strong>进入标签状态之后：</strong></span></p><ul><li>如果下一个字符是 &quot;！&quot;，那么就进入到了注释节点状态或者 CDATA节点</li><li>如果<span>下一个字符是 &quot;/ &quot;，那么就进入标签结束状态</span></li><li>如果下一个字符是一个字母。那么进入标签解析开始的状态</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。</span></li></ul><p><br /></p><p><span class=\"lake-fontsize-14\">其实用状态机做词法解析，只是将各种特征字符拆分成单独状态，然后通过判断单独的状态，最终连成图结构输出。</span><span class=\"lake-fontsize-14\">我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20data%20%3D%20function(c)%7B%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%26%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20characterReferenceInData%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%3C%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20tagOpen%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20if(c%3D%3D%3D%5C%22%5C%5C0%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20error()%3B%5Cn%20%20%20%20%20%20%20%20emitToken(c)%3B%5Cn%20%20%20%20%20%20%20%20return%20data%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20if(c%3D%3D%3DEOF)%20%7B%5Cn%20%20%20%20%20%20%20%20emitToken(EOF)%3B%5Cn%20%20%20%20%20%20%20%20return%20data%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20emitToken(c)%3B%5Cn%20%20%20%20%20%20%20%20return%20data%3B%5Cn%20%20%20%20%7D%5Cn%7D%3B%5Cnvar%20tagOpenState%20%3D%20function%20tagOpenState(c)%7B%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%2F%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20endTagOpenState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c.match(%2F%5BA-Z%5D%2F))%20%7B%5Cn%20%20%20%20%20%20%20%20token%20%3D%20new%20StartTagToken()%3B%5Cn%20%20%20%20%20%20%20%20token.name%20%3D%20c.toLowerCase()%3B%5Cn%20%20%20%20%20%20%20%20return%20tagNameState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c.match(%2F%5Ba-z%5D%2F))%20%7B%5Cn%20%20%20%20%20%20%20%20token%20%3D%20new%20StartTagToken()%3B%5Cn%20%20%20%20%20%20%20%20token.name%20%3D%20c%3B%5Cn%20%20%20%20%20%20%20%20return%20tagNameState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%3F%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20bogusCommentState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20error()%3B%5Cn%20%20%20%20%20%20%20%20return%20dataState%3B%5Cn%20%20%20%20%7D%5Cn%7D%3B%5Cn%2F%2F%E2%80%A6%E2%80%A6%22%2C%22id%22%3A%22pnqM1%22%7D\"></card><p><br /></p><p>这里通过 <strong><code>if....else</code></strong> 来区分解析的字符来进行状态迁移。状态迁移其实就是当前状态的函数通过判断返回下一个字符的状态函数。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20state%20%3D%20data%3B%5Cnvar%20char%5Cnwhile(char%20%3D%20getInput())%5Cn%20%20%20%20state%20%3D%20state(char)%3B%22%2C%22id%22%3A%22u38mi%22%7D\"></card><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。</span></p><p><br /></p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20HTMLLexicalParser()%7B%5Cn%20%20%20%20%2F%2F%20%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E4%BB%AC%E2%80%A6%E2%80%A6%5Cn%20%20%20%20function%20data()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20%7D%5Cn%20%20%20%20function%20tagOpen()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20var%20state%20%3D%20data%3B%5Cn%20%20%20%20this.receiveInput%20%3D%20function(char)%20%7B%5Cn%20%20%20%20%20%20%20%20state%20%3D%20state(char)%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22id%22%3A%229efNH%22%7D\"></card><p><br /></p><h3 id=\"ee86bc99\">构建 <code>DOM</code> 树</h3><p>通过上面的词拆分进行解析。简单的词到后来的 <strong><code>DOM</code></strong> 树。整个过程是通过栈实现的。任何语言都有栈这个东西。</p><ul><li>栈顶元素就是当前节点；</li><li>遇到属性，就添加到当前节点；</li><li>遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；</li><li>遇到注释节点，作为当前节点的子节点；</li><li>遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；</li><li>遇到 tag end 就出栈一个节点（还可以检查是否匹配）。</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Chtml%20maaa%3Da%20%3E%5Cn%20%20%20%20%3Chead%3E%5Cn%20%20%20%20%20%20%20%20%3Ctitle%3Ecool%3C%2Ftitle%3E%5Cn%20%20%20%20%3C%2Fhead%3E%5Cn%20%20%20%20%3Cbody%3E%5Cn%20%20%20%20%20%20%20%20%3Cimg%20src%3D%5C%22a%5C%22%20%2F%3E%5Cn%20%20%20%20%3C%2Fbody%3E%5Cn%3C%2Fhtml%3E%22%2C%22id%22%3A%22RFMZf%22%7D\"></card><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fgif%2F221851%2F1554867046508-68bb4743-b838-408e-96f9-da392ee7c321.gif%22%2C%22originWidth%22%3A1852%2C%22originHeight%22%3A563%2C%22name%22%3A%22GIF.gif%22%2C%22size%22%3A2376616%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A227%7D\"></card></p><p><br /></p><p><a href=\"https://github.com/aimergenge/toy-html-parser\" target=\"_blank\">GitHub上的HTML解析器</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:53:05.000Z",
    "deleted_at": null,
    "created_at": "2019-04-08T08:48:39.000Z",
    "updated_at": "2019-04-28T01:53:05.000Z",
    "published_at": "2019-04-28T01:53:05.000Z",
    "first_published_at": "2019-04-08T08:49:47.000Z",
    "word_count": 1070,
    "cover": null,
    "description": "tags: [解析构建Dom树过程] categories: 重学前端系列笔记浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？解析代码词（token）拆分&lt;p class=&quot;a&quot;&gt;text text text&lt;/p&gt;...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1486155,
    "slug": "lssef8",
    "title": "8.文档排版布局",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [ 文档排版布局 ]<br />categories: 重学前端系列笔记\n\n---\n<a name=\"ZImkg\"></a>\n### 浏览器默认排版 - 正常流\n> 浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样\n\n\n\n浏览器默认的文字排版规则：规定了**行模型及文字在行模型中的排版。**行模型中规定了，文字的**行顶、行底、中心（文字区域）、基线**几种对齐方式。一般**默认是基线对齐。**\n\n浏览器不仅支持文字排版，还支持文字与其他元素排版。元素被定义为拥有一定区域的盒子。这个盒子由：**元素内容、内边距、边框、外边距**组成。\n\n浏览器排版，还包括：**flex布局（**这里主要是通过display的属性控制排版方式**） 、定位布局（**这里包括**绝对定位、相对定位，固定定位）、浮动布局** 、还有老式的**table布局。**\n\n<a name=\"335b97c0\"></a>\n#### 盒模型\n> 讲到布局，就不能不讲一下盒模型，\n\n一般元素都具有盒模型特征，主要由\n\n- content （内容）\n- padding（内边距）\n- border（边框）\n- margin（外边距）\n\n元素还分为三类：\n\n- **行内元素（inline）**无法赋值宽高**，元素的宽高由内容撑开，**上内边距**无法生效**上下的外边距**无法生效**\n- **行内块元素（inline-block）**：这类元素可以的赋值宽高，也可以设置内外边距\n- **块级元素（block）**：这类元素独占一行，不管元素是否有一行的宽，宽高内外边距都可以赋值。\n\n<a name=\"2e169b41\"></a>\n### flex布局\n```css\ndisplay:flex;\njustify-content: center;\nalign-items: center;\n```\n<br />详细的可以看我之前的文章  [flex布局总结](https://wuxin.netlify.com/passages/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bflex%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/)\n\n另外说一点就是。 **`display`** 这个属性的不同的值可以改变元素的布局方式\n\n<a name=\"4eb6b409\"></a>\n### 定位布局\n<a name=\"d0285350\"></a>\n#### 相对定位\n**`position`** 为 **`absolute`** 属性的元素，这类元素根据父级元素定位，一层层向上查找，如果没找到。最终会找到   **`body`** ，这类布局不参与正常流排版，他自有自己的一套排版规则。按照这种定位布局之后，将在文档中不占位置\n<a name=\"ff40a9ca\"></a>\n#### 绝对定位\n**`position`** 为  **`relative`**  属性的元素，这类元素是根据自己定位，定位移动的话，是根据自己自身移动，自身本身占据的位置不管是随着如何移动，依然在文档中占据位置\n<a name=\"7d121dca\"></a>\n#### 固定定位\n**`position`** 为 **`fixed`** 属性的元素，这类元素是根据浏览器可视定位。最大宽高是浏览器视口的宽高。超出部分会被裁剪隐藏。定位移动是根据浏览器定位移动，在正常文档流中不占据位置。\n\n<a name=\"ad793c09\"></a>\n### 浮动布局\n当元素使用 **`float: right`** 或者 **`float:left`** 的时候，就可以开启浮动布局。不过相对于其他的布局来说， **`float`** 的布局，浏览器会先将其排入正常流，然后再其排到其父元素最左/最右。移动之后的浮动元素，在没清除浮动之前，其父级元素是不占据位置。同级的浮动元素处于同一空间内，在浮动空间内的布局的规则，很像正常元素在正常流上的布局。\n\n<a name=\"a8fb79d2\"></a>\n### table布局（表格布局）\n> 顾名思，就是讲网页分割成一个个网格，然后对网格进行排版\n\n```html\n<style>\n  div{\n    /*这里记得给宽高\\(^o^)/~*/\n    display:table-cell;\n    text-align:center;\n    vertical-align: middle;\n  }\n</style>\n<body>\n  <div>\n    <em>爱是一种病，你病的不轻，还从来没有好过。</em>\n  </div>\n</body>\n```\n\n- 当父元素是要  **`display : table-row， 子元素使用  display : table-cell`**   的时候。子元素是等高的\n- 当父元素是要 **`display : table-row， 子元素使用  display : table-row`**  的时候。子元素是等宽的\n<a name=\"a5bed4e2\"></a>\n### Grid布局（网格布局）\n> 这种布局和 **`flex`**`grid`** 布局更倾向于二维布局。\n\n<a name=\"df368884\"></a>\n#### 前言\n\n- 在 **`Grid`**\"容器\"**\"项目\"**\n```html\n<article>\n    <div>\n        <p>一生一世一双人</p>\n    </div>\n    <div>\n        <p>一生一世一双人</p>\n    </div>\n    <div>\n        <p>一生一世一双人</p>\n    </div>\n</article>\n```\n> 上面的 **`article`** 就可以作为一个**容器，**作为他的子元素 **`div`**  便是 **项目 **，但是作为子元素的子元素 **`p`** 便不是项目，项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 **`p`** 元素就不是项目。 **`Grid`**  布局只对项目生效\n\n\n- **行（row）与列（column）：**正常的是横为行，竖为列\n- **单元格（cell） **： 行与列相交的地方，称之为单元格\n- **网格线 **： 划分单元格的线称之为网格线\n\n<a name=\"1527f2de\"></a>\n#### 属性介绍\n<a name=\"0e8a88a1\"></a>\n##### 开启grid布局\n```css\ndisplay:grid /*这种元素独占一行*/\ndisplay:inline-grid /*这种布局类似于inline-block*/\n```\n> 注意，设为网格布局以后，容器子元素（项目）的 **`float、display: inline-block、display: table-cell、vertical-align 和 column-*`**  等设置都将失效。\n\n<a name=\"fe36677d\"></a>\n##### 划分行与列布局\n```css\n/*下面定义是宽高都是200px的三行三列网格*/\ngrid-template-columns: 200px 200px 200px; /*这里的单位不仅可以使用固定单位，也可以使用百分比*/\ngrid-template-rows: 200px 200px 200px;\n```\n\n重复数值 `repeat()` <br />\n```css\ngrid-template-columns: reqeat(3,200px); \ngrid-template-rows: reqeat(3,200px);\n```\n**`repeat()`** 接受两个值，第一个值为重复的次数，第二个值是重复的数值。\n\n<a name=\"80ae2394\"></a>\n##### 重复的次数自动填充\n```css\ngrid-template-columns: reqeat(auto-fill,200px); \ngrid-template-rows: reqeat(3,200px);\n```\n\n> **`auto-fill`** 可以按照重复的数值，将子元素铺满父元素，超出便会换行\n\n\n<a name=\"07b55829\"></a>\n##### fr 关键词\n这关键词有点类似 **`flex`**  布局的 **`flex:1`** \n```css\ngrid-template-columns: 1fr 2fr; /* 2fr相当于1fr的两倍 */\n```\n\n<a name=\"e8bd0e48\"></a>\n##### 行间距、列间距\n```css\n grid-row-gap: 20px; /*行间距*/\ngrid-column-gap: 20px; /*列间距*/\n```\n\n<a name=\"969e849d\"></a>\n##### 排列先后问题 `grid-auto-flow` \n```css\ngrid-auto-flow: column;\ngrid-auto-flow:row /*默认*/\n```\n\n更详细的可以去看下阮一峰老师的[**grid教程**](http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)\n\n\n\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [ 文档排版布局 ]</p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"ZImkg\"><span style=\"background-color: transparent;\">浏览器默认排版 - 正常流</span></h3><blockquote><p><span class=\"lake-fontsize-14\">浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样</span></p></blockquote><p><span class=\"lake-fontsize-14\"><br /></span></p><p><span class=\"lake-fontsize-12\">浏览器默认的文字排版规则：规定了</span><span class=\"lake-fontsize-12\"><strong>行模型及文字在行模型中的排版。</strong>行模型中规定了，文字的</span><strong><span class=\"lake-fontsize-12\">行顶</span></strong><strong><span class=\"lake-fontsize-12\">、</span></strong><strong><span class=\"lake-fontsize-12\">行底、中心（文字区域）、基线</span></strong><span class=\"lake-fontsize-12\">几种对齐方式。一般</span><strong><span class=\"lake-fontsize-12\">默认是基线对齐。</span></strong></p><p><br /></p><p>浏览器不仅支持文字排版，还支持文字与其他元素排版。元素被定义为拥有一定区域的盒子。这个盒子由：<strong>元素内容、</strong><strong>内边距、边框、外边距</strong>组成。</p><p><br /></p><p><span class=\"lake-fontsize-12\">浏览器排版，还包括：</span><strong><span class=\"lake-fontsize-12\">flex布局（</span></strong><span class=\"lake-fontsize-12\">这里主要是通过display的属性控制排版方式</span><strong><span class=\"lake-fontsize-12\">） 、定位布局（</span></strong><span class=\"lake-fontsize-12\">这里包括</span><strong><span class=\"lake-fontsize-12\">绝对定位、相对定位，固定定位）、浮动布局</span></strong><span class=\"lake-fontsize-12\"> 、还有老式的</span><strong><span class=\"lake-fontsize-12\">table布局</span></strong><strong><span class=\"lake-fontsize-12\">。</span></strong></p><p><br /></p><h4 id=\"335b97c0\">盒模型</h4><blockquote><p>讲到布局，就不能不讲一下盒模型，</p></blockquote><p>一般元素都具有盒模型特征，主要由</p><ul><li>content （内容）</li><li>padding（内边距）</li><li>border（边框）</li><li>margin（外边距）</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\">元素还分为三类：</span></p><ul><li><strong>行内元素（inline）</strong>：这类元素<strong>无法赋值宽高</strong><span>，元素的宽高由内容撑开</span>，<strong>上内边距</strong>赋值之后<strong>无法生效</strong>。<strong>上下的外边距</strong>赋值之后是<strong>无法生效</strong></li><li><strong>行内块元素（inline-block）</strong>：这类元素可以的赋值宽高，也可以设置内外边距</li><li><strong>块级元素（block）</strong>：这类元素独占一行，不管元素是否有一行的宽，宽高内外边距都可以赋值。</li></ul><p><br /></p><h3 id=\"2e169b41\">flex布局</h3><pre data-lang=\"css\"><code>display:flex;\njustify-content: center;\nalign-items: center;</code></pre><p><span style=\"background-color: \"rgba(0, 0, 0, 0)\";\"><br />详细的可以看我之前的文章  </span><a href=\"https://wuxin.netlify.com/passages/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bflex%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/\" target=\"_blank\">flex布局总结</a><br /></p><p>另外说一点就是。 <strong><code>display</code></strong> 这个属性的不同的值可以改变元素的布局方式</p><p><br /></p><h3 id=\"4eb6b409\">定位布局</h3><h4 id=\"d0285350\">相对定位</h4><p style=\"text-indent: 2em;\"><strong><code>position</code></strong> 为 <strong><code>absolute</code></strong> 属性的元素，这类元素根据父级元素定位，一层层向上查找，如果没找到。最终会找到   <strong><code>body</code></strong> ，这类布局不参与正常流排版，他自有自己的一套排版规则。按照这种定位布局之后，将在文档中不占位置</p><h4 id=\"ff40a9ca\">绝对定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为  </span><span class=\"lake-fontsize-11\"><strong><code>relative</code></strong></span><span class=\"lake-fontsize-11\">  属性的元素，这类元素是根据自己定位，定位移动的话，是根据自己自身移动，自身本身占据的位置不管是随着如何移动，依然在文档中占据位置</span></p><h4 id=\"7d121dca\">固定定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为 </span><strong><code><span class=\"lake-fontsize-11\">fixed</span></code></strong> <span class=\"lake-fontsize-11\">属性的元素</span>，这类元素是根据浏览器可视定位。最大宽高是浏览器视口的宽高。超出部分会被裁剪隐藏。定位移动是根据浏览器定位移动，在正常文档流中不占据位置。</p><p><br /></p><h3 id=\"ad793c09\">浮动布局</h3><p>当元素使用 <strong><code>float: right</code></strong> 或者 <strong><code>float:left</code></strong> 的时候，就可以开启浮动布局。不过相对于其他的布局来说， <strong><code>float</code></strong> 的布局，浏览器会先将其排入正常流，然后再其排到其父元素最左/最右。移动之后的浮动元素，在没清除浮动之前，其父级元素是不占据位置。同级的浮动元素处于同一空间内，在浮动空间内的布局的规则，很像正常元素在正常流上的布局。</p><p><br /></p><h3 id=\"a8fb79d2\">table布局（表格布局）</h3><blockquote><p>顾名思，就是讲网页分割成一个个网格，然后对网格进行排版</p></blockquote><pre data-lang=\"html\"><code>&lt;style&gt;\n  div{\n    /*这里记得给宽高\\(^o^)/~*/\n    display:table-cell;\n    text-align:center;\n    vertical-align: middle;\n  }\n&lt;/style&gt;\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;em&gt;爱是一种病，你病的不轻，还从来没有好过。&lt;/em&gt;\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre><p><br /></p><ul><li>当父元素是要  <strong><code>display : table-row， 子元素使用  display : table-cell</code></strong>   的时候。子元素是等高的</li><li>当父元素是要 <strong><code>display : table-row， 子元素使用  display : table-row</code></strong>  的时候。子元素是等宽的</li></ul><h3 id=\"a5bed4e2\">Grid布局（网格布局）</h3><blockquote><p>这种布局和 <strong><code>flex</code></strong> 布局很像，但是 <strong><code>grid</code></strong> 布局更倾向于二维布局。</p></blockquote><h4 id=\"df368884\">前言</h4><ul><li>在 <strong><code>Grid</code></strong> 布局中，采用布局的区域称之为<strong>&quot;容器&quot;</strong>，容器内采用网格布局的子元素称之为 <strong>&quot;项目&quot;</strong></li></ul><pre data-lang=\"html\"><code>&lt;article&gt;\n    &lt;div&gt;\n        &lt;p&gt;一生一世一双人&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;p&gt;一生一世一双人&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;p&gt;一生一世一双人&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/article&gt;</code></pre><blockquote><p><span class=\"lake-fontsize-12\">上面的 </span><span class=\"lake-fontsize-12\"><strong><code>article</code></strong></span><span class=\"lake-fontsize-12\"> 就可以作为一个</span><span class=\"lake-fontsize-12\"><strong>容器，</strong></span><span class=\"lake-fontsize-12\">作为他的子元素 </span><strong><code><span class=\"lake-fontsize-12\">div</span></code></strong> <span class=\"lake-fontsize-12\"> 便是 </span><span class=\"lake-fontsize-12\"><strong>项目 </strong></span><span class=\"lake-fontsize-12\">，但是作为子元素的子元素 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">便不是项目，项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">元素就不是项目。 </span><strong><code><span class=\"lake-fontsize-12\">Grid</span></code></strong> <span class=\"lake-fontsize-12\"> 布局只对项目生效</span></p></blockquote><p><br /></p><ul><li><strong>行（row）与列（column）：</strong>正常的是横为行，竖为列</li><li><strong>单元格（cell） </strong>： 行与列相交的地方，称之为单元格</li><li><strong>网格线 </strong>： 划分单元格的线称之为网格线</li></ul><p><br /></p><h4 id=\"1527f2de\">属性介绍</h4><h5 id=\"0e8a88a1\">开启grid布局</h5><pre data-lang=\"css\"><code>display:grid /*这种元素独占一行*/\ndisplay:inline-grid /*这种布局类似于inline-block*/</code></pre><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">注意，设为网格布局以后，容器子元素（项目）的 </span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\"><strong><code>float、display: inline-block、display: table-cell、vertical-align 和 column-*</code></strong></span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">  等设置都将失效。</span></p></blockquote><h5 id=\"fe36677d\">划分行与列布局</h5><pre data-lang=\"css\"><code>/*下面定义是宽高都是200px的三行三列网格*/\ngrid-template-columns: 200px 200px 200px; /*这里的单位不仅可以使用固定单位，也可以使用百分比*/\ngrid-template-rows: 200px 200px 200px;</code></pre><p><br /></p><p><span style=\"background-color: \"rgba(0, 0, 0, 0)\";\">重复数值 </span><code>repeat()</code><span style=\"background-color: \"rgba(0, 0, 0, 0)\";\"> </span><br /></p><pre data-lang=\"css\"><code>grid-template-columns: reqeat(3,200px); \ngrid-template-rows: reqeat(3,200px);</code></pre><p><strong><code>repeat()</code></strong> 接受两个值，第一个值为重复的次数，第二个值是重复的数值。</p><p><br /></p><h5 id=\"80ae2394\">重复的次数自动填充</h5><pre data-lang=\"css\"><code>grid-template-columns: reqeat(auto-fill,200px); \ngrid-template-rows: reqeat(3,200px);</code></pre><p><br /></p><blockquote><p><strong><code>auto-fill</code></strong> 可以按照重复的数值，将子元素铺满父元素，超出便会换行</p></blockquote><p><br /></p><h5 id=\"07b55829\">fr <span style=\"background-color: \"rgba(0, 0, 0, 0)\";\">关键词</span></h5><p>这关键词有点类似 <strong><code>flex</code></strong>  布局的 <strong><code>flex:1</code></strong> </p><pre data-lang=\"css\"><code>grid-template-columns: 1fr 2fr; /* 2fr相当于1fr的两倍 */</code></pre><p><br /></p><h5 id=\"e8bd0e48\">行间距、列间距</h5><pre data-lang=\"css\"><code> grid-row-gap: 20px; /*行间距*/\ngrid-column-gap: 20px; /*列间距*/</code></pre><p><br /></p><h5 id=\"969e849d\">排列先后问题 <code>grid-auto-flow</code> </h5><pre data-lang=\"css\"><code>grid-auto-flow: column;\ngrid-auto-flow:row /*默认*/</code></pre><p><br /></p><p>更详细的可以去看下阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\"><strong>grid教程</strong></a></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [ 文档排版布局 ]</p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22y28ue%22%7D\"></card><h3 id=\"ZImkg\"><span style=\"background-color: transparent;\"><cursor />浏览器默认排版 - 正常流</span></h3><blockquote><p><span class=\"lake-fontsize-14\">浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样</span></p></blockquote><p><span class=\"lake-fontsize-14\"><br /></span></p><p><span class=\"lake-fontsize-12\">浏览器默认的文字排版规则：规定了</span><span class=\"lake-fontsize-12\"><strong>行模型及文字在行模型中的排版。</strong>行模型中规定了，文字的</span><strong><span class=\"lake-fontsize-12\">行顶</span></strong><strong><span class=\"lake-fontsize-12\">、</span></strong><strong><span class=\"lake-fontsize-12\">行底、中心（文字区域）、基线</span></strong><span class=\"lake-fontsize-12\">几种对齐方式。一般</span><strong><span class=\"lake-fontsize-12\">默认是基线对齐。</span></strong></p><p><br /></p><p>浏览器不仅支持文字排版，还支持文字与其他元素排版。元素被定义为拥有一定区域的盒子。这个盒子由：<strong>元素内容、</strong><strong>内边距、边框、外边距</strong>组成。</p><p><br /></p><p><span class=\"lake-fontsize-12\">浏览器排版，还包括：</span><strong><span class=\"lake-fontsize-12\">flex布局（</span></strong><span class=\"lake-fontsize-12\">这里主要是通过display的属性控制排版方式</span><strong><span class=\"lake-fontsize-12\">） 、定位布局（</span></strong><span class=\"lake-fontsize-12\">这里包括</span><strong><span class=\"lake-fontsize-12\">绝对定位、相对定位，固定定位）、浮动布局</span></strong><span class=\"lake-fontsize-12\"> 、还有老式的</span><strong><span class=\"lake-fontsize-12\">table布局</span></strong><strong><span class=\"lake-fontsize-12\">。</span></strong></p><p><br /></p><h4 id=\"335b97c0\">盒模型</h4><blockquote><p>讲到布局，就不能不讲一下盒模型，</p></blockquote><p>一般元素都具有盒模型特征，主要由</p><ul><li>content （内容）</li><li>padding（内边距）</li><li>border（边框）</li><li>margin（外边距）</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\">元素还分为三类：</span></p><ul><li><strong>行内元素（inline）</strong>：这类元素<strong>无法赋值宽高</strong><span>，元素的宽高由内容撑开</span>，<strong>上内边距</strong>赋值之后<strong>无法生效</strong>。<strong>上下的外边距</strong>赋值之后是<strong>无法生效</strong></li><li><strong>行内块元素（inline-block）</strong>：这类元素可以的赋值宽高，也可以设置内外边距</li><li><strong>块级元素（block）</strong>：这类元素独占一行，不管元素是否有一行的宽，宽高内外边距都可以赋值。</li></ul><p><br /></p><h3 id=\"2e169b41\">flex布局</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22display%3Aflex%3B%5Cnjustify-content%3A%20center%3B%5Cnalign-items%3A%20center%3B%22%2C%22id%22%3A%222nydV%22%7D\"></card><p><span style=\"background-color: rgba(0, 0, 0, 0);\"><br />详细的可以看我之前的文章  </span><a href=\"https://wuxin.netlify.com/passages/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bflex%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/\" target=\"_blank\">flex布局总结</a><br /></p><p>另外说一点就是。 <strong><code>display</code></strong> 这个属性的不同的值可以改变元素的布局方式</p><p><br /></p><h3 id=\"4eb6b409\">定位布局</h3><h4 id=\"d0285350\">相对定位</h4><p style=\"text-indent: 2em;\"><strong><code>position</code></strong> 为 <strong><code>absolute</code></strong> 属性的元素，这类元素根据父级元素定位，一层层向上查找，如果没找到。最终会找到   <strong><code>body</code></strong> ，这类布局不参与正常流排版，他自有自己的一套排版规则。按照这种定位布局之后，将在文档中不占位置</p><h4 id=\"ff40a9ca\">绝对定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为  </span><span class=\"lake-fontsize-11\"><strong><code>relative</code></strong></span><span class=\"lake-fontsize-11\">  属性的元素，这类元素是根据自己定位，定位移动的话，是根据自己自身移动，自身本身占据的位置不管是随着如何移动，依然在文档中占据位置</span></p><h4 id=\"7d121dca\">固定定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为 </span><strong><code><span class=\"lake-fontsize-11\">fixed</span></code></strong> <span class=\"lake-fontsize-11\">属性的元素</span>，这类元素是根据浏览器可视定位。最大宽高是浏览器视口的宽高。超出部分会被裁剪隐藏。定位移动是根据浏览器定位移动，在正常文档流中不占据位置。</p><p><br /></p><h3 id=\"ad793c09\">浮动布局</h3><p>当元素使用 <strong><code>float: right</code></strong> 或者 <strong><code>float:left</code></strong> 的时候，就可以开启浮动布局。不过相对于其他的布局来说， <strong><code>float</code></strong> 的布局，浏览器会先将其排入正常流，然后再其排到其父元素最左/最右。移动之后的浮动元素，在没清除浮动之前，其父级元素是不占据位置。同级的浮动元素处于同一空间内，在浮动空间内的布局的规则，很像正常元素在正常流上的布局。</p><p><br /></p><h3 id=\"a8fb79d2\">table布局（表格布局）</h3><blockquote><p>顾名思，就是讲网页分割成一个个网格，然后对网格进行排版</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cstyle%3E%5Cn%20%20div%7B%5Cn%20%20%20%20%2F*%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BE%97%E7%BB%99%E5%AE%BD%E9%AB%98%5C%5C(%5Eo%5E)%2F~*%2F%5Cn%20%20%20%20display%3Atable-cell%3B%5Cn%20%20%20%20text-align%3Acenter%3B%5Cn%20%20%20%20vertical-align%3A%20middle%3B%5Cn%20%20%7D%5Cn%3C%2Fstyle%3E%5Cn%3Cbody%3E%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Cem%3E%E7%88%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E7%97%85%EF%BC%8C%E4%BD%A0%E7%97%85%E7%9A%84%E4%B8%8D%E8%BD%BB%EF%BC%8C%E8%BF%98%E4%BB%8E%E6%9D%A5%E6%B2%A1%E6%9C%89%E5%A5%BD%E8%BF%87%E3%80%82%3C%2Fem%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fbody%3E%22%2C%22id%22%3A%22YyVcZ%22%7D\"></card><p><br /></p><ul><li>当父元素是要  <strong><code>display : table-row， 子元素使用  display : table-cell</code></strong>   的时候。子元素是等高的</li><li>当父元素是要 <strong><code>display : table-row， 子元素使用  display : table-row</code></strong>  的时候。子元素是等宽的</li></ul><h3 id=\"a5bed4e2\">Grid布局（网格布局）</h3><blockquote><p>这种布局和 <strong><code>flex</code></strong> 布局很像，但是 <strong><code>grid</code></strong> 布局更倾向于二维布局。</p></blockquote><h4 id=\"df368884\">前言</h4><ul><li>在 <strong><code>Grid</code></strong> 布局中，采用布局的区域称之为<strong>&quot;容器&quot;</strong>，容器内采用网格布局的子元素称之为 <strong>&quot;项目&quot;</strong></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Carticle%3E%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%20%20%3Cp%3E%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E4%B8%80%E5%8F%8C%E4%BA%BA%3C%2Fp%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%20%20%3Cp%3E%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E4%B8%80%E5%8F%8C%E4%BA%BA%3C%2Fp%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%20%20%3Cp%3E%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E4%B8%80%E5%8F%8C%E4%BA%BA%3C%2Fp%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%3C%2Farticle%3E%22%2C%22id%22%3A%220jRRQ%22%7D\"></card><blockquote><p><span class=\"lake-fontsize-12\">上面的 </span><span class=\"lake-fontsize-12\"><strong><code>article</code></strong></span><span class=\"lake-fontsize-12\"> 就可以作为一个</span><span class=\"lake-fontsize-12\"><strong>容器，</strong></span><span class=\"lake-fontsize-12\">作为他的子元素 </span><strong><code><span class=\"lake-fontsize-12\">div</span></code></strong> <span class=\"lake-fontsize-12\"> 便是 </span><span class=\"lake-fontsize-12\"><strong>项目 </strong></span><span class=\"lake-fontsize-12\">，但是作为子元素的子元素 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">便不是项目，项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">元素就不是项目。 </span><strong><code><span class=\"lake-fontsize-12\">Grid</span></code></strong> <span class=\"lake-fontsize-12\"> 布局只对项目生效</span></p></blockquote><p><br /></p><ul><li><strong>行（row）与列（column）：</strong>正常的是横为行，竖为列</li><li><strong>单元格（cell） </strong>： 行与列相交的地方，称之为单元格</li><li><strong>网格线 </strong>： 划分单元格的线称之为网格线</li></ul><p><br /></p><h4 id=\"1527f2de\">属性介绍</h4><h5 id=\"0e8a88a1\">开启grid布局</h5><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22display%3Agrid%20%2F*%E8%BF%99%E7%A7%8D%E5%85%83%E7%B4%A0%E7%8B%AC%E5%8D%A0%E4%B8%80%E8%A1%8C*%2F%5Cndisplay%3Ainline-grid%20%2F*%E8%BF%99%E7%A7%8D%E5%B8%83%E5%B1%80%E7%B1%BB%E4%BC%BC%E4%BA%8Einline-block*%2F%22%2C%22id%22%3A%22P3FV3%22%7D\"></card><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">注意，设为网格布局以后，容器子元素（项目）的 </span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\"><strong><code>float、display: inline-block、display: table-cell、vertical-align 和 column-*</code></strong></span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">  等设置都将失效。</span></p></blockquote><h5 id=\"fe36677d\">划分行与列布局</h5><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%2F*%E4%B8%8B%E9%9D%A2%E5%AE%9A%E4%B9%89%E6%98%AF%E5%AE%BD%E9%AB%98%E9%83%BD%E6%98%AF200px%E7%9A%84%E4%B8%89%E8%A1%8C%E4%B8%89%E5%88%97%E7%BD%91%E6%A0%BC*%2F%5Cngrid-template-columns%3A%20200px%20200px%20200px%3B%20%2F*%E8%BF%99%E9%87%8C%E7%9A%84%E5%8D%95%E4%BD%8D%E4%B8%8D%E4%BB%85%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%9B%BA%E5%AE%9A%E5%8D%95%E4%BD%8D%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%99%BE%E5%88%86%E6%AF%94*%2F%5Cngrid-template-rows%3A%20200px%20200px%20200px%3B%22%2C%22id%22%3A%22DryfO%22%7D\"></card><p><br /></p><p><span style=\"background-color: rgba(0, 0, 0, 0);\">重复数值 </span><code>repeat()</code><span style=\"background-color: rgba(0, 0, 0, 0);\"> </span><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-template-columns%3A%20reqeat(3%2C200px)%3B%20%5Cngrid-template-rows%3A%20reqeat(3%2C200px)%3B%22%2C%22id%22%3A%228o8kb%22%7D\"></card><p><strong><code>repeat()</code></strong> 接受两个值，第一个值为重复的次数，第二个值是重复的数值。</p><p><br /></p><h5 id=\"80ae2394\">重复的次数自动填充</h5><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-template-columns%3A%20reqeat(auto-fill%2C200px)%3B%20%5Cngrid-template-rows%3A%20reqeat(3%2C200px)%3B%22%2C%22id%22%3A%22cA5Pa%22%7D\"></card><p><br /></p><blockquote><p><strong><code>auto-fill</code></strong> 可以按照重复的数值，将子元素铺满父元素，超出便会换行</p></blockquote><p><br /></p><h5 id=\"07b55829\">fr <span style=\"background-color: rgba(0, 0, 0, 0);\">关键词</span></h5><p>这关键词有点类似 <strong><code>flex</code></strong>  布局的 <strong><code>flex:1</code></strong> </p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-template-columns%3A%201fr%202fr%3B%20%2F*%202fr%E7%9B%B8%E5%BD%93%E4%BA%8E1fr%E7%9A%84%E4%B8%A4%E5%80%8D%20*%2F%22%2C%22id%22%3A%22LpbgJ%22%7D\"></card><p><br /></p><h5 id=\"e8bd0e48\">行间距、列间距</h5><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%20grid-row-gap%3A%2020px%3B%20%2F*%E8%A1%8C%E9%97%B4%E8%B7%9D*%2F%5Cngrid-column-gap%3A%2020px%3B%20%2F*%E5%88%97%E9%97%B4%E8%B7%9D*%2F%22%2C%22id%22%3A%22WcAub%22%7D\"></card><p><br /></p><h5 id=\"969e849d\">排列先后问题 <code>grid-auto-flow</code> </h5><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-auto-flow%3A%20column%3B%5Cngrid-auto-flow%3Arow%20%2F*%E9%BB%98%E8%AE%A4*%2F%22%2C%22id%22%3A%22uR4qD%22%7D\"></card><p><br /></p><p>更详细的可以去看下阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\"><strong>grid教程</strong></a></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T02:00:10.000Z",
    "deleted_at": null,
    "created_at": "2019-04-08T08:48:29.000Z",
    "updated_at": "2019-04-28T02:00:10.000Z",
    "published_at": "2019-04-28T02:00:10.000Z",
    "first_published_at": "2019-04-09T02:00:09.000Z",
    "word_count": 1583,
    "cover": null,
    "description": "tags: [ 文档排版布局 ]categories: 重学前端系列笔记浏览器默认排版 - 正常流浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样浏览器默认的文字排版规则：规定了行模型及文字在行模型中的排版...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1469346,
    "slug": "cfusxb",
    "title": "6. http协议",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [http协议]<br />categories: 重学前端系列笔记\n\n---\n<a name=\"N0fX6\"></a>\n### 什么是http?\n\n> 简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们\n> HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。\n\n\n<a name=\"9e404cbd\"></a>\n### http协议的格式\n\n![](https://cdn.nlark.com/yuque/0/2019/png/221851/1556416825286-c51f1341-1445-4a64-9893-9c86e3a68beb.png)\n\n<a name=\"25717aa2\"></a>\n#### 其中 **request-method **代表是此次发送请求是什么方法\n\n- GET \n- POST \n- HEAD\n-  PUT \n- DELETE \n- CONNECT \n- OPTIONS \n- TRACE\n\n浏览器通过地址栏访问页面都是 GET 方法。表单提交默认是 POST 方法\n\nHEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起\n\nPUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。\n\nCONNECT 现在多用于 HTTPS 和 WebSocket。\n\nOPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。\n\n<a name=\"148be3df\"></a>\n#### Status Code （状态码）\n\n- 1xx：临时回应，表示客户端请继续\n- 2xx：请求成功。\n- 3xx: 表示请求的目标有变化，希望客户端进一步处理。\n- 4xx：客户端请求错误。\n- 5xx：服务端请求错误。\n\n<a name=\"be47bd27\"></a>\n#### 请求头\n![请求头.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554712749401-938ab3d8-393f-47e8-ae4f-11c55990401d.png#align=left&display=inline&height=407&name=%E8%AF%B7%E6%B1%82%E5%A4%B4.png&originHeight=407&originWidth=633&size=75594&status=done&width=633)\n\n<a name=\"dca6cb61\"></a>\n#### 响应头\n![响应头.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554712777314-1716a350-fb17-430e-9989-3ce5b4b56a47.png#align=left&display=inline&height=453&name=%E5%93%8D%E5%BA%94%E5%A4%B4.png&originHeight=453&originWidth=627&size=84667&status=done&width=627)\n\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [<span>http协议</span>]</p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"N0fX6\"><span style=\"background-color: transparent;\">什么是http?</span></h3><p><br /></p><blockquote><p>简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们</p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。</span></p></blockquote><p><br /></p><h3 id=\"9e404cbd\">http协议的格式</h3><p><br /></p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1556416825286-c51f1341-1445-4a64-9893-9c86e3a68beb.png\" style=\"max-width: 600px;\" /><p><br /></p><p><br /></p><h4 id=\"25717aa2\"><span>其中 </span><strong>request-method </strong><span>代表是此次发送请求是什么方法</span></h4><ul><li><span>GET </span></li><li><span>POST </span></li><li>HEAD</li><li> PUT </li><li><span>DELETE </span></li><li>CONNECT </li><li><span>OPTIONS </span></li><li><span>TRACE</span></li></ul><p><br /></p><p>浏览器通过地址栏访问页面都是 GET 方法。表单提交默认是 POST 方法</p><p><br /></p><p>HEAD 则是跟 GET 类似，只返回请求头，多数由 <span>JavaScript </span><span>发起</span></p><p><br /></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">CONNECT 现在多用于 HTTPS 和 WebSocket。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。</span></p><p><br /></p><h4 id=\"148be3df\">Status Code （状态码）</h4><ul><li><span>1xx：临时回应，表示客户端请继续</span></li><li>2xx：请求成功。</li><li>3xx: 表示请求的目标有变化，希望客户端进一步处理。</li><li>4xx：客户端请求错误。</li><li>5xx：服务端请求错误。</li></ul><p><br /></p><h4 id=\"be47bd27\">请求头</h4><p><img alt=\"请求头.png\" title=\"请求头.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554712749401-938ab3d8-393f-47e8-ae4f-11c55990401d.png#align=left&amp;display=inline&amp;height=407&amp;name=%E8%AF%B7%E6%B1%82%E5%A4%B4.png&amp;originHeight=407&amp;originWidth=633&amp;size=75594&amp;status=done&amp;width=633\" style=\"max-width: 600px; width: 633px;\" /></p><p><br /></p><h4 id=\"dca6cb61\">响应头</h4><p><img alt=\"响应头.png\" title=\"响应头.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554712777314-1716a350-fb17-430e-9989-3ce5b4b56a47.png#align=left&amp;display=inline&amp;height=453&amp;name=%E5%93%8D%E5%BA%94%E5%A4%B4.png&amp;originHeight=453&amp;originWidth=627&amp;size=84667&amp;status=done&amp;width=627\" style=\"max-width: 600px; width: 627px;\" /></p><p><br /></p><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [<span>http协议</span>]</p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22xXB3C%22%7D\"></card><h3 id=\"N0fX6\"><span style=\"background-color: transparent;\"><cursor />什么是http?</span></h3><p><br /></p><blockquote><p>简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们</p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。</span></p></blockquote><p><br /></p><h3 id=\"9e404cbd\">http协议的格式</h3><p><br /></p><card type=\"block\" name=\"mindmap\" value=\"data:%7B%22id%22%3A%22kuwOK%22%2C%22graphData%22%3A%7B%22roots%22%3A%5B%7B%22label%22%3A%22HTTP%E5%8D%8F%E8%AE%AE%22%2C%22children%22%3A%5B%7B%22label%22%3A%22Request%22%2C%22side%22%3A%22right%22%2C%22id%22%3A%22b8d74ffa%22%2C%22children%22%3A%5B%7B%22id%22%3A%22c13fb1e9%22%2C%22label%22%3A%22request%20line%22%2C%22children%22%3A%5B%7B%22id%22%3A%22bb9cb5ce%22%2C%22label%22%3A%22method%22%2C%22side%22%3A%22right%22%2C%22hierarchy%22%3A4%2C%22parent%22%3A%22c13fb1e9%22%2C%22width%22%3A59.025390625%2C%22height%22%3A23%2C%22x%22%3A354.8046875%2C%22y%22%3A-168%7D%2C%7B%22id%22%3A%22528d4d00%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22path%22%2C%22hierarchy%22%3A4%2C%22parent%22%3A%22c13fb1e9%22%2C%22width%22%3A42.35546875%2C%22height%22%3A23%2C%22x%22%3A346.4697265625%2C%22y%22%3A-141%7D%2C%7B%22id%22%3A%222cd20f46%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22version%22%2C%22hierarchy%22%3A4%2C%22parent%22%3A%22c13fb1e9%22%2C%22width%22%3A57.68359375%2C%22height%22%3A23%2C%22x%22%3A354.1337890625%2C%22y%22%3A-114%7D%5D%2C%22side%22%3A%22right%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22b8d74ffa%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A73.0390625%2C%22height%22%3A31%2C%22x%22%3A252.7724609375%2C%22y%22%3A-141%7D%2C%7B%22id%22%3A%22b7fef410%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22head%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22b8d74ffa%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.6953125%2C%22height%22%3A31%2C%22x%22%3A235.1005859375%2C%22y%22%3A-81%7D%2C%7B%22id%22%3A%22206e9d8e%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22body%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22b8d74ffa%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.021484375%2C%22height%22%3A31%2C%22x%22%3A234.763671875%2C%22y%22%3A-46%7D%5D%2C%22hierarchy%22%3A2%2C%22parent%22%3A%222a07c73a%22%2C%22shape%22%3A%22mind-first-sub%22%2C%22width%22%3A79.14453125%2C%22height%22%3A31%2C%22x%22%3A134.6806640625%2C%22y%22%3A-93.5%7D%2C%7B%22label%22%3A%22Response%22%2C%22side%22%3A%22right%22%2C%22id%22%3A%22f6549fcd%22%2C%22children%22%3A%5B%7B%22id%22%3A%22f1ca0587%22%2C%22label%22%3A%22request%20line%22%2C%22side%22%3A%22right%22%2C%22children%22%3A%5B%7B%22id%22%3A%22e40ce380%22%2C%22label%22%3A%22version%22%2C%22hierarchy%22%3A4%2C%22side%22%3A%22right%22%2C%22parent%22%3A%22f1ca0587%22%2C%22width%22%3A57.68359375%2C%22height%22%3A23%2C%22x%22%3A365.0302734375%2C%22y%22%3A3%7D%2C%7B%22id%22%3A%220beaa43e%22%2C%22label%22%3A%22status%20code%22%2C%22hierarchy%22%3A4%2C%22side%22%3A%22right%22%2C%22parent%22%3A%22f1ca0587%22%2C%22width%22%3A80.37109375%2C%22height%22%3A23%2C%22x%22%3A376.3740234375%2C%22y%22%3A30%7D%2C%7B%22id%22%3A%2237782077%22%2C%22label%22%3A%22status%20text%22%2C%22hierarchy%22%3A4%2C%22side%22%3A%22right%22%2C%22parent%22%3A%22f1ca0587%22%2C%22width%22%3A73.69140625%2C%22height%22%3A23%2C%22x%22%3A373.0341796875%2C%22y%22%3A57%7D%5D%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22f6549fcd%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A73.0390625%2C%22height%22%3A31%2C%22x%22%3A263.6689453125%2C%22y%22%3A30%7D%2C%7B%22id%22%3A%2232966f18%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22head%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22f6549fcd%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.6953125%2C%22height%22%3A31%2C%22x%22%3A245.9970703125%2C%22y%22%3A90%7D%2C%7B%22id%22%3A%220b81f415%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22body%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22f6549fcd%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.021484375%2C%22height%22%3A31%2C%22x%22%3A245.66015625%2C%22y%22%3A125%7D%5D%2C%22hierarchy%22%3A2%2C%22parent%22%3A%222a07c73a%22%2C%22shape%22%3A%22mind-first-sub%22%2C%22width%22%3A90.041015625%2C%22height%22%3A31%2C%22x%22%3A140.12890625%2C%22y%22%3A77.5%7D%5D%2C%22id%22%3A%222a07c73a%22%2C%22shape%22%3A%22mind-root%22%2C%22hierarchy%22%3A1%2C%22width%22%3A142.216796875%2C%22height%22%3A46%2C%22x%22%3A-8%2C%22y%22%3A-8%7D%5D%7D%2C%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1556416825286-c51f1341-1445-4a64-9893-9c86e3a68beb.png%22%2C%22matrix%22%3A%5B1.5000000000000004%2C0%2C0%2C0%2C1.5000000000000004%2C0%2C121.09116908482144%2C263.53571428571433%2C1%5D%2C%22height%22%3A481%7D\"></card><p><br /></p><p><br /></p><h4 id=\"25717aa2\"><span>其中 </span><strong>request-method </strong><span>代表是此次发送请求是什么方法</span></h4><ul><li><span>GET </span></li><li><span>POST </span></li><li>HEAD</li><li> PUT </li><li><span>DELETE </span></li><li>CONNECT </li><li><span>OPTIONS </span></li><li><span>TRACE</span></li></ul><p><br /></p><p>浏览器通过地址栏访问页面都是 GET 方法。表单提交默认是 POST 方法</p><p><br /></p><p>HEAD 则是跟 GET 类似，只返回请求头，多数由 <span>JavaScript </span><span>发起</span></p><p><br /></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">CONNECT 现在多用于 HTTPS 和 WebSocket。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。</span></p><p><br /></p><h4 id=\"148be3df\">Status Code （状态码）</h4><ul><li><span>1xx：临时回应，表示客户端请继续</span></li><li>2xx：请求成功。</li><li>3xx: 表示请求的目标有变化，希望客户端进一步处理。</li><li>4xx：客户端请求错误。</li><li>5xx：服务端请求错误。</li></ul><p><br /></p><h4 id=\"be47bd27\">请求头</h4><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554712749401-938ab3d8-393f-47e8-ae4f-11c55990401d.png%22%2C%22originWidth%22%3A633%2C%22originHeight%22%3A407%2C%22name%22%3A%22%E8%AF%B7%E6%B1%82%E5%A4%B4.png%22%2C%22size%22%3A75594%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A633%2C%22height%22%3A407%7D\"></card></p><p><br /></p><h4 id=\"dca6cb61\">响应头</h4><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554712777314-1716a350-fb17-430e-9989-3ce5b4b56a47.png%22%2C%22originWidth%22%3A627%2C%22originHeight%22%3A453%2C%22name%22%3A%22%E5%93%8D%E5%BA%94%E5%A4%B4.png%22%2C%22size%22%3A84667%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A627%2C%22height%22%3A453%7D\"></card></p><p><br /></p><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T02:00:25.000Z",
    "deleted_at": null,
    "created_at": "2019-04-03T08:24:12.000Z",
    "updated_at": "2019-04-28T02:00:25.000Z",
    "published_at": "2019-04-28T02:00:25.000Z",
    "first_published_at": "2019-04-03T08:25:08.000Z",
    "word_count": 351,
    "cover": null,
    "description": "tags: [http协议]categories: 重学前端系列笔记什么是http?简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1468656,
    "slug": "vtgdtr",
    "title": "5. 浏览器渲染与加载优化",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [浏览器渲染 ,加载优化]<br />categories: 重学前端系列笔记\n\n---\n<a name=\"aBzUY\"></a>\n### 浏览器解析网页过程 \n\n1. 解析DOM树，生成 domTree\n1. 解析CSS树，生成 cssTree\n1. 根据domTree上的节点，以及 cssTree 上的属性合成，\n1. 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度\n1. 合成之后，再绘制到界面上\n> **在网页中浏览器解析是从上往下，从左往右解析。遇到类似于网页请求的时候，就会阻塞页面。例如：图片请求，js加载。css加载。**\n\n\n**![tree.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554277582503-3a35e42c-71d3-4aa4-b475-08c74bab3ca2.png#align=left&display=inline&height=420&name=tree.png&originHeight=810&originWidth=1440&size=216758&status=done&width=746)<br />**<br />**\n<a name=\"981b618c\"></a>\n### 优化加载速度\n<a name=\"57d92aca\"></a>\n#### （0）页面dom结构，尽量少嵌套元素。能用一个元素完成的排版，就不用两个\n<a name=\"a693339b\"></a>\n#### （1）js尽量写到body外\n<a name=\"78f0edcc\"></a>\n#### （2）css渲染，尽量别使用大规模的重绘，回流的样式\n> css优化渲染，可以参考，我之前写的 [前端性能之css渲染](https://www.hellomyblog.cn/2018/12/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93.html) 或者 [性能](https://wuxin.netlify.com/passages/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93/)\n\n<a name=\"40ebffe3\"></a>\n#### （4）图片如果可以的，能使用字体图标，就别使用雪碧图\n<a name=\"0d142347\"></a>\n#### （5）在写初始化样式的时候，能用标签，就别用通配符 `*`  \n<a name=\"70b12fd8\"></a>\n#### （6）资源压缩\n> 我们在做项目的时候，经常会将一些 JS 代码分文件分区块存贮，这样虽然方便后期维护，但是会造成多次请求。\n> **所以：**在保证不多次请求的前提下进行模块文件划分。一般是尽量一个 **`JS`** 文件 不超过500行，超过了就抽取成公共函数，暴露引用，这样方便维护。\n> 并且在上线的时候，使用混淆压缩文件体积，可以使请求资源变小\n\n\n**压缩还可以让后端启用**  **`g-zip`** ** **\n\n<a name=\"76486118\"></a>\n#### （7）文件异步加载，文件按需加载\n<a name=\"d62cf5ee\"></a>\n##### ① async\n\n- 这个属性是 H5 新增的属性，需要Chrome、FireFox、IE9+浏览器支持\n- async属性规定一旦脚本可用，则会异步执行<br />\n- async属性仅适用于外部脚本<br />\n- 如果是多个脚本，该方法不能保证脚本按顺序执行\n```html\n<script type=\"text/javascript\" src=\"xxx.js\" async=\"async\"></script>\n```\n\n<a name=\"89c8336e\"></a>\n##### ② **defer**\n\n- 兼容所有浏览器<br />\n- defer属性规定是否对脚本执行进行延迟，直到页面加载为止\n- 如果是多个脚本，该方法可以确保所有设置了defer属性的脚本按顺序执行<br />\n- 如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度<br />\n\n```html\n<script type=\"text/javascript\" src=\"xxx.js\" defer=\"defer\"></script>\n```\n\n<a name=\"a111ed08\"></a>\n##### ③ **动态创建script标签**\n> 通过window.onload方法确保页面加载完毕再将script标签插入到DOM\n\n\n```javascript\nfunctionaddScriptTag(src){\n    var script = document.createElement('script');\n    script.setAttribute(\"type\",\"text/javascript\");\n    script.src =src;\n \t\tdocument.body.appendChild(script);\n}\n  \nwindow.onload =function(){\n  addScriptTag(\"js/index.js\");\n}\n```\n\n<a name=\"21244bbb\"></a>\n##### `async` 与 `defer` 的区别：\n\n- defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行\n- async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关\n<a name=\"c5a971fc\"></a>\n#### （8）利用缓存\n<a name=\"1092fc71\"></a>\n##### ① 利用浏览器强缓存\n> 不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示 **`from disk cache`** ** `from memory cache`**\n\n\n\n<a name=\"0ee2c4fc\"></a>\n#### （9）使用CDN\n> 通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载\n\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [浏览器渲染 ,加载优化]</p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"aBzUY\"><span style=\"background-color: transparent;\">浏览器解析网页过程 </span></h3><ol start=\"1\"><li>解析DOM树，生成 domTree</li><li>解析CSS树，生成 cssTree</li><li>根据domTree上的节点，以及 cssTree 上的属性合成，</li><li>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度</li><li>合成之后，再绘制到界面上</li></ol><blockquote><p><span class=\"lake-fontsize-12\"><strong>在网页中浏览器解析是从上往下，从左往右解析。遇到类似于网页请求的时候，就会阻塞页面。例如：图片请求，js加载。css加载。</strong></span></p></blockquote><p><br /></p><p><span class=\"lake-fontsize-12\"><strong><img alt=\"tree.png\" title=\"tree.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554277582503-3a35e42c-71d3-4aa4-b475-08c74bab3ca2.png#align=left&amp;display=inline&amp;height=420&amp;name=tree.png&amp;originHeight=810&amp;originWidth=1440&amp;size=216758&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /><br /></strong></span></p><p><span class=\"lake-fontsize-12\"><strong><br /></strong></span></p><h3 id=\"981b618c\">优化加载速度</h3><h4 id=\"57d92aca\">（0）页面dom结构，尽量少嵌套元素。能用一个元素完成的排版，就不用两个</h4><h4 id=\"a693339b\">（1）js尽量写到body外</h4><h4 id=\"78f0edcc\">（2）css渲染，尽量别使用大规模的重绘，回流的样式</h4><blockquote><p>css优化渲染，可以参考，我之前写的 <a href=\"https://www.hellomyblog.cn/2018/12/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93.html\" target=\"_blank\">前端性能之css渲染</a> 或者 <a href=\"https://wuxin.netlify.com/passages/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93/\" target=\"_blank\">性能</a></p></blockquote><h4 id=\"40ebffe3\">（4）图片如果可以的，能使用字体图标，就别使用雪碧图</h4><h4 id=\"0d142347\">（5）在写初始化样式的时候，能用标签，就别用通配符 <code>*</code>  </h4><h4 id=\"70b12fd8\">（6）资源压缩</h4><blockquote><p>我们在做项目的时候，经常会将一些 JS 代码分文件分区块存贮，这样虽然方便后期维护，但是会造成多次请求。</p><p><strong>所以：</strong><span class=\"lake-fontsize-14\">在保证不多次请求的前提下进行模块文件划分。一般是尽量一个 </span><span class=\"lake-fontsize-14\"><strong><code>JS</code></strong> 文件 不超过500行，超过了就抽取成公共函数，暴露引用，这样方便维护。</span></p><p><span class=\"lake-fontsize-14\">并且在上线的时候，使用混淆压缩文件体积，可以使请求资源变小</span></p></blockquote><p><br /></p><p><strong>压缩还可以让后端启用</strong>  <strong><code>g-zip</code></strong> <strong> </strong></p><p><span class=\"lake-fontsize-14\"><br /></span></p><h4 id=\"76486118\">（7）文件异步加载，文件按需加载</h4><h5 id=\"d62cf5ee\">① async</h5><ul><li>这个属性是 H5 新增的属性，<span style=\"color: #4A4A4A;\">需要Chrome、FireFox、IE9+浏览器支持</span></li><li><span style=\"color: #4A4A4A;\"><span>async属性规定一旦脚本可用，则会异步执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>async属性仅适用于外部脚本</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法不能保证脚本按顺序执行</span></span></li></ul><pre data-lang=\"html\"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</code></pre><p><br /></p><h5 id=\"89c8336e\">② <strong>defer</strong></h5><ul><li><span style=\"color: #4A4A4A;\"><span>兼容所有浏览器</span></span><br /></li><li>defer属性规定是否对脚本执行进行延迟，直到页面加载为止</li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法可以确保所有设置了defer属性的脚本按顺序执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度</span></span><br /></li><p><br /></p></ul><pre data-lang=\"html\"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;</code></pre><p><br /></p><h5 id=\"a111ed08\">③ <strong>动态创建script标签</strong></h5><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #4A4A4A;\">通过window.onload方法确保页面加载完毕再将script标签插入到DOM</span></p></blockquote><p><br /></p><pre data-lang=\"javascript\"><code>functionaddScriptTag(src){\n    var script = document.createElement('script');\n    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);\n    script.src =src;\n \t\tdocument.body.appendChild(script);\n}\n  \nwindow.onload =function(){\n  addScriptTag(&quot;js/index.js&quot;);\n}</code></pre><p><br /></p><h5 id=\"21244bbb\"><code>async</code> 与 <code>defer</code> 的区别：</h5><ul><li>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行</li><li>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</li></ul><h4 id=\"c5a971fc\">（8）利用缓存</h4><h5 id=\"1092fc71\">① 利用浏览器强缓存<br /></h5><blockquote><p>不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示 <strong><code>from disk cache</code></strong>  <strong> </strong>或  <strong> <code>from memory cache</code></strong></p></blockquote><p><br /></p><p><br /></p><h4 id=\"0ee2c4fc\">（9）使用CDN</h4><blockquote><p>通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载</p></blockquote><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [浏览器渲染 ,加载优化]</p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22klTCs%22%7D\"></card><h3 id=\"aBzUY\"><span style=\"background-color: transparent;\"><cursor />浏览器解析网页过程 </span></h3><ol start=\"1\"><li>解析DOM树，生成 domTree</li><li>解析CSS树，生成 cssTree</li><li>根据domTree上的节点，以及 cssTree 上的属性合成，</li><li>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度</li><li>合成之后，再绘制到界面上</li></ol><blockquote><p><span class=\"lake-fontsize-12\"><strong>在网页中浏览器解析是从上往下，从左往右解析。遇到类似于网页请求的时候，就会阻塞页面。例如：图片请求，js加载。css加载。</strong></span></p></blockquote><p><br /></p><p><span class=\"lake-fontsize-12\"><strong><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554277582503-3a35e42c-71d3-4aa4-b475-08c74bab3ca2.png%22%2C%22originWidth%22%3A1440%2C%22originHeight%22%3A810%2C%22name%22%3A%22tree.png%22%2C%22size%22%3A216758%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A420%7D\"></card><br /></strong></span></p><p><span class=\"lake-fontsize-12\"><strong><br /></strong></span></p><h3 id=\"981b618c\">优化加载速度</h3><h4 id=\"57d92aca\">（0）页面dom结构，尽量少嵌套元素。能用一个元素完成的排版，就不用两个</h4><h4 id=\"a693339b\">（1）js尽量写到body外</h4><h4 id=\"78f0edcc\">（2）css渲染，尽量别使用大规模的重绘，回流的样式</h4><blockquote><p>css优化渲染，可以参考，我之前写的 <a href=\"https://www.hellomyblog.cn/2018/12/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93.html\" target=\"_blank\">前端性能之css渲染</a> 或者 <a href=\"https://wuxin.netlify.com/passages/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93/\" target=\"_blank\">性能</a></p></blockquote><h4 id=\"40ebffe3\">（4）图片如果可以的，能使用字体图标，就别使用雪碧图</h4><h4 id=\"0d142347\">（5）在写初始化样式的时候，能用标签，就别用通配符 <code>*</code>  </h4><h4 id=\"70b12fd8\">（6）资源压缩</h4><blockquote><p>我们在做项目的时候，经常会将一些 JS 代码分文件分区块存贮，这样虽然方便后期维护，但是会造成多次请求。</p><p><strong>所以：</strong><span class=\"lake-fontsize-14\">在保证不多次请求的前提下进行模块文件划分。一般是尽量一个 </span><span class=\"lake-fontsize-14\"><strong><code>JS</code></strong> 文件 不超过500行，超过了就抽取成公共函数，暴露引用，这样方便维护。</span></p><p><span class=\"lake-fontsize-14\">并且在上线的时候，使用混淆压缩文件体积，可以使请求资源变小</span></p></blockquote><p><br /></p><p><strong>压缩还可以让后端启用</strong>  <strong><code>g-zip</code></strong> <strong> </strong></p><p><span class=\"lake-fontsize-14\"><br /></span></p><h4 id=\"76486118\">（7）文件异步加载，文件按需加载</h4><h5 id=\"d62cf5ee\">① async</h5><ul><li>这个属性是 H5 新增的属性，<span style=\"color: #4A4A4A;\">需要Chrome、FireFox、IE9+浏览器支持</span></li><li><span style=\"color: #4A4A4A;\"><span>async属性规定一旦脚本可用，则会异步执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>async属性仅适用于外部脚本</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法不能保证脚本按顺序执行</span></span></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20type%3D%5C%22text%2Fjavascript%5C%22%20src%3D%5C%22xxx.js%5C%22%20async%3D%5C%22async%5C%22%3E%3C%2Fscript%3E%22%2C%22id%22%3A%22dd0bu%22%7D\"></card><p><br /></p><h5 id=\"89c8336e\">② <strong>defer</strong></h5><ul><li><span style=\"color: #4A4A4A;\"><span>兼容所有浏览器</span></span><br /></li><li>defer属性规定是否对脚本执行进行延迟，直到页面加载为止</li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法可以确保所有设置了defer属性的脚本按顺序执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度</span></span><br /></li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20type%3D%5C%22text%2Fjavascript%5C%22%20src%3D%5C%22xxx.js%5C%22%20defer%3D%5C%22defer%5C%22%3E%3C%2Fscript%3E%22%2C%22id%22%3A%220bXpU%22%7D\"></card><p><br /></p><h5 id=\"a111ed08\">③ <strong>动态创建script标签</strong></h5><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #4A4A4A;\">通过window.onload方法确保页面加载完毕再将script标签插入到DOM</span></p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22functionaddScriptTag(src)%7B%5Cn%20%20%20%20var%20script%20%3D%20document.createElement('script')%3B%5Cn%20%20%20%20script.setAttribute(%5C%22type%5C%22%2C%5C%22text%2Fjavascript%5C%22)%3B%5Cn%20%20%20%20script.src%20%3Dsrc%3B%5Cn%20%5Ct%5Ctdocument.body.appendChild(script)%3B%5Cn%7D%5Cn%20%20%5Cnwindow.onload%20%3Dfunction()%7B%5Cn%20%20addScriptTag(%5C%22js%2Findex.js%5C%22)%3B%5Cn%7D%22%2C%22id%22%3A%22wNqio%22%7D\"></card><p><br /></p><h5 id=\"21244bbb\"><code>async</code> 与 <code>defer</code> 的区别：</h5><ul><li>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行</li><li>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</li></ul><h4 id=\"c5a971fc\">（8）利用缓存</h4><h5 id=\"1092fc71\">① 利用浏览器强缓存<br /></h5><blockquote><p>不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示 <strong><code>from disk cache</code></strong>  <strong> </strong>或  <strong> <code>from memory cache</code></strong></p></blockquote><p><br /></p><p><br /></p><h4 id=\"0ee2c4fc\">（9）使用CDN</h4><blockquote><p>通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载</p></blockquote><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T02:00:37.000Z",
    "deleted_at": null,
    "created_at": "2019-04-03T07:15:52.000Z",
    "updated_at": "2019-04-28T02:00:37.000Z",
    "published_at": "2019-04-28T02:00:37.000Z",
    "first_published_at": "2019-04-03T07:16:17.000Z",
    "word_count": 916,
    "cover": null,
    "description": "tags: [浏览器渲染 ,加载优化]categories: 重学前端系列笔记浏览器解析网页过程 解析DOM树，生成 domTree解析CSS树，生成 cssTree根据domTree上的节点，以及 cssTree 上的属性合成，一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度合成...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1455644,
    "slug": "csekvc",
    "title": "4. css语法中常见的@规则符",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [css规则符]<br />categories: 重学前端系列笔记\n\n---\n<a name=\"QYCXx\"></a>\n### （0）@charset （规定页面使用什么格式）\n> 这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果\n\n\n```css\n@charset \"UTF-8\";\n```\n\n<a name=\"6b36b468\"></a>\n### （1）@import（用来引入文件）\n> 这个是用来引入另外一个 css 文件到当前文件内。除了页面的 [@charset](#) 标识，其余的都会引入，就相当于复制\n\n\n```css\n/* 两种引入方式 */\n@import \"/css/base.css\"\n@import url(\"/css/base.css\")\n  \n\n@import [ <url> | <string> ]\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;\n```\n<a name=\"92afc589\"></a>\n### （2）@media（用来判断设备类型）\n> 它能够对设备的类型进行一些判断。在 media 的区块内。是普通规则列表。\n\n\n```css\n@media print{\n\theader{\n   font-size:13pt; \n  }\n}\n@media screen{\n\thtml{\n   font-size:50px; \n  }\n}\n\n```\n\n<a name=\"ab5d596d\"></a>\n### （3）@page（分页媒体访问网页时的表现设置）\n> page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。\n\n\n```css\n@page {\n  size: 8.5in 11in;\n  margin: 10%;\n  @top-left {\n    content: \"Hamlet\";\n  }\n  @top-right {\n    content: \"Page \" counter(page);\n  }\n}\n\n```\n\n<a name=\"7722807a\"></a>\n### （4）@counter-style（定义列表样式）\n\n```css\n\n@counter-style count-style{\n\t  system:cyclic/numeric/alphabetic/symbolic/additive/[fixed ?]/[ extends ]; /*这个定义算法*/\n    range:auto/数字范围 ; /*使用范围*/;\n    symbols：符号; or additive-symbols: 符号;\n    prefix：前缀;\n    suffix  : 后缀;\n    pad:补零策略;\n  \tnegative：负数策略;\n    fallback:出错后的默认值;\n  \tspeakas:语音策略;\n}\n```\n具体的可以看 [CSDN参数属性](https://blog.csdn.net/chy555chy/article/details/79928389)，或者可以看 [MDN详解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style)\n\n<a name=\"cdea5a28\"></a>\n### （5）@keyframes（定义关键帧动画）\n> 这个可能是比较熟悉了，定义关键帧动画。著名的 [animate.css](https://daneden.github.io/animate.css/)，就是使用这个定义的多达几十种动画\n> \n\n```css\n/* 定义 */\n@keyframes animateName {\n\tfrom {\n    left: 0;\n    top: 0;\n  }\n  to {\n    left: 100px;\n    top: 100px;\n  }\n}\n\n/*使用*/\n.userAnimate{\n\tanimation:animateName .5s ease-in infinite;\n}\n```\n\n<a name=\"b4364690\"></a>\n### （6）@fontface（定义字体）\n> 著名的 icon字体图标，就是使用这个定义的。\n\n\n```css\n@font-face {\n  font-family: Gentium;\n  src: url(http://example.com/fonts/Gentium.woff);\n}\np { \n  font-family: Gentium, serif; \n}\n```\n\n<a name=\"1086e109\"></a>\n### （7）@supports（判断环境）\n> support 检查环境的特性，它与 media 比较类似\n\n<a name=\"55be0195\"></a>\n### （8）@namespace（设置命名空间）\n> 用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。\n\n\n*****这个还没搞懂用法，暂时先记下\n\n<a name=\"7bb5a181\"></a>\n### （9）@viewport（设置视口特性）\n> 用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。\n\n\n\n大概的就是这些了。有其他的话，之后再做补充吧。\n",
    "body_draft": "",
    "body_html": "<p>tags: [<span>css规则符</span>]</p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"QYCXx\"><span style=\"background-color: transparent;\">（0）@charset （规定页面使用什么格式）</span></h3><blockquote><p>这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@charset &quot;UTF-8&quot;;</code></pre><p><br /></p><h3 id=\"6b36b468\">（1）@import（用来引入文件）</h3><blockquote><p>这个是用来引入另外一个 css 文件到当前文件内。除了页面的 <a href=\"#\">@charset</a> 标识，其余的都会引入，就相当于复制</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>/* 两种引入方式 */\n@import &quot;/css/base.css&quot;\n@import url(&quot;/css/base.css&quot;)\n  \n\n@import [ &lt;url&gt; | &lt;string&gt; ]\n        [ supports( [ &lt;supports-condition&gt; | &lt;declaration&gt; ] ) ]?\n        &lt;media-query-list&gt;? ;</code></pre><h3 id=\"92afc589\">（2）@media（用来判断设备类型）</h3><blockquote><p>它能够对设备的类型进行一些判断。在 media 的区块内。是普通规则列表。</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@media print{\n\theader{\n   font-size:13pt; \n  }\n}\n@media screen{\n\thtml{\n   font-size:50px; \n  }\n}\n</code></pre><p><br /></p><h3 id=\"ab5d596d\">（3）@page（分页媒体访问网页时的表现设置）</h3><blockquote><p>page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@page {\n  size: 8.5in 11in;\n  margin: 10%;\n  @top-left {\n    content: &quot;Hamlet&quot;;\n  }\n  @top-right {\n    content: &quot;Page &quot; counter(page);\n  }\n}\n</code></pre><p><br /></p><h3 id=\"7722807a\">（4）@counter-style（定义列表样式）</h3><p><br /></p><pre data-lang=\"css\"><code>\n@counter-style count-style{\n\t  system:cyclic/numeric/alphabetic/symbolic/additive/[fixed ?]/[ extends ]; /*这个定义算法*/\n    range:auto/数字范围 ; /*使用范围*/;\n    symbols：符号; or additive-symbols: 符号;\n    prefix：前缀;\n    suffix  : 后缀;\n    pad:补零策略;\n  \tnegative：负数策略;\n    fallback:出错后的默认值;\n  \tspeakas:语音策略;\n}</code></pre><p>具体的可以看 <a href=\"https://blog.csdn.net/chy555chy/article/details/79928389\" target=\"_blank\">CSDN参数属性</a>，或者可以看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style\" target=\"_blank\">MDN详解</a></p><p><br /></p><h3 id=\"cdea5a28\">（5）@keyframes（定义关键帧动画）</h3><blockquote><p>这个可能是比较熟悉了，定义关键帧动画。著名的<span class=\"lake-fontsize-14\"> </span><a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\"><span class=\"lake-fontsize-14\">animate.css</span></a>，就是使用这个定义的多达几十种动画</p><p><br /></p></blockquote><pre data-lang=\"css\"><code>/* 定义 */\n@keyframes animateName {\n\tfrom {\n    left: 0;\n    top: 0;\n  }\n  to {\n    left: 100px;\n    top: 100px;\n  }\n}\n\n/*使用*/\n.userAnimate{\n\tanimation:animateName .5s ease-in infinite;\n}</code></pre><p><br /></p><h3 id=\"b4364690\">（6）@fontface（定义字体）</h3><blockquote><p>著名的 <span class=\"lake-fontsize-12\" style=\"color: #FA541C;\">icon字体图标，</span><span class=\"lake-fontsize-11\" style=\"color: #000000;\">就是使用这个定义的。</span></p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@font-face {\n  font-family: Gentium;\n  src: url(http://example.com/fonts/Gentium.woff);\n}\np { \n  font-family: Gentium, serif; \n}</code></pre><p><br /></p><h3 id=\"1086e109\">（7）@supports（判断环境）</h3><blockquote><p>support 检查环境的特性，它与 media 比较类似</p></blockquote><h3 id=\"55be0195\">（8）@namespace（设置命名空间）</h3><blockquote><p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p></blockquote><p><br /></p><p><span class=\"lake-fontsize-16\" style=\"color: #F5222D;\"><strong>*</strong></span>这个还没搞懂用法，暂时先记下</p><p><br /></p><h3 id=\"7bb5a181\">（9）@viewport（设置视口特性）</h3><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。</span></p></blockquote><p><br /></p><p><br /></p><p>大概的就是这些了。有其他的话，之后再做补充吧。</p>",
    "body_lake": "<!doctype lake><p>tags: [<span>css规则符</span>]</p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22TROD3%22%7D\"></card><h3 id=\"QYCXx\"><span style=\"background-color: transparent;\"><cursor />（0）@charset （规定页面使用什么格式）</span></h3><blockquote><p>这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40charset%20%5C%22UTF-8%5C%22%3B%22%2C%22id%22%3A%22tY0sA%22%7D\"></card><p><br /></p><h3 id=\"6b36b468\">（1）@import（用来引入文件）</h3><blockquote><p>这个是用来引入另外一个 css 文件到当前文件内。除了页面的 <card type=\"inline\" name=\"mention\" value=\"data:%7B%22login%22%3A%22%22%2C%22name%22%3A%22charset%22%7D\"></card> 标识，其余的都会引入，就相当于复制</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%2F*%20%E4%B8%A4%E7%A7%8D%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%20*%2F%5Cn%40import%20%5C%22%2Fcss%2Fbase.css%5C%22%5Cn%40import%20url(%5C%22%2Fcss%2Fbase.css%5C%22)%5Cn%20%20%5Cn%5Cn%40import%20%5B%20%3Curl%3E%20%7C%20%3Cstring%3E%20%5D%5Cn%20%20%20%20%20%20%20%20%5B%20supports(%20%5B%20%3Csupports-condition%3E%20%7C%20%3Cdeclaration%3E%20%5D%20)%20%5D%3F%5Cn%20%20%20%20%20%20%20%20%3Cmedia-query-list%3E%3F%20%3B%22%2C%22id%22%3A%22MCDu0%22%7D\"></card><h3 id=\"92afc589\">（2）@media（用来判断设备类型）</h3><blockquote><p>它能够对设备的类型进行一些判断。在 media 的区块内。是普通规则列表。</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40media%20print%7B%5Cn%5Ctheader%7B%5Cn%20%20%20font-size%3A13pt%3B%20%5Cn%20%20%7D%5Cn%7D%5Cn%40media%20screen%7B%5Cn%5Cthtml%7B%5Cn%20%20%20font-size%3A50px%3B%20%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22id%22%3A%22T7ey8%22%7D\"></card><p><br /></p><h3 id=\"ab5d596d\">（3）@page（分页媒体访问网页时的表现设置）</h3><blockquote><p>page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40page%20%7B%5Cn%20%20size%3A%208.5in%2011in%3B%5Cn%20%20margin%3A%2010%25%3B%5Cn%20%20%40top-left%20%7B%5Cn%20%20%20%20content%3A%20%5C%22Hamlet%5C%22%3B%5Cn%20%20%7D%5Cn%20%20%40top-right%20%7B%5Cn%20%20%20%20content%3A%20%5C%22Page%20%5C%22%20counter(page)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22id%22%3A%224Mq8C%22%7D\"></card><p><br /></p><h3 id=\"7722807a\">（4）@counter-style（定义列表样式）</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%5Cn%40counter-style%20count-style%7B%5Cn%5Ct%20%20system%3Acyclic%2Fnumeric%2Falphabetic%2Fsymbolic%2Fadditive%2F%5Bfixed%20%3F%5D%2F%5B%20extends%20%5D%3B%20%2F*%E8%BF%99%E4%B8%AA%E5%AE%9A%E4%B9%89%E7%AE%97%E6%B3%95*%2F%5Cn%20%20%20%20range%3Aauto%2F%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%20%3B%20%2F*%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4*%2F%3B%5Cn%20%20%20%20symbols%EF%BC%9A%E7%AC%A6%E5%8F%B7%3B%20or%20additive-symbols%3A%20%E7%AC%A6%E5%8F%B7%3B%5Cn%20%20%20%20prefix%EF%BC%9A%E5%89%8D%E7%BC%80%3B%5Cn%20%20%20%20suffix%20%20%3A%20%E5%90%8E%E7%BC%80%3B%5Cn%20%20%20%20pad%3A%E8%A1%A5%E9%9B%B6%E7%AD%96%E7%95%A5%3B%5Cn%20%20%5Ctnegative%EF%BC%9A%E8%B4%9F%E6%95%B0%E7%AD%96%E7%95%A5%3B%5Cn%20%20%20%20fallback%3A%E5%87%BA%E9%94%99%E5%90%8E%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%3B%5Cn%20%20%5Ctspeakas%3A%E8%AF%AD%E9%9F%B3%E7%AD%96%E7%95%A5%3B%5Cn%7D%22%2C%22id%22%3A%227LVbX%22%7D\"></card><p>具体的可以看 <a href=\"https://blog.csdn.net/chy555chy/article/details/79928389\" target=\"_blank\">CSDN参数属性</a>，或者可以看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style\" target=\"_blank\">MDN详解</a></p><p><br /></p><h3 id=\"cdea5a28\">（5）@keyframes（定义关键帧动画）</h3><blockquote><p>这个可能是比较熟悉了，定义关键帧动画。著名的<span class=\"lake-fontsize-14\"> </span><a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\"><span class=\"lake-fontsize-14\">animate.css</span></a>，就是使用这个定义的多达几十种动画</p><p><br /></p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%2F*%20%E5%AE%9A%E4%B9%89%20*%2F%5Cn%40keyframes%20animateName%20%7B%5Cn%5Ctfrom%20%7B%5Cn%20%20%20%20left%3A%200%3B%5Cn%20%20%20%20top%3A%200%3B%5Cn%20%20%7D%5Cn%20%20to%20%7B%5Cn%20%20%20%20left%3A%20100px%3B%5Cn%20%20%20%20top%3A%20100px%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F*%E4%BD%BF%E7%94%A8*%2F%5Cn.userAnimate%7B%5Cn%5Ctanimation%3AanimateName%20.5s%20ease-in%20infinite%3B%5Cn%7D%22%2C%22id%22%3A%22PFCDC%22%7D\"></card><p><br /></p><h3 id=\"b4364690\">（6）@fontface（定义字体）</h3><blockquote><p>著名的 <span class=\"lake-fontsize-12\" style=\"color: #FA541C;\">icon字体图标，</span><span class=\"lake-fontsize-11\" style=\"color: #000000;\">就是使用这个定义的。</span></p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40font-face%20%7B%5Cn%20%20font-family%3A%20Gentium%3B%5Cn%20%20src%3A%20url(http%3A%2F%2Fexample.com%2Ffonts%2FGentium.woff)%3B%5Cn%7D%5Cnp%20%7B%20%5Cn%20%20font-family%3A%20Gentium%2C%20serif%3B%20%5Cn%7D%22%2C%22id%22%3A%22FckuY%22%7D\"></card><p><br /></p><h3 id=\"1086e109\">（7）@supports（判断环境）</h3><blockquote><p>support 检查环境的特性，它与 media 比较类似</p></blockquote><h3 id=\"55be0195\">（8）@namespace（设置命名空间）</h3><blockquote><p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p></blockquote><p><br /></p><p><span class=\"lake-fontsize-16\" style=\"color: #F5222D;\"><strong>*</strong></span>这个还没搞懂用法，暂时先记下</p><p><br /></p><h3 id=\"7bb5a181\">（9）@viewport（设置视口特性）</h3><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。</span></p></blockquote><p><br /></p><p><br /></p><p>大概的就是这些了。有其他的话，之后再做补充吧。</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T02:00:52.000Z",
    "deleted_at": null,
    "created_at": "2019-04-01T02:31:09.000Z",
    "updated_at": "2019-04-28T02:00:52.000Z",
    "published_at": "2019-04-28T02:00:52.000Z",
    "first_published_at": "2019-04-01T02:41:00.000Z",
    "word_count": 652,
    "cover": null,
    "description": "tags: [css规则符]categories: 重学前端系列笔记（0）@charset （规定页面使用什么格式）这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果@charset &quot;UTF-8...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1445868,
    "slug": "htkygc",
    "title": "3. 所知道的全部对象类型",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [JavaScript对象类型]<br />categories: 重学前端系列笔记\n\n---\n<a name=\"oB9tz\"></a>\n### 宿主对象: 由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。\n\n-  **`JavaScript`**  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器提供了 **`location`** ** **，**`Window`** 、**`Document`** 等 **API** 都是宿主环境提供的宿主对象。\n- 其中 **`window`**`JavaScript`** 这门语言。\n-  **`JavaScript`** 标准中规定了全局对象属性，**w3c** 的各种标准中规定了 **`window`** 对象的其它属性。\n- 宿主对象也分为固有的和用户可创建的两种，比如 **`document.createElement`**  就可以创建一些 dom 对象。\n- 浏览器也会提供一些构造器，通过 **`new`**`Dom`**`New Image`**`Img`**`Dom`** 对象\n\n<a name=\"4e6b882b\"></a>\n### 内置对象：由 JavaScript 语言提供的对象。\n<a name=\"0cfe2bfe\"></a>\n#### （0）固有对象：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。\n> 固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“**类**”其实就是固有对象的一种。\n\n<a name=\"6d4a04a5\"></a>\n#### （1）原生对象：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。\n**原生的对象有：**<br />![6cb1df319bbc7c7f948acfdb9ffd99d0.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1553847843535-34b058d8-e34f-4ed8-9995-7aa56263e437.png#align=left&display=inline&height=273&name=6cb1df319bbc7c7f948acfdb9ffd99d0.png&originHeight=375&originWidth=988&size=110828&status=done&width=720)\n\n在使用这些对象的时候，可以通过 **`New`**  关键字创建新对象。\n<a name=\"99e0367e\"></a>\n##### 用对象来模拟函数与构造器：函数对象与构造器对象\n> 这类对象具有私有字段 [**[call]] 和 [[construct]]**，其中 \n> - [[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换\n> - 任何对象只需要实现 **[[call]]**函数对象**，可以作为函数去调用\n> - 而如果它能实现 **[[construct]]**，它就是一个**构造器对象**，可以作为构造器被调用。\n\n\n<a name=\"0c56e77d\"></a>\n#### 函数对象调用与构造器调用\n```javascript\nfunction f(){\n    return 1;\n}\nlet v = f(); // 把 f 作为函数调用\nlet o = new f(); // 把 f 作为构造器调用\n\n```\n\n我们大致的可以理解 **[[construct]] **的执行过程为\n\n- 以 Object.protoype 为原型创建一个新对象；\n- 以新对象为 this，执行函数的 [[call]]；\n- 如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。\n- **一定程度上，new创造的对象及属性，构造器之外是无法访问的，在一定程度上可以实现“私有”**\n\n**对于有 `JS` 解析引擎的地方，只要字段正常。宿主对象及内置对象也可以模仿函数对象及构造器对象。**\n\n```javascript\n// 内置对象\nlet time = new Date;\n//或者\nlet time = Date();\n// 宿主对象，在浏览器可以使用Image对象\nlet img = new Image; // 可以得到一个img Dom对象\nlet img = Image() //会抛出错误\n```\n\n<a name=\"1256caf1\"></a>\n#### *注意：     ES6语法创建的函数，仅仅是函数，是不能作为构造器使用的   \n```javascript\nnew (date=>{}) // error\n```\n\n<a name=\"73bf6b4f\"></a>\n#### （2）普通对象：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。\n**例：**\n```javascript\nlet Child = (){};\nlet childItem = new Child\n```\n<a name=\"0d98c747\"></a>\n### 其他\n> 除了上述的对象，有一些对象跟正常的对象有很大的区别，\n> 它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同\n\n\n- **`Array`**`Array`**`length`**  属性根据最大的下标自动发生变化。\n- **`Object.prototype`** ：作为所有正常对象的默认原型，不能再给它设置原型了。\n- **`String`**`String`**  的正整数属性访问会去字符串里查找。\n- **`Arguments`**`arguments`**  的非负整数型下标属性跟对应的变量联动。\n- 模块的 **`namespace`**  对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。\n- 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。\n- **`bind`**`function`** ：跟原来的函数相关联。\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [<span>JavaScript对象类型</span>]</p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"oB9tz\"><span style=\"background-color: transparent;\">宿主对象: </span>由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</h3><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><code>JavaScript</code></strong><span>  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器提供了 </span><strong><code>location</code></strong><span> </span><strong> </strong><span>，</span><strong><code>Window</code></strong><span> 、</span><strong><code>Document</code></strong><span> 等 </span><strong>API</strong><span> 都是宿主环境提供的宿主对象。</span></li><li>其中 <strong><code>window</code></strong> 对象上提供的属性，一部分来自浏览器本身，一部分来自 <strong><code>JavaScript</code></strong> 这门语言。</li><li> <strong><code>JavaScript</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">标准中规定了全局对象属性，</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">w3c</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 的各种标准中规定了</span> <strong><code>window</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象的其它属性。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">宿主对象也分为固有的和用户可创建的两种，比如 </span><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">document.createElement</span></code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 就可以创建一些 dom 对象。</span></li><li>浏览器也会提供一些构造器，通过 <strong><code>new</code></strong>  的方法，创建一个 <strong><code>Dom</code></strong>  对象，例如可以通过  <strong><code>New Image</code></strong> 的形式可以创造 <strong><code>Img</code></strong> 的 <strong><code>Dom</code></strong> 对象</li></ul><p><br /></p><h3 id=\"4e6b882b\">内置对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由 JavaScript 语言提供的对象。</span></h3><h4 id=\"0cfe2bfe\">（0）固有对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</span></h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #222222;\">固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“</span><span class=\"lake-fontsize-12\"><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">类</span></strong></span><span class=\"lake-fontsize-12\" style=\"color: #222222;\">”其实就是固有对象的一种。</span></p></blockquote><h4 id=\"6d4a04a5\">（1）原生对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</span></h4><p><strong>原生的对象有：</strong></p><p><img alt=\"6cb1df319bbc7c7f948acfdb9ffd99d0.png\" title=\"6cb1df319bbc7c7f948acfdb9ffd99d0.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1553847843535-34b058d8-e34f-4ed8-9995-7aa56263e437.png#align=left&amp;display=inline&amp;height=273&amp;name=6cb1df319bbc7c7f948acfdb9ffd99d0.png&amp;originHeight=375&amp;originWidth=988&amp;size=110828&amp;status=done&amp;width=720\" style=\"max-width: 600px; width: 720px;\" /></p><p><br /></p><p>在使用这些对象的时候，可以通过 <strong><code>New</code></strong>  关键字创建新对象。</p><h5 id=\"99e0367e\">用对象来模拟函数与构造器：函数对象与构造器对象</h5><blockquote><p>这类对象具有私有字段 [<strong>[call]] 和 </strong><strong>[[construct]]</strong>，其中 </p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换</span></li><li>任何对象只需要实现 <strong>[[call]]</strong>，它就是一个<strong>函数对象</strong>，可以作为函数去调用</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">而如果它能实现 </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]]</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，它就是一个</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">构造器对象</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，可以作为构造器被调用。</span></li></ul></blockquote><p><br /></p><h4 id=\"0c56e77d\">函数对象调用与构造器调用</h4><pre data-lang=\"javascript\"><code>function f(){\n    return 1;\n}\nlet v = f(); // 把 f 作为函数调用\nlet o = new f(); // 把 f 作为构造器调用\n</code></pre><p><br /></p><p>我们大致的可以理解<span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]] </span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">的执行过程为</span></p><ul><li>以 Object.protoype 为原型创建一个新对象；</li><li>以新对象为 this，执行函数的 [[call]]；</li><li>如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li><li><strong>一定程度上，new创造的对象及属性，构造器之外是无法访问的，在一定程度上可以实现“私有”</strong></li></ul><p><br /></p><p><strong><span>对于有 </span></strong><strong><code>JS</code></strong><strong><span> 解析引擎的地方，只要字段正常。宿主对象及内置对象也可以模仿函数对象及构造器对象。</span></strong></p><p><br /></p><pre data-lang=\"javascript\"><code>// 内置对象\nlet time = new Date;\n//或者\nlet time = Date();\n// 宿主对象，在浏览器可以使用Image对象\nlet img = new Image; // 可以得到一个img Dom对象\nlet img = Image() //会抛出错误</code></pre><p><br /></p><h4 id=\"1256caf1\"><span style=\"color: #F5222D;\">*</span><span style=\"color: #F5222D;\">注意：</span><span style=\"color: #FFFFFF;\">  </span><span style=\"color: #FFFFFF; background-color: #003A8C;\">   ES6语法创建的函数，仅仅是函数，是不能作为构造器使用的   </span></h4><pre data-lang=\"javascript\"><code>new (date=&gt;{}) // error</code></pre><p><br /></p><h4 id=\"73bf6b4f\">（2）普通对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</span></h4><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">例：</span></strong></p><pre data-lang=\"javascript\"><code>let Child = (){};\nlet childItem = new Child</code></pre><h3 id=\"0d98c747\">其他</h3><blockquote><p>除了上述的对象，有一些对象跟正常的对象有很大的区别，</p><p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同</p></blockquote><p><br /></p><ul><li><strong><code>Array</code></strong> ：<strong><code>Array</code></strong>  的 <strong><code>length</code></strong>  属性根据最大的下标自动发生变化。</li><li><strong><code>Object.prototype</code></strong> ：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li><strong><code>String</code></strong> ：为了支持下标运算，<strong><code>String</code></strong>  的正整数属性访问会去字符串里查找。</li><li><strong><code>Arguments</code></strong> ：<strong><code>arguments</code></strong>  的非负整数型下标属性跟对应的变量联动。</li><li>模块的 <strong><code>namespace</code></strong>  对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li><strong><code>bind</code></strong>  后的 <strong><code>function</code></strong> ：跟原来的函数相关联。</li></ul><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [<span>JavaScript对象类型</span>]</p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22yrQAq%22%7D\"></card><h3 id=\"oB9tz\"><span style=\"background-color: transparent;\"><cursor />宿主对象: </span>由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</h3><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><code>JavaScript</code></strong><span>  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器提供了 </span><strong><code>location</code></strong><span> </span><strong> </strong><span>，</span><strong><code>Window</code></strong><span> 、</span><strong><code>Document</code></strong><span> 等 </span><strong>API</strong><span> 都是宿主环境提供的宿主对象。</span></li><li>其中 <strong><code>window</code></strong> 对象上提供的属性，一部分来自浏览器本身，一部分来自 <strong><code>JavaScript</code></strong> 这门语言。</li><li> <strong><code>JavaScript</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">标准中规定了全局对象属性，</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">w3c</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 的各种标准中规定了</span> <strong><code>window</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象的其它属性。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">宿主对象也分为固有的和用户可创建的两种，比如 </span><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">document.createElement</span></code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 就可以创建一些 dom 对象。</span></li><li>浏览器也会提供一些构造器，通过 <strong><code>new</code></strong>  的方法，创建一个 <strong><code>Dom</code></strong>  对象，例如可以通过  <strong><code>New Image</code></strong> 的形式可以创造 <strong><code>Img</code></strong> 的 <strong><code>Dom</code></strong> 对象</li></ul><p><br /></p><h3 id=\"4e6b882b\">内置对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由 JavaScript 语言提供的对象。</span></h3><h4 id=\"0cfe2bfe\">（0）固有对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</span></h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #222222;\">固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“</span><span class=\"lake-fontsize-12\"><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">类</span></strong></span><span class=\"lake-fontsize-12\" style=\"color: #222222;\">”其实就是固有对象的一种。</span></p></blockquote><h4 id=\"6d4a04a5\">（1）原生对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</span></h4><p><strong>原生的对象有：</strong></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1553847843535-34b058d8-e34f-4ed8-9995-7aa56263e437.png%22%2C%22originWidth%22%3A988%2C%22originHeight%22%3A375%2C%22name%22%3A%226cb1df319bbc7c7f948acfdb9ffd99d0.png%22%2C%22size%22%3A110828%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A720%2C%22height%22%3A273%7D\"></card></p><p><br /></p><p>在使用这些对象的时候，可以通过 <strong><code>New</code></strong>  关键字创建新对象。</p><h5 id=\"99e0367e\">用对象来模拟函数与构造器：函数对象与构造器对象</h5><blockquote><p>这类对象具有私有字段 [<strong>[call]] 和 </strong><strong>[[construct]]</strong>，其中 </p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换</span></li><li>任何对象只需要实现 <strong>[[call]]</strong>，它就是一个<strong>函数对象</strong>，可以作为函数去调用</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">而如果它能实现 </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]]</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，它就是一个</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">构造器对象</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，可以作为构造器被调用。</span></li></ul></blockquote><p><br /></p><h4 id=\"0c56e77d\">函数对象调用与构造器调用</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20f()%7B%5Cn%20%20%20%20return%201%3B%5Cn%7D%5Cnlet%20v%20%3D%20f()%3B%20%2F%2F%20%E6%8A%8A%20f%20%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%5Cnlet%20o%20%3D%20new%20f()%3B%20%2F%2F%20%E6%8A%8A%20f%20%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%5Cn%22%2C%22id%22%3A%22hyxlj%22%7D\"></card><p><br /></p><p>我们大致的可以理解<span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]] </span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">的执行过程为</span></p><ul><li>以 Object.protoype 为原型创建一个新对象；</li><li>以新对象为 this，执行函数的 [[call]]；</li><li>如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li><li><strong>一定程度上，new创造的对象及属性，构造器之外是无法访问的，在一定程度上可以实现“私有”</strong></li></ul><p><br /></p><p><strong><span>对于有 </span></strong><strong><code>JS</code></strong><strong><span> 解析引擎的地方，只要字段正常。宿主对象及内置对象也可以模仿函数对象及构造器对象。</span></strong></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%5Cnlet%20time%20%3D%20new%20Date%3B%5Cn%2F%2F%E6%88%96%E8%80%85%5Cnlet%20time%20%3D%20Date()%3B%5Cn%2F%2F%20%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Image%E5%AF%B9%E8%B1%A1%5Cnlet%20img%20%3D%20new%20Image%3B%20%2F%2F%20%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AAimg%20Dom%E5%AF%B9%E8%B1%A1%5Cnlet%20img%20%3D%20Image()%20%2F%2F%E4%BC%9A%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%22%2C%22id%22%3A%224TY2S%22%7D\"></card><p><br /></p><h4 id=\"1256caf1\"><span style=\"color: #F5222D;\">*</span><span style=\"color: #F5222D;\">注意：</span><span style=\"color: #FFFFFF;\">  </span><span style=\"color: #FFFFFF; background-color: #003A8C;\">   ES6语法创建的函数，仅仅是函数，是不能作为构造器使用的   </span></h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22new%20(date%3D%3E%7B%7D)%20%2F%2F%20error%22%2C%22id%22%3A%22oKAPT%22%7D\"></card><p><br /></p><h4 id=\"73bf6b4f\">（2）普通对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</span></h4><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">例：</span></strong></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20Child%20%3D%20()%7B%7D%3B%5Cnlet%20childItem%20%3D%20new%20Child%22%2C%22id%22%3A%22fZxf9%22%7D\"></card><h3 id=\"0d98c747\">其他</h3><blockquote><p>除了上述的对象，有一些对象跟正常的对象有很大的区别，</p><p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同</p></blockquote><p><br /></p><ul><li><strong><code>Array</code></strong> ：<strong><code>Array</code></strong>  的 <strong><code>length</code></strong>  属性根据最大的下标自动发生变化。</li><li><strong><code>Object.prototype</code></strong> ：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li><strong><code>String</code></strong> ：为了支持下标运算，<strong><code>String</code></strong>  的正整数属性访问会去字符串里查找。</li><li><strong><code>Arguments</code></strong> ：<strong><code>arguments</code></strong>  的非负整数型下标属性跟对应的变量联动。</li><li>模块的 <strong><code>namespace</code></strong>  对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li><strong><code>bind</code></strong>  后的 <strong><code>function</code></strong> ：跟原来的函数相关联。</li></ul><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T02:01:08.000Z",
    "deleted_at": null,
    "created_at": "2019-03-29T06:16:46.000Z",
    "updated_at": "2019-04-28T02:01:08.000Z",
    "published_at": "2019-04-28T02:01:08.000Z",
    "first_published_at": "2019-03-29T09:28:22.000Z",
    "word_count": 1068,
    "cover": null,
    "description": "tags: [JavaScript对象类型]categories: 重学前端系列笔记宿主对象: 由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。 JavaScript  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器提供了 location  ...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1437597,
    "slug": "rfa6hf",
    "title": "2. 重新熟悉 javascript 对象",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [JavaScript对象]\n\ncategories: 重学前端系列笔记\n\n---\n<a name=\"WbPMO\"></a>\n### 前言\nJavaScript 是面向对象还是基于对象？\n\n要想弄懂这个，就得搞清楚，什么是面向对象？\n<a name=\"78ad2473\"></a>\n#### 什么是对象？\n\n- 之前有说过，对象是一切有形无形物体的总称。\n- 一切的编程语言最开始都是基于人类思想思维演变而来的，在人类思维中\n> 对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。\n> 在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。\n\n\n**这样可以总结出以下的对象特征**\n\n1. 一个可以触摸或者可以看见的东西\n1. 人的智力可以理解的东西\n1. 可以指导思考或行动（进行想象或施加动作）的东西\n\n<a name=\"24743cc9\"></a>\n#### 怎么描述对象\n以上的总结来自  Grady Booch 的**《面向对象程序分析与设计》**根据上面的总结，由此可以得出两种描述的方式：\n\n- 一种就是使用类的方式，描述一类事物。然后一个个的挂载到描述的类上，挂载的事物可以继承原定的类的属性及方法，同时也可以有自己特定的方法及属性。使用这种的有，C/C++/JAVA/汇编\n> **eg：**还是拿水果举例，水果是一些事物总称，公共特点就是能吃，好吃。可以补充营养。。。。，梨子，苹果都是属于水果，那么可以归类于水果这个类上，但是每种水果有自己的一些特性。\n\n\n```javascript\n// 创建一个水果的类\nclass Fruit {\n  // 构造器\n  constructor(color,type) {\n      this.color = color;\n      this.type = type ;\n  },\n  // 作用：营养\n\taction:nutrition,\n  // 使用方法：吃\n  instructions:eat\n};\n// 描述一个苹果\nclass apple extends Fruit {\n  constructor(color, type) {\n \t\t super(color, type);\n\t},\n   // 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n   // 颜色:暗红\n   color: DarkRed,\n   // 特点:脆\n   feature: brittle,\n}\n```\n\n     \n- 还有一种就是原型的方式。简略的描述一个事物，之后可以慢慢的对他进行丰满的描述，这些之后丰满的描述都是挂载在最原始描述的原型上。\n\n```javascript\n// 创建一个原始对象\nlet Apple = (){\n\t// 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n};\n// 给苹果这个对象添加个吃的方法。\nApple.prototype.eat = function () {\n  console.log(\"我要吧这个苹果吃完\")\n};\n```\n\n> 但是在创造 **`JavaScript`**`JavaScript`**`Java`**`new`**`this`**`Java`** 。\n\n\n<a name=\"1022a402\"></a>\n#### JavaScript 的对象特征\n从 Grandy Booch《面向对象分析与设计》可以总结出所有的语言对象应该都具有以下特征\n\n- 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。\n- 对象有状态：对象具有状态，同一对象可能处于不同状态之下。\n- 对象具有行为：即对象的状态，可能因为它的行为产生变迁。\n\n从第一个特征来看，**`JavaScript`**  中的对象。即使是具有相同属性的，也不是相同的\n\n```javascript\n let a = {\n   title: \"我要吃素\",\n };\nlet b = {\n    title: \"我要吃素\",\n};\nconsole.log(b === a) // 结果：false\n```\n这个为啥是 **`false`**  呢，学过 **`JavaScript`**  的都知道**堆**和**栈**的存在，（~~堆栈思想应该也是窃取其他语言的吧，小声比比~~）。简单数据类型存在**堆**中，复杂数据类型存在**栈**中，如果是**复杂数据浅拷贝**的话，一般是将**引用地址存在堆上**\n\n第二个特征和第三个特征来看，在 **`JavaScript`** 中，就抽象成了属性，不管是普通的属性还是函数，都是属于JavaScript的属性这个类别。\n\n```javascript\nlet test = { \n\tcode: 1,\n  fun () {\n\t   console.log(this.d);\n  }\n}\n```\n上述代码中，code 和 fun 都是属于普通的属性。<br />**在实现了对象基本特征的基础上，**`**JavaScript**` ** 中对象独有的特色是：对象具有高度的动态性，这是因为 **`**JavaScript**` ** 赋予了使用者在运行时为对象添改状态和行为的能力。**<br />**\n<a name=\"74dd9583\"></a>\n#### JavaScript 对象的属性类别\n<a name=\"f3142db4\"></a>\n##### （0）数据属性\n\n- **value：就是属性的值。**\n- **writable：**决定属性能否被赋值。\n- **enumerable：**决定 for in 能否枚举该属性。\n- **configurable：**决定该属性能否被删除或者改变特征值。\n<a name=\"fc50eb8e\"></a>\n##### （1）访问器属性（getter/setter）\n\n- **getter：**函数或 undefined，在取属性值时被调用。\n- **setter：**函数或 undefined，在设置属性值时被调用。\n- **enumerable：**决定 for in 能否枚举该属性。\n- **configurable：**决定该属性能否被删除或者改变特征值。\n\n     访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。<br />**那我们怎么查看一个对象的数据属性呢？**\n\n查看属性 **`Object.getOwnPropertyDescriptor`** \n```javascript\n    let test = { a: 1 };\n    test.b = 2;\n    //a 和 b 皆为数据属性\n    console.log( Object.getOwnPropertyDescriptor(test,\"a\") ) // {value: 1, writable: true, enumerable: true, configurable: true}\n    console.log( Object.getOwnPropertyDescriptor(test,\"b\") ) // {value: 2, writable: true, enumerable: true, configurable: true}\n```\n\n改变属性：**`Object.defineProperty`** \n\n```javascript\nlet test = { a: 1 };\n// 改变数据属性\nObject.defineProperty(test,\"a\",{value: 1, writable: false, enumerable: false, configurable: false });\n// 获取改变之后的数据属性\nconsole.log( Object.getOwnPropertyDescriptor(test,\"b\") ) // {value: 1, writable: false, enumerable: false, configurable: false }}\n```\n\n<a name=\"bafbe962\"></a>\n##### 当然在创建对象的时候，也可以使用 get 和 set 关键字来创建访问器属性\n\n```javascript\n    let test = { \n      get a() { \n        return 1 \n      } \n    };\n    console.log(test.a); // 1\n```\n\n",
    "body_draft": "",
    "body_html": "<p><span style=\"background-color: \"rgba(0, 0, 0, 0)\";\">tags: [JavaScript对象]</span><br /></p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"WbPMO\">前言</h3><p><span style=\"background-color: transparent;\">JavaScript 是面向对象还是基于对象？</span><br /></p><p>要想弄懂这个，就得搞清楚，什么是面向对象？</p><h4 id=\"78ad2473\">什么是对象？</h4><ul><li>之前有说过，对象是一切有形无形物体的总称。</li><li>一切的编程语言最开始都是基于人类思想思维演变而来的，在人类思维中</li></ul><blockquote><p><span class=\"lake-fontsize-11\">对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。</span></p><p><span class=\"lake-fontsize-11\" style=\"color: #222222;\">在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。</span></p></blockquote><p><br /></p><p><strong>这样可以总结出以下的对象特征</strong></p><ol start=\"1\"><li>一个可以触摸或者可以看见的东西</li><li>人的智力可以理解的东西</li><li>可以指导思考或行动（进行想象或施加动作）的东西</li></ol><p><br /></p><h4 id=\"24743cc9\">怎么描述对象</h4><p>以上的总结来自  Grady Booch 的<strong>《面向对象程序分析与设计》</strong><span>根据上面的总结，由此可以得出两种描述的方式：</span></p><ul><li>一种就是使用类的方式，描述一类事物。然后一个个的挂载到描述的类上，挂载的事物可以继承原定的类的属性及方法，同时也可以有自己特定的方法及属性。使用这种的有，C/C++/JAVA/汇编</li></ul><blockquote><p><strong>eg：</strong>还是拿水果举例，水果是一些事物总称，公共特点就是能吃，好吃。可以补充营养。。。。，梨子，苹果都是属于水果，那么可以归类于水果这个类上，但是每种水果有自己的一些特性。</p></blockquote><p><br /></p><pre data-lang=\"javascript\"><code>// 创建一个水果的类\nclass Fruit {\n  // 构造器\n  constructor(color,type) {\n      this.color = color;\n      this.type = type ;\n  },\n  // 作用：营养\n\taction:nutrition,\n  // 使用方法：吃\n  instructions:eat\n};\n// 描述一个苹果\nclass apple extends Fruit {\n  constructor(color, type) {\n \t\t super(color, type);\n\t},\n   // 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n   // 颜色:暗红\n   color: DarkRed,\n   // 特点:脆\n   feature: brittle,\n}</code></pre><ul><p>     </p><li>还有一种就是原型的方式。简略的描述一个事物，之后可以慢慢的对他进行丰满的描述，这些之后丰满的描述都是挂载在最原始描述的原型上。</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>// 创建一个原始对象\nlet Apple = (){\n\t// 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n};\n// 给苹果这个对象添加个吃的方法。\nApple.prototype.eat = function () {\n  console.log(&quot;我要吧这个苹果吃完&quot;)\n};</code></pre><p><br /></p><blockquote><p>但是在创造 <strong><code>JavaScript</code></strong> 之初，<strong><code>JavaScript</code></strong> 之父的公司要求模仿 <strong><code>Java</code></strong> ，于是在原本的原型基础上，引入 <strong><code>new</code></strong> 关键字，以及 <strong><code>this</code></strong>  的概念特性。使之更像 <strong><code>Java</code></strong> 。</p></blockquote><p><br /></p><h4 id=\"1022a402\">JavaScript 的对象特征</h4><p>从 Grandy Booch《面向对象分析与设计》可以总结出所有的语言对象应该都具有以下特征</p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象有状态：对象具有状态，同一对象可能处于不同状态之下。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有行为：即对象的状态，可能因为它的行为产生变迁。</span></li></ul><p><br /></p><p>从第一个特征来看，<strong><code>JavaScript</code></strong>  中的对象。即使是具有相同属性的，也不是相同的</p><p><br /></p><pre data-lang=\"javascript\"><code> let a = {\n   title: &quot;我要吃素&quot;,\n };\nlet b = {\n    title: &quot;我要吃素&quot;,\n};\nconsole.log(b === a) // 结果：false</code></pre><p>这个为啥是 <strong><code>false</code></strong>  呢，学过 <strong><code>JavaScript</code></strong>  的都知道<strong>堆</strong>和<strong>栈</strong>的存在，（<del>堆栈思想应该也是窃取其他语言的吧，小声比比</del><span>）。</span>简单数据类型存在<strong>堆</strong>中，复杂数据类型存在<strong>栈</strong>中，如果是<strong>复杂数据浅拷贝</strong>的话，一般是将<strong>引用地址存在堆上</strong></p><p><br /></p><p>第二个特征和第三个特征来看，在 <strong><code>JavaScript</code></strong> 中，就抽象成了属性，不管是普通的属性还是函数，都是属于JavaScript的属性这个类别。</p><p><br /></p><pre data-lang=\"javascript\"><code>let test = { \n\tcode: 1,\n  fun () {\n\t   console.log(this.d);\n  }\n}</code></pre><p>上述代码中，code 和 fun 都是属于普通的属性。</p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">在实现了对象基本特征的基础上，</span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 中对象独有的特色是：对象具有高度的动态性，这是因为 </span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 赋予了使用者在运行时为对象添改状态和行为的能力。</span></strong></p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span></strong></p><h4 id=\"74dd9583\">JavaScript 对象的属性类别</h4><h5 id=\"f3142db4\">（0）数据属性</h5><ul><li><strong>value：就是属性的值。</strong></li><li><strong>writable：</strong>决定属性能否被赋值。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><h5 id=\"fc50eb8e\">（1）访问器属性（getter/setter）</h5><ul><li><strong>getter：</strong>函数或 undefined，在取属性值时被调用。</li><li><strong>setter：</strong>函数或 undefined，在设置属性值时被调用。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><p>     访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><p><strong>那我们怎么查看一个对象的数据属性呢？</strong></p><p><br /></p><p>查看属性 <strong><code>Object.getOwnPropertyDescriptor</code></strong> </p><pre data-lang=\"javascript\"><code>    let test = { a: 1 };\n    test.b = 2;\n    //a 和 b 皆为数据属性\n    console.log( Object.getOwnPropertyDescriptor(test,&quot;a&quot;) ) // {value: 1, writable: true, enumerable: true, configurable: true}\n    console.log( Object.getOwnPropertyDescriptor(test,&quot;b&quot;) ) // {value: 2, writable: true, enumerable: true, configurable: true}</code></pre><p><br /></p><p>改变属性：<strong><code>Object.defineProperty</code></strong> </p><p><br /></p><pre data-lang=\"javascript\"><code>let test = { a: 1 };\n// 改变数据属性\nObject.defineProperty(test,&quot;a&quot;,{value: 1, writable: false, enumerable: false, configurable: false });\n// 获取改变之后的数据属性\nconsole.log( Object.getOwnPropertyDescriptor(test,&quot;b&quot;) ) // {value: 1, writable: false, enumerable: false, configurable: false }}</code></pre><p><br /></p><h5 id=\"bafbe962\">当然在创建对象的时候，也可以使用 get 和 set 关键字来创建访问器属性</h5><p><br /></p><pre data-lang=\"javascript\"><code>    let test = { \n      get a() { \n        return 1 \n      } \n    };\n    console.log(test.a); // 1</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><p><span style=\"background-color: rgba(0, 0, 0, 0);\">tags: [JavaScript对象]</span><br /></p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22HrNfP%22%7D\"></card><h3 id=\"WbPMO\">前言<cursor /></h3><p><span style=\"background-color: transparent;\">JavaScript 是面向对象还是基于对象？</span><br /></p><p>要想弄懂这个，就得搞清楚，什么是面向对象？</p><h4 id=\"78ad2473\">什么是对象？</h4><ul><li>之前有说过，对象是一切有形无形物体的总称。</li><li>一切的编程语言最开始都是基于人类思想思维演变而来的，在人类思维中</li></ul><blockquote><p><span class=\"lake-fontsize-11\">对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。</span></p><p><span class=\"lake-fontsize-11\" style=\"color: #222222;\">在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。</span></p></blockquote><p><br /></p><p><strong>这样可以总结出以下的对象特征</strong></p><ol start=\"1\"><li>一个可以触摸或者可以看见的东西</li><li>人的智力可以理解的东西</li><li>可以指导思考或行动（进行想象或施加动作）的东西</li></ol><p><br /></p><h4 id=\"24743cc9\">怎么描述对象</h4><p>以上的总结来自  Grady Booch 的<strong>《面向对象程序分析与设计》</strong><span>根据上面的总结，由此可以得出两种描述的方式：</span></p><ul><li>一种就是使用类的方式，描述一类事物。然后一个个的挂载到描述的类上，挂载的事物可以继承原定的类的属性及方法，同时也可以有自己特定的方法及属性。使用这种的有，C/C++/JAVA/汇编</li></ul><blockquote><p><strong>eg：</strong>还是拿水果举例，水果是一些事物总称，公共特点就是能吃，好吃。可以补充营养。。。。，梨子，苹果都是属于水果，那么可以归类于水果这个类上，但是每种水果有自己的一些特性。</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B0%B4%E6%9E%9C%E7%9A%84%E7%B1%BB%5Cnclass%20Fruit%20%7B%5Cn%20%20%2F%2F%20%E6%9E%84%E9%80%A0%E5%99%A8%5Cn%20%20constructor(color%2Ctype)%20%7B%5Cn%20%20%20%20%20%20this.color%20%3D%20color%3B%5Cn%20%20%20%20%20%20this.type%20%3D%20type%20%3B%5Cn%20%20%7D%2C%5Cn%20%20%2F%2F%20%E4%BD%9C%E7%94%A8%EF%BC%9A%E8%90%A5%E5%85%BB%5Cn%5Ctaction%3Anutrition%2C%5Cn%20%20%2F%2F%20%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%90%83%5Cn%20%20instructions%3Aeat%5Cn%7D%3B%5Cn%2F%2F%20%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E8%8B%B9%E6%9E%9C%5Cnclass%20apple%20extends%20Fruit%20%7B%5Cn%20%20constructor(color%2C%20type)%20%7B%5Cn%20%5Ct%5Ct%20super(color%2C%20type)%3B%5Cn%5Ct%7D%2C%5Cn%20%20%20%2F%2F%20%E5%BD%A2%E7%8A%B6%3A%20%E6%A4%AD%E5%9C%86%5Cn%5Ct%20shape%3Aoval%2C%5Cn%20%20%2F%2F%20%E7%A7%8D%E7%B1%BB%3A%20%E8%8B%B9%E6%9E%9C%5Cn%20%20%20type%3Aapple%2C%5Cn%20%20%20%2F%2F%20%E9%A2%9C%E8%89%B2%3A%E6%9A%97%E7%BA%A2%5Cn%20%20%20color%3A%20DarkRed%2C%5Cn%20%20%20%2F%2F%20%E7%89%B9%E7%82%B9%3A%E8%84%86%5Cn%20%20%20feature%3A%20brittle%2C%5Cn%7D%22%2C%22id%22%3A%22eEEe6%22%7D\"></card><ul><p>     </p><li>还有一种就是原型的方式。简略的描述一个事物，之后可以慢慢的对他进行丰满的描述，这些之后丰满的描述都是挂载在最原始描述的原型上。</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%A7%8B%E5%AF%B9%E8%B1%A1%5Cnlet%20Apple%20%3D%20()%7B%5Cn%5Ct%2F%2F%20%E5%BD%A2%E7%8A%B6%3A%20%E6%A4%AD%E5%9C%86%5Cn%5Ct%20shape%3Aoval%2C%5Cn%20%20%2F%2F%20%E7%A7%8D%E7%B1%BB%3A%20%E8%8B%B9%E6%9E%9C%5Cn%20%20%20type%3Aapple%2C%5Cn%7D%3B%5Cn%2F%2F%20%E7%BB%99%E8%8B%B9%E6%9E%9C%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E4%B8%AA%E5%90%83%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%5CnApple.prototype.eat%20%3D%20function%20()%20%7B%5Cn%20%20console.log(%5C%22%E6%88%91%E8%A6%81%E5%90%A7%E8%BF%99%E4%B8%AA%E8%8B%B9%E6%9E%9C%E5%90%83%E5%AE%8C%5C%22)%5Cn%7D%3B%22%2C%22id%22%3A%22MM6KQ%22%7D\"></card><p><br /></p><blockquote><p>但是在创造 <strong><code>JavaScript</code></strong> 之初，<strong><code>JavaScript</code></strong> 之父的公司要求模仿 <strong><code>Java</code></strong> ，于是在原本的原型基础上，引入 <strong><code>new</code></strong> 关键字，以及 <strong><code>this</code></strong>  的概念特性。使之更像 <strong><code>Java</code></strong> 。</p></blockquote><p><br /></p><h4 id=\"1022a402\">JavaScript 的对象特征</h4><p>从 Grandy Booch《面向对象分析与设计》可以总结出所有的语言对象应该都具有以下特征</p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象有状态：对象具有状态，同一对象可能处于不同状态之下。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有行为：即对象的状态，可能因为它的行为产生变迁。</span></li></ul><p><br /></p><p>从第一个特征来看，<strong><code>JavaScript</code></strong>  中的对象。即使是具有相同属性的，也不是相同的</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20let%20a%20%3D%20%7B%5Cn%20%20%20title%3A%20%5C%22%E6%88%91%E8%A6%81%E5%90%83%E7%B4%A0%5C%22%2C%5Cn%20%7D%3B%5Cnlet%20b%20%3D%20%7B%5Cn%20%20%20%20title%3A%20%5C%22%E6%88%91%E8%A6%81%E5%90%83%E7%B4%A0%5C%22%2C%5Cn%7D%3B%5Cnconsole.log(b%20%3D%3D%3D%20a)%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9Afalse%22%2C%22id%22%3A%22gJz0j%22%7D\"></card><p>这个为啥是 <strong><code>false</code></strong>  呢，学过 <strong><code>JavaScript</code></strong>  的都知道<strong>堆</strong>和<strong>栈</strong>的存在，（<del>堆栈思想应该也是窃取其他语言的吧，小声比比</del><span>）。</span>简单数据类型存在<strong>堆</strong>中，复杂数据类型存在<strong>栈</strong>中，如果是<strong>复杂数据浅拷贝</strong>的话，一般是将<strong>引用地址存在堆上</strong></p><p><br /></p><p>第二个特征和第三个特征来看，在 <strong><code>JavaScript</code></strong> 中，就抽象成了属性，不管是普通的属性还是函数，都是属于JavaScript的属性这个类别。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20test%20%3D%20%7B%20%5Cn%5Ctcode%3A%201%2C%5Cn%20%20fun%20()%20%7B%5Cn%5Ct%20%20%20console.log(this.d)%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22id%22%3A%22PsqPU%22%7D\"></card><p>上述代码中，code 和 fun 都是属于普通的属性。</p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">在实现了对象基本特征的基础上，</span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 中对象独有的特色是：对象具有高度的动态性，这是因为 </span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 赋予了使用者在运行时为对象添改状态和行为的能力。</span></strong></p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span></strong></p><h4 id=\"74dd9583\">JavaScript 对象的属性类别</h4><h5 id=\"f3142db4\">（0）数据属性</h5><ul><li><strong>value：就是属性的值。</strong></li><li><strong>writable：</strong>决定属性能否被赋值。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><h5 id=\"fc50eb8e\">（1）访问器属性（getter/setter）</h5><ul><li><strong>getter：</strong>函数或 undefined，在取属性值时被调用。</li><li><strong>setter：</strong>函数或 undefined，在设置属性值时被调用。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><p>     访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><p><strong>那我们怎么查看一个对象的数据属性呢？</strong></p><p><br /></p><p>查看属性 <strong><code>Object.getOwnPropertyDescriptor</code></strong> </p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20%20%20%20let%20test%20%3D%20%7B%20a%3A%201%20%7D%3B%5Cn%20%20%20%20test.b%20%3D%202%3B%5Cn%20%20%20%20%2F%2Fa%20%E5%92%8C%20b%20%E7%9A%86%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%5Cn%20%20%20%20console.log(%20Object.getOwnPropertyDescriptor(test%2C%5C%22a%5C%22)%20)%20%2F%2F%20%7Bvalue%3A%201%2C%20writable%3A%20true%2C%20enumerable%3A%20true%2C%20configurable%3A%20true%7D%5Cn%20%20%20%20console.log(%20Object.getOwnPropertyDescriptor(test%2C%5C%22b%5C%22)%20)%20%2F%2F%20%7Bvalue%3A%202%2C%20writable%3A%20true%2C%20enumerable%3A%20true%2C%20configurable%3A%20true%7D%22%2C%22id%22%3A%22o9Xau%22%7D\"></card><p><br /></p><p>改变属性：<strong><code>Object.defineProperty</code></strong> </p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20test%20%3D%20%7B%20a%3A%201%20%7D%3B%5Cn%2F%2F%20%E6%94%B9%E5%8F%98%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%5CnObject.defineProperty(test%2C%5C%22a%5C%22%2C%7Bvalue%3A%201%2C%20writable%3A%20false%2C%20enumerable%3A%20false%2C%20configurable%3A%20false%20%7D)%3B%5Cn%2F%2F%20%E8%8E%B7%E5%8F%96%E6%94%B9%E5%8F%98%E4%B9%8B%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%5Cnconsole.log(%20Object.getOwnPropertyDescriptor(test%2C%5C%22b%5C%22)%20)%20%2F%2F%20%7Bvalue%3A%201%2C%20writable%3A%20false%2C%20enumerable%3A%20false%2C%20configurable%3A%20false%20%7D%7D%22%2C%22id%22%3A%22oxUDt%22%7D\"></card><p><br /></p><h5 id=\"bafbe962\">当然在创建对象的时候，也可以使用 get 和 set 关键字来创建访问器属性</h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20%20%20%20let%20test%20%3D%20%7B%20%5Cn%20%20%20%20%20%20get%20a()%20%7B%20%5Cn%20%20%20%20%20%20%20%20return%201%20%5Cn%20%20%20%20%20%20%7D%20%5Cn%20%20%20%20%7D%3B%5Cn%20%20%20%20console.log(test.a)%3B%20%2F%2F%201%22%2C%22id%22%3A%22mfeB6%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T02:01:27.000Z",
    "deleted_at": null,
    "created_at": "2019-03-27T15:57:18.000Z",
    "updated_at": "2019-04-28T02:01:27.000Z",
    "published_at": "2019-04-28T02:01:27.000Z",
    "first_published_at": "2019-03-27T15:58:11.000Z",
    "word_count": 1467,
    "cover": "",
    "description": "tags: [JavaScript对象]categories: 重学前端系列笔记前言JavaScript 是面向对象还是基于对象？要想弄懂这个，就得搞清楚，什么是面向对象？什么是对象？之前有说过，对象是一切有形无形物体的总称。一切的编程语言最开始都是基于人类思想思维演变而来的，在人类思维中对象...",
    "custom_description": "",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1432513,
    "slug": "wuxin",
    "title": "1. 重新认识 JavaScript 类型",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T02:01:37.614Z",
      "updated_at": "2019-04-28T02:01:37.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [JavaScript数据类型]<br />categories: 重学前端系列笔记\n\n---\n<a name=\"X51yG\"></a>\n### 前言\n最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。\n<a name=\"49448199\"></a>\n### 补充*\n\n- 变量声明跟赋值，是两个概念。\n- **`let a`** 是属于变量声明阶段，这个阶段所有的变量的值都是 **`undefined`** 。**`a = 12`**`JS`** 解析引擎。这个变量是什么类型以及它的值多少。\n- 当 **`JavaScript`** 执行的时候，如果遇到致命错误便会停止往下执行。\n```javascript\n//bad声明方式\nvar a=b=2;\n// good\nvar a=12,b=23;\n// 但是更期望使用let声明，不用变量提升\nlet a = 12;\n```\n<a name=\"08da595a\"></a>\n## 怎么准确的判断数据类型\n\n```javascript\nlet str = \"你是谁，我是战无不胜的孙悟空\"\nObject.prototype.toString.call(str) // [object,String];\nlet arr = [1,4,56];\nObject.prototype.toString.call(arr) // [object,Array];\n```\n\n<a name=\"2746c81b\"></a>\n### JavaScript现有常见类型\n\n- Null\n- Undefined\n- String\n- Boolean\n- Number\n- Symbol\n- Object\n\n现在JavaScript常见类型是这么多，其中只有 `Symbol`  是 `ES6` 新提出来的，其余都是 `ES6` 之前早就熟悉的类\n<a name=\"c23f5abf\"></a>\n#### （0）Null\n\n- 这个类型表示：**定义了但是为空**\n- Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。\n<a name=\"357bda8a\"></a>\n#### （1）Undefined\n\n- 这个类型表示：**变量定义了但是未赋值**\n- 任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值\n- 它同样的表示一个变量的值，它并非一个关键词，这是 `JavaScript`  语言公认的设计失误之一，所以，所以，我们为了避免无意中被篡改，我建议使用 `void 0` 来来获取 `Nudefined` 值。\n- 它与 `Null` 的不同就是，`Null` 是 `JavaScript` 的关键字，在开发中可以自由的获取 `Null` 类型的变量\n<a name=\"f9369aa0\"></a>\n#### （2）Boolean\n\n- 这个类型表示：**逻辑上的真和假**\n- 它有两个值：`true` 和 `false` \n- 它属于 `JavaScript` 中的内置对象，可以通过 `new` 关键词创造实例对象\n<a name=\"ece22d59\"></a>\n#### （3）String\n\n- 这个类型表示：表示文本数据\n- 这个类型具有长度单位的，最大的长度 **`2^53-1`** ，\n- 这个 `String` 并非文本意义的字符串，而是字符串的 `UTF16` 编码，我们日常操作字符使用的 `length` `charAt` 都是针对 `UTF16` 编码\n- 字符串的最大长度是受经过 `UTF16` 编码之后的字符长度限制\n<a name=\"932cf868\"></a>\n#### 补充编码知识\n> Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。\n\n<a name=\"a887f81c\"></a>\n#### （4）Number\n\n- 这个类型表示：通常意义的数字类型\n- 它是 `JavaScript` 的内置对象，可以通过 `new` 关键字创造实例\n- 它类型有 `**2^64-2^53+3**` 个值\n- 在为了避免计算的时候出错，借鉴生活中的数学，引入了 `NaN` (这个可以用来检测是否为数字类型)、Infinity(正无穷大)、-Infinity(负无穷大)\n- 在加减法中 **-0**+0 **没有很大的区别，但是在除法中就会很大的区别了\n\n```javascript\nconsole.log(.00001 / -0); //结果：-Infinity\nconsole.log(.00000000001 / 0); //结果: Infinity\n```\n\n- 根据双精度浮点数的定义，Number 类型中有效的整数范围是-0x1fffffffffffff 至0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。所以在非整数面前是无法使用 `==` 或者 `===` 进行比较的\n\n```javascript\nconsole.log( .1 + .2 == .3 ); //结果：false;\nconsole.log(.1 + .2);  // 结果：0.30000000000000004\n```\n\n- 正确的比较两边数值是否相等，应该比较左右两边差的绝对值是否小于最小精度\n\n```javascript\nconsole.log(Math.abs(.1 + .2 - .3) <=Number.EPSILON); // true\n```\n\n> **Number.EPSILON**ES6 **Number **的一个常量。\n> **Number.EPSILON** 实际上是 **JavaScript** 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。\n\n<a name=\"780b6ec0\"></a>\n#### （5）Object\n\n- 这个类型表示：**对象**，它是一切有形和无形物体的总称\n- 它是属性的集合，是 **`key-value`** 结构\n- **key : **可以是字符串类型。也可以是symbol类型\n- **value :**可以是字符串，可以是数值类型。也可以是对象类型\n<a name=\"c91ff6ed\"></a>\n#### （6）Symbol\n\n- 这个类型是 `**ES6**` 新增的一个类型。其实说实话，到现在还不太清楚这个类型的作用，以及用法\n- 它是一切非字符串的对象 key 的集合\n- Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等\n\n```javascript\n// 创建 Symbol 类型\nlet symbol = Symbol(\"其实，我是一个好人\");\nconsole.log(symbol)\n```\n\n- 这个类型还是有很多不懂，之后有了新收获，再过来更新吧\n<a name=\"f3c723ec\"></a>\n### 类型转换\n<a name=\"2f9540a5\"></a>\n#### （0）string → Number(字符串转成数值类型)\n\n- 常见都是借助 `JavaScript` 中的内置方法进行转换，例如 `**parseInt**`  `**parseFloat**` 都是将字符串转化成数值类型。但是  `**parseInt**` 是遇到非数值就停下，而** ** `**parseFloat**` 遇到不属于数字行列才会停，\n- `**parseInt**` `**parseFloat**`  转化的字符串，如果第一个字符不是数字的话，就会返回 **NaN**\n- 除了上述的两种，还有 **`JavaScript`**Math  **NaN **\n- 还有一种就是利用装箱操作，利用 **`Number`**NaN**\n- 如果字符串的字符都是数字。那么可以使用四则运算，也可以进行隐士转换\n\n```javascript\n console.log(parseInt(\"6340.54\")); // 结果:6340\n console.log(parseFloat(\"4.648781655wr我是1\"));结果:4.648781655\n console.log(Number(\"2.2.22\")); // 结果:NaN\n console.log(Number(\"5464646\")) // 结果: 5464646\n```\n\n<a name=\"6c2395fb\"></a>\n#### （1）Number → string (数字转化成字符串)\n\n- 字符串拼接\n\n```javascript\nlet str = 121343454545;\nstr = str+ \"\";\nconsole.log(typeof(str)) // 结果：string\n```\n\n- 装箱转换\n```javascript\nlet str = 13243545646;\nconsole.log( typeof( String(str) ) ) // 结果：string \n```\n\n<a name=\"0e1aa6d1\"></a>\n#### （2）装箱操作转换\n\n- 在 `**JavaScript**` 中，类型之间存在装箱转换操作\n\n```javascript\n let str = 1323;\n console.log(typeof (String(str))); // string\n console.log(typeof (Symbol(str))) // symbol\n```\n\n<a name=\"f0dde815\"></a>\n### 其他的数据类型\n\n- **`List`**  和  **`Record`** ： 用于描述函数传参过程。\n- `**Set**` ：主要用于解释字符集等。\n- **`Completion Record`** ：用于描述异常、跳出等语句执行过程。\n- **`Reference`** ：用于描述对象属性访问、delete 等。\n- **`Property Descriptor`** ：用于描述对象的属性。\n- **`Lexical Environment`**  和  **`Environment Record`** ：用于描述变量和作用域。\n- **`Data Block`** ：用于描述二进制数据。\n<a name=\"7aa17298\"></a>\n### 程序 = 算法 + 数据结构\n",
    "body_draft": "",
    "body_html": "<p>tags: [JavaScript数据类型]</p><p>categories: 重学前端系列笔记</p><hr /><h3 id=\"X51yG\"><span style=\"background-color: transparent;\">前言</span></h3><p>最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。</p><h3 id=\"49448199\">补充<span style=\"color: #F5222D;\">*</span></h3><ul><li><span class=\"lake-fontsize-12\">变量声明跟赋值，是两个概念。</span></li><li><span class=\"lake-fontsize-12\"><strong><code>let a</code></strong> 是属于变量声明阶段，这个阶段所有的变量的值都是 </span><strong><code><span class=\"lake-fontsize-12\">undefined</span></code></strong> <span class=\"lake-fontsize-12\">。</span><strong><code><span class=\"lake-fontsize-12\">a = 12</span></code></strong> 是赋值阶段，这个阶段是告诉 <strong><code>JS</code></strong> 解析引擎。这个变量是什么类型以及它的值多少。</li><li>当 <strong><code>JavaScript</code></strong> 执行的时候，如果遇到致命错误便会停止往下执行。</li></ul><pre data-lang=\"javascript\"><code>//bad声明方式\nvar a=b=2;\n// good\nvar a=12,b=23;\n// 但是更期望使用let声明，不用变量提升\nlet a = 12;</code></pre><h2 id=\"08da595a\">怎么准确的判断数据类型</h2><p><br /></p><pre data-lang=\"javascript\"><code>let str = &quot;你是谁，我是战无不胜的孙悟空&quot;\nObject.prototype.toString.call(str) // [object,String];\nlet arr = [1,4,56];\nObject.prototype.toString.call(arr) // [object,Array];</code></pre><p><br /></p><h3 id=\"2746c81b\">JavaScript现有常见类型</h3><ul><li>Null</li><li>Undefined</li><li>String</li><li>Boolean</li><li>Number</li><li>Symbol</li><li>Object</li></ul><p>现在JavaScript常见类型是这么多，其中只有 <code>Symbol</code>  是 <code>ES6</code> 新提出来的，其余都是 <code>ES6</code> 之前早就熟悉的类</p><h4 id=\"c23f5abf\">（0）Null</h4><ul><li>这个类型表示：<strong>定义了但是为空</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</span></li></ul><h4 id=\"357bda8a\">（1）Undefined</h4><ul><li>这个类型表示：<strong>变量定义了但是未赋值</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值</span></li><li>它同样的表示一个变量的值，它并非一个关键词，这是 <code>JavaScript</code>  语言公认的设计失误之一，所以，所以，我们为了避免无意中被篡改，我建议使用 <code>void 0</code> 来来获取 <code>Nudefined</code> 值。</li><li>它与 <code>Null</code> 的不同就是，<code>Null</code> 是 <code>JavaScript</code> 的关键字，在开发中可以自由的获取 <code>Null</code> 类型的变量</li></ul><h4 id=\"f9369aa0\">（2）Boolean</h4><ul><li>这个类型表示：<strong>逻辑上的真和假</strong></li><li>它有两个值：<code>true</code> 和 <code>false</code> </li><li>它属于 <code>JavaScript</code> 中的内置对象，可以通过 <code>new</code> 关键词创造实例对象</li></ul><h4 id=\"ece22d59\">（3）String</h4><ul><li>这个类型表示：表示文本数据</li><li>这个类型具有长度单位的，最大的长度 <strong><code>2^53-1</code></strong> ，</li><li>这个 <code>String</code> 并非文本意义的字符串，而是字符串的 <code>UTF16</code> 编码，我们日常操作字符使用的 <code>length</code> <code>charAt</code> 都是针对 <code>UTF16</code> 编码</li><li>字符串的最大长度是受经过 <code>UTF16</code> 编码之后的字符长度限制</li></ul><h4 id=\"932cf868\">补充编码知识</h4><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。</span></p></blockquote><h4 id=\"a887f81c\">（4）Number</h4><ul><li>这个类型表示：通常意义的数字类型</li><li>它是 <code>JavaScript</code> 的内置对象，可以通过 <code>new</code> 关键字创造实例</li><li>它类型有 <code><strong>2^64-2^53+3</strong></code> 个值</li><li>在为了避免计算的时候出错，借鉴生活中的数学，引入了 <code>NaN</code> (这个可以用来检测是否为数字类型)、Infinity(正无穷大)、-Infinity(负无穷大)</li><li>在加减法中 <strong>-0</strong>和<strong>+0 </strong>没有很大的区别，但是在除法中就会很大的区别了</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>console.log(.00001 / -0); //结果：-Infinity\nconsole.log(.00000000001 / 0); //结果: Infinity</code></pre><p><br /></p><ul><li>根据双精度浮点数的定义，Number 类型中有效的整数范围是-0x1fffffffffffff 至0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。所以在非整数面前是无法使用 <code>==</code> 或者 <code>===</code> 进行比较的</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>console.log( .1 + .2 == .3 ); //结果：false;\nconsole.log(.1 + .2);  // 结果：0.30000000000000004</code></pre><ul><li>正确的比较两边数值是否相等，应该比较左右两边差的绝对值是否小于最小精度</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>console.log(Math.abs(.1 + .2 - .3) &lt;=Number.EPSILON); // true</code></pre><p><br /></p><blockquote><p><strong><span>Number.EPSILON</span></strong> 它是 <strong>ES6 </strong>新出的一个挂载在 <strong>Number </strong>的一个常量。</p><p><strong><span>N</span></strong><strong><span>u</span></strong><strong>mber.EPSILON</strong><span> </span><span class=\"lake-fontsize-12\">实际上是 </span><strong><span class=\"lake-fontsize-12\" style=\"color: #333333;\">JavaScript</span></strong><span class=\"lake-fontsize-12\"> 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</span></p></blockquote><h4 id=\"780b6ec0\">（5）Object</h4><ul><li>这个类型表示：<strong>对象</strong>，它是一切有形和无形物体的总称</li><li>它是属性的集合，是 <strong><code>key-value</code></strong> 结构</li><li><strong>key : </strong>可以是字符串类型。也可以是symbol类型</li><li><strong>value :</strong>可以是字符串，可以是数值类型。也可以是对象类型</li></ul><h4 id=\"c91ff6ed\">（6）Symbol</h4><ul><li>这个类型是 <code><strong>ES6</strong></code> 新增的一个类型。其实说实话，到现在还不太清楚这个类型的作用，以及用法</li><li>它是一切非字符串的对象 key 的集合</li><li>Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>// 创建 Symbol 类型\nlet symbol = Symbol(&quot;其实，我是一个好人&quot;);\nconsole.log(symbol)</code></pre><p><br /></p><ul><li>这个类型还是有很多不懂，之后有了新收获，再过来更新吧</li></ul><h3 id=\"f3c723ec\">类型转换</h3><h4 id=\"2f9540a5\">（0）string → Number(<span>字符串转成数值类型</span>)</h4><ul><li>常见都是借助 <code>JavaScript</code> 中的内置方法进行转换，例如 <code><strong>parseInt</strong></code>  <code><strong>parseFloat</strong></code> 都是将字符串转化成数值类型。但是  <code><strong>parseInt</strong></code> 是遇到非数值就停下，而<strong> </strong> <code><strong>parseFloat</strong></code> 遇到不属于数字行列才会停，</li><li><code><strong>parseInt</strong></code> <code><strong>parseFloat</strong></code>  转化的字符串，如果第一个字符不是数字的话，就会返回 <strong>NaN</strong></li><li>除了上述的两种，还有 <strong><code>JavaScript</code></strong> 内置的 <strong>Math  </strong>方法也可以隐式的转化成数值，但是依然是如果第一个字符不是数值的话，就会返回 <strong>NaN </strong></li><li>还有一种就是利用装箱操作，利用 <strong><code>Number</code></strong> 进行转换，这个转换的好处就是，只要转换的字符不属于数值类型的，都会返回 <strong>NaN</strong></li><li>如果字符串的字符都是数字。那么可以使用四则运算，也可以进行隐士转换</li></ul><p><br /></p><pre data-lang=\"javascript\"><code> console.log(parseInt(&quot;6340.54&quot;)); // 结果:6340\n console.log(parseFloat(&quot;4.648781655wr我是1&quot;));结果:4.648781655\n console.log(Number(&quot;2.2.22&quot;)); // 结果:NaN\n console.log(Number(&quot;5464646&quot;)) // 结果: 5464646</code></pre><p><br /></p><h4 id=\"6c2395fb\">（1）Number → string (数字转化成字符串)</h4><ul><li>字符串拼接</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>let str = 121343454545;\nstr = str+ &quot;&quot;;\nconsole.log(typeof(str)) // 结果：string</code></pre><p><br /></p><ul><li>装箱转换</li></ul><pre data-lang=\"javascript\"><code>let str = 13243545646;\nconsole.log( typeof( String(str) ) ) // 结果：string </code></pre><p><br /></p><h4 id=\"0e1aa6d1\">（2）装箱操作转换</h4><ul><li>在 <code><strong>JavaScript</strong></code> 中，类型之间存在装箱转换操作</li><p><br /></p></ul><pre data-lang=\"javascript\"><code> let str = 1323;\n console.log(typeof (String(str))); // string\n console.log(typeof (Symbol(str))) // symbol</code></pre><p><br /></p><h3 id=\"f0dde815\">其他的数据类型</h3><ul><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">List</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">： 用于描述函数传参过程。</span></li><li><code><strong><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Set</span></strong></code> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：主要用于解释字符集等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Completion Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述异常、跳出等语句执行过程。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Reference</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象属性访问、delete 等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Property Descriptor</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象的属性。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Lexical Environment</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Environment Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述变量和作用域。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Data Block</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述二进制数据。</span></li></ul><h3 id=\"7aa17298\">程序 = 算法 + 数据结构</h3>",
    "body_lake": "<!doctype lake><p>tags: [JavaScript数据类型]</p><p>categories: 重学前端系列笔记</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22teFIX%22%7D\"></card><h3 id=\"X51yG\"><span style=\"background-color: transparent;\"><cursor />前言</span></h3><p>最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。</p><h3 id=\"49448199\">补充<span style=\"color: #F5222D;\">*</span></h3><ul><li><span class=\"lake-fontsize-12\">变量声明跟赋值，是两个概念。</span></li><li><span class=\"lake-fontsize-12\"><strong><code>let a</code></strong> 是属于变量声明阶段，这个阶段所有的变量的值都是 </span><strong><code><span class=\"lake-fontsize-12\">undefined</span></code></strong> <span class=\"lake-fontsize-12\">。</span><strong><code><span class=\"lake-fontsize-12\">a = 12</span></code></strong> 是赋值阶段，这个阶段是告诉 <strong><code>JS</code></strong> 解析引擎。这个变量是什么类型以及它的值多少。</li><li>当 <strong><code>JavaScript</code></strong> 执行的时候，如果遇到致命错误便会停止往下执行。</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2Fbad%E5%A3%B0%E6%98%8E%E6%96%B9%E5%BC%8F%5Cnvar%20a%3Db%3D2%3B%5Cn%2F%2F%20good%5Cnvar%20a%3D12%2Cb%3D23%3B%5Cn%2F%2F%20%E4%BD%86%E6%98%AF%E6%9B%B4%E6%9C%9F%E6%9C%9B%E4%BD%BF%E7%94%A8let%E5%A3%B0%E6%98%8E%EF%BC%8C%E4%B8%8D%E7%94%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%5Cnlet%20a%20%3D%2012%3B%22%2C%22id%22%3A%22Ckqqw%22%7D\"></card><h2 id=\"08da595a\">怎么准确的判断数据类型</h2><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20str%20%3D%20%5C%22%E4%BD%A0%E6%98%AF%E8%B0%81%EF%BC%8C%E6%88%91%E6%98%AF%E6%88%98%E6%97%A0%E4%B8%8D%E8%83%9C%E7%9A%84%E5%AD%99%E6%82%9F%E7%A9%BA%5C%22%5CnObject.prototype.toString.call(str)%20%2F%2F%20%5Bobject%2CString%5D%3B%5Cnlet%20arr%20%3D%20%5B1%2C4%2C56%5D%3B%5CnObject.prototype.toString.call(arr)%20%2F%2F%20%5Bobject%2CArray%5D%3B%22%2C%22id%22%3A%22gNxkr%22%7D\"></card><p><br /></p><h3 id=\"2746c81b\">JavaScript现有常见类型</h3><ul><li>Null</li><li>Undefined</li><li>String</li><li>Boolean</li><li>Number</li><li>Symbol</li><li>Object</li></ul><p>现在JavaScript常见类型是这么多，其中只有 <code>Symbol</code>  是 <code>ES6</code> 新提出来的，其余都是 <code>ES6</code> 之前早就熟悉的类</p><h4 id=\"c23f5abf\">（0）Null</h4><ul><li>这个类型表示：<strong>定义了但是为空</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</span></li></ul><h4 id=\"357bda8a\">（1）Undefined</h4><ul><li>这个类型表示：<strong>变量定义了但是未赋值</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值</span></li><li>它同样的表示一个变量的值，它并非一个关键词，这是 <code>JavaScript</code>  语言公认的设计失误之一，所以，所以，我们为了避免无意中被篡改，我建议使用 <code>void 0</code> 来来获取 <code>Nudefined</code> 值。</li><li>它与 <code>Null</code> 的不同就是，<code>Null</code> 是 <code>JavaScript</code> 的关键字，在开发中可以自由的获取 <code>Null</code> 类型的变量</li></ul><h4 id=\"f9369aa0\">（2）Boolean</h4><ul><li>这个类型表示：<strong>逻辑上的真和假</strong></li><li>它有两个值：<code>true</code> 和 <code>false</code> </li><li>它属于 <code>JavaScript</code> 中的内置对象，可以通过 <code>new</code> 关键词创造实例对象</li></ul><h4 id=\"ece22d59\">（3）String</h4><ul><li>这个类型表示：表示文本数据</li><li>这个类型具有长度单位的，最大的长度 <strong><code>2^53-1</code></strong> ，</li><li>这个 <code>String</code> 并非文本意义的字符串，而是字符串的 <code>UTF16</code> 编码，我们日常操作字符使用的 <code>length</code> <code>charAt</code> 都是针对 <code>UTF16</code> 编码</li><li>字符串的最大长度是受经过 <code>UTF16</code> 编码之后的字符长度限制</li></ul><h4 id=\"932cf868\">补充编码知识</h4><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。</span></p></blockquote><h4 id=\"a887f81c\">（4）Number</h4><ul><li>这个类型表示：通常意义的数字类型</li><li>它是 <code>JavaScript</code> 的内置对象，可以通过 <code>new</code> 关键字创造实例</li><li>它类型有 <code><strong>2^64-2^53+3</strong></code> 个值</li><li>在为了避免计算的时候出错，借鉴生活中的数学，引入了 <code>NaN</code> (这个可以用来检测是否为数字类型)、Infinity(正无穷大)、-Infinity(负无穷大)</li><li>在加减法中 <strong>-0</strong>和<strong>+0 </strong>没有很大的区别，但是在除法中就会很大的区别了</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(.00001%20%2F%20-0)%3B%20%2F%2F%E7%BB%93%E6%9E%9C%EF%BC%9A-Infinity%5Cnconsole.log(.00000000001%20%2F%200)%3B%20%2F%2F%E7%BB%93%E6%9E%9C%3A%20Infinity%22%2C%22id%22%3A%222GSmE%22%7D\"></card><p><br /></p><ul><li>根据双精度浮点数的定义，Number 类型中有效的整数范围是-0x1fffffffffffff 至0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。所以在非整数面前是无法使用 <code>==</code> 或者 <code>===</code> 进行比较的</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(%20.1%20%2B%20.2%20%3D%3D%20.3%20)%3B%20%2F%2F%E7%BB%93%E6%9E%9C%EF%BC%9Afalse%3B%5Cnconsole.log(.1%20%2B%20.2)%3B%20%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9A0.30000000000000004%22%2C%22id%22%3A%22nUCC9%22%7D\"></card><ul><li>正确的比较两边数值是否相等，应该比较左右两边差的绝对值是否小于最小精度</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(Math.abs(.1%20%2B%20.2%20-%20.3)%20%3C%3DNumber.EPSILON)%3B%20%2F%2F%20true%22%2C%22id%22%3A%22ratOY%22%7D\"></card><p><br /></p><blockquote><p><strong><span>Number.EPSILON</span></strong> 它是 <strong>ES6 </strong>新出的一个挂载在 <strong>Number </strong>的一个常量。</p><p><strong><span>N</span></strong><strong><span>u</span></strong><strong>mber.EPSILON</strong><span> </span><span class=\"lake-fontsize-12\">实际上是 </span><strong><span class=\"lake-fontsize-12\" style=\"color: #333333;\">JavaScript</span></strong><span class=\"lake-fontsize-12\"> 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</span></p></blockquote><h4 id=\"780b6ec0\">（5）Object</h4><ul><li>这个类型表示：<strong>对象</strong>，它是一切有形和无形物体的总称</li><li>它是属性的集合，是 <strong><code>key-value</code></strong> 结构</li><li><strong>key : </strong>可以是字符串类型。也可以是symbol类型</li><li><strong>value :</strong>可以是字符串，可以是数值类型。也可以是对象类型</li></ul><h4 id=\"c91ff6ed\">（6）Symbol</h4><ul><li>这个类型是 <code><strong>ES6</strong></code> 新增的一个类型。其实说实话，到现在还不太清楚这个类型的作用，以及用法</li><li>它是一切非字符串的对象 key 的集合</li><li>Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%9B%E5%BB%BA%20Symbol%20%E7%B1%BB%E5%9E%8B%5Cnlet%20symbol%20%3D%20Symbol(%5C%22%E5%85%B6%E5%AE%9E%EF%BC%8C%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E4%BA%BA%5C%22)%3B%5Cnconsole.log(symbol)%22%2C%22id%22%3A%22Wj6ur%22%7D\"></card><p><br /></p><ul><li>这个类型还是有很多不懂，之后有了新收获，再过来更新吧</li></ul><h3 id=\"f3c723ec\">类型转换</h3><h4 id=\"2f9540a5\">（0）string → Number(<span>字符串转成数值类型</span>)</h4><ul><li>常见都是借助 <code>JavaScript</code> 中的内置方法进行转换，例如 <code><strong>parseInt</strong></code>  <code><strong>parseFloat</strong></code> 都是将字符串转化成数值类型。但是  <code><strong>parseInt</strong></code> 是遇到非数值就停下，而<strong> </strong> <code><strong>parseFloat</strong></code> 遇到不属于数字行列才会停，</li><li><code><strong>parseInt</strong></code> <code><strong>parseFloat</strong></code>  转化的字符串，如果第一个字符不是数字的话，就会返回 <strong>NaN</strong></li><li>除了上述的两种，还有 <strong><code>JavaScript</code></strong> 内置的 <strong>Math  </strong>方法也可以隐式的转化成数值，但是依然是如果第一个字符不是数值的话，就会返回 <strong>NaN </strong></li><li>还有一种就是利用装箱操作，利用 <strong><code>Number</code></strong> 进行转换，这个转换的好处就是，只要转换的字符不属于数值类型的，都会返回 <strong>NaN</strong></li><li>如果字符串的字符都是数字。那么可以使用四则运算，也可以进行隐士转换</li></ul><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20console.log(parseInt(%5C%226340.54%5C%22))%3B%20%2F%2F%20%E7%BB%93%E6%9E%9C%3A6340%5Cn%20console.log(parseFloat(%5C%224.648781655wr%E6%88%91%E6%98%AF1%5C%22))%3B%E7%BB%93%E6%9E%9C%3A4.648781655%5Cn%20console.log(Number(%5C%222.2.22%5C%22))%3B%20%2F%2F%20%E7%BB%93%E6%9E%9C%3ANaN%5Cn%20console.log(Number(%5C%225464646%5C%22))%20%2F%2F%20%E7%BB%93%E6%9E%9C%3A%205464646%22%2C%22id%22%3A%22lsAeE%22%7D\"></card><p><br /></p><h4 id=\"6c2395fb\">（1）Number → string (数字转化成字符串)</h4><ul><li>字符串拼接</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20str%20%3D%20121343454545%3B%5Cnstr%20%3D%20str%2B%20%5C%22%5C%22%3B%5Cnconsole.log(typeof(str))%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9Astring%22%2C%22id%22%3A%22BG9HY%22%7D\"></card><p><br /></p><ul><li>装箱转换</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20str%20%3D%2013243545646%3B%5Cnconsole.log(%20typeof(%20String(str)%20)%20)%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9Astring%20%22%2C%22id%22%3A%22D50Bv%22%7D\"></card><p><br /></p><h4 id=\"0e1aa6d1\">（2）装箱操作转换</h4><ul><li>在 <code><strong>JavaScript</strong></code> 中，类型之间存在装箱转换操作</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20let%20str%20%3D%201323%3B%5Cn%20console.log(typeof%20(String(str)))%3B%20%2F%2F%20string%5Cn%20console.log(typeof%20(Symbol(str)))%20%2F%2F%20symbol%22%2C%22id%22%3A%22UJhlC%22%7D\"></card><p><br /></p><h3 id=\"f0dde815\">其他的数据类型</h3><ul><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">List</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">： 用于描述函数传参过程。</span></li><li><code><strong><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Set</span></strong></code> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：主要用于解释字符集等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Completion Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述异常、跳出等语句执行过程。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Reference</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象属性访问、delete 等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Property Descriptor</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象的属性。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Lexical Environment</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Environment Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述变量和作用域。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Data Block</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述二进制数据。</span></li></ul><h3 id=\"7aa17298\">程序 = 算法 + 数据结构</h3>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T02:01:37.000Z",
    "deleted_at": null,
    "created_at": "2019-03-27T03:12:47.000Z",
    "updated_at": "2019-04-28T02:01:37.000Z",
    "published_at": "2019-04-28T02:01:37.000Z",
    "first_published_at": "2019-03-27T03:22:53.000Z",
    "word_count": 1787,
    "cover": "",
    "description": "tags: [JavaScript数据类型]categories: 重学前端系列笔记前言最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。补充*变量声明跟赋值，是两个概念。let a 是属于变量声明阶段，这个阶段所有的变量...",
    "custom_description": "前言最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1571315,
    "slug": "fl9fg4",
    "title": "13. 零碎但好用的API",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T01:56:39.365Z",
      "updated_at": "2019-04-28T01:56:39.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [工作常用的API]<br />categories: 重学前端系列笔记<br />cover: \"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg\"\n\n---\n记录一下工作中常用，但是不好归纳的 **`API`** \n\n👇 内容速览 👇\n\n- 获取样式表\n- 获取盒子准确宽高\n- 获取联网情况\n- 元素可编辑\n- 获取语言\n- 震动\n- 全屏与退出全屏\n\n<!-- more -->\n<a name=\"58f055cd\"></a>\n### 样式表\n```javascript\nconsole.log(document.styleSheets)\n/* 可以获取当前页面的样式表 */\n```\n\n<a name=\"fe7fef1d\"></a>\n### 获取包裹元素盒的宽高\n> 我们常说的获取宽高，其实是获取包裹元素盒子的宽高，元素是没有宽高的，只有盒子有宽高\n\n- **`getClientRects()`**`x、y`** 是相对于浏览器视口来定的，是个相对的数值\n- **`getBoundingClintRect()`** ：返回的是一个对象，里面同样是盒子所占据区域的尺寸\n\n两者不同的地方在于，一个是返回列表，一个是直接返回的对象\n<a name=\"738bd8cf\"></a>\n### 获取联网情况\n<a name=\"df66e53e\"></a>\n#### navigator.onLine（联网的时候触发）\n<a name=\"feaca892\"></a>\n#### navigator.offLine（连不上网的时候触发）\n```javascript\nwindow.addEventListener('online',Function, true);\nwindow.addEventListener('offline', Function , true);\n```\n> 注意: **`navigator.onLine`** 只会在机器未连接到局域网或路由器时返回 **`false`**，其他情况下均返回 **`true`**。 也就是说，机器连接上路由器后，即使这个路由器没联通网络，**`navigator.onLine`** 仍然返回 **`true`**。\n\n<a name=\"ca7be09f\"></a>\n### 元素可编辑（contenteditable）\n> HTML 给全局提供了可以让普通的元素可以像input输入框那种，可以输入文字\n\n```html\n<div contenteditable=\"true\">可编辑</div>\n```\n<a name=\"2547bb16\"></a>\n### 获取当前语言（navigator.language）\n> 它基于系统语言设置\n\n```javascript\nconsole.log(navigator.language) // 具体的语言值是根据系统来的\n```\n<a name=\"728dc0aa\"></a>\n### 使得页面震动（window.navigator.vibrate(_pattern_)）\n```javascript\nvar successBool = window.navigator.vibrate(pattern);// 兼容性不是很好 \n/*传递一个 0、一个空数组或者一个元素全部为 0 的数组会结束当前正在运行中的震动模式。*/\n```\n<a name=\"3c7c0f11\"></a>\n### 全屏以及退出全屏\n<a name=\"0b919881\"></a>\n#### `document.documentElement.requestFullscreen()` （全屏）\n<a name=\"567ddbe2\"></a>\n#### **`document.exitFullscreen()`** （退出全屏）\n```javascript\nfunction fullScreenFun(){\n    let self = this;\n     var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled ||\n        document.webkitFullscreenEnabled || document.msFullscreenEnabled;\n    if (fullscreenEnabled) { //判断浏览器是不是支持全屏\n        let de = document.documentElement;\n        if(self.fullScreenInfo === '打开全屏'){\n            if( de.requestFullscreen ){\n                de.requestFullscreen();\n            }else if( de.mozRequestFullScreen ){\n                de.mozRequestFullScreen();\n            }else if( de.webkitRequestFullScreen ){\n                de.webkitRequestFullScreen();\n            }\n            self.fullScreenInfo = '退出全屏'\n        } else {\n            if( document.exitFullscreen ){\n                document.exitFullscreen();\n            }else if( document.mozCancelFullScreen ){\n                document.mozCancelFullScreen();\n            }else if( document.webkitCancelFullScreen ){\n                document.webkitCancelFullScreen();\n            }\n            self.fullScreenInfo = '打开全屏'\n        }\n    } else {\n        self.fullScreenInfo = '浏览器当前不能全屏';\n    }\n}\n```\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [工作常用的API]</p><p>categories<span>:</span> 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><hr /><p><span style=\"background-color: transparent;\">记录一下工作中常用，但是不好归纳的 </span><strong><code>API</code></strong><span style=\"background-color: transparent;\"> </span><br /></p><p>👇 内容速览 👇</p><ul><li>获取样式表</li><li>获取盒子准确宽高</li><li>获取联网情况</li><li>元素可编辑</li><li>获取语言</li><li>震动</li><li>全屏与退出全屏</li></ul><p>&lt;!-- more --&gt;</p><h3 id=\"58f055cd\">样式表</h3><pre data-lang=\"javascript\"><code>console.log(document.styleSheets)\n/* 可以获取当前页面的样式表 */</code></pre><p><br /></p><h3 id=\"fe7fef1d\">获取包裹元素盒的宽高</h3><blockquote><p>我们常说的获取宽高，其实是获取包裹元素盒子的宽高，元素是没有宽高的，只有盒子有宽高</p></blockquote><ul><li><strong><code>getClientRects()</code></strong>  ：返回的是一个列表，里面是包裹元素的盒的矩形区域所占的尺寸，里面的 <strong><code>x、y</code></strong> 是相对于浏览器视口来定的，是个相对的数值</li><li><strong><code>getBoundingClintRect()</code></strong> ：返回的是一个对象，里面同样是盒子所占据区域的尺寸</li></ul><p><span class=\"lake-fontsize-12\">两者不同的地方在于，一个是返回列表，一个是直接返回的对象</span></p><h3 id=\"738bd8cf\">获取联网情况</h3><h4 id=\"df66e53e\">navigator.onLine（联网的时候触发）</h4><h4 id=\"feaca892\">navigator.offLine（连不上网的时候触发）</h4><pre data-lang=\"javascript\"><code>window.addEventListener('online',Function, true);\nwindow.addEventListener('offline', Function , true);</code></pre><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">注意: </span><strong><span class=\"lake-fontsize-12\"><code>navigator.onLine</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\"> 只会在机器未连接到局域网或路由器时返回 </span><strong><span class=\"lake-fontsize-12\"><code>false</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">，其他情况下均返回 </span><strong><span class=\"lake-fontsize-12\"><code>true</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">。 也就是说，机器连接上路由器后，即使这个路由器没联通网络，</span><strong><span class=\"lake-fontsize-12\"><code>navigator.onLine</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\"> 仍然返回 </span><strong><span class=\"lake-fontsize-12\"><code>true</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">。</span></p></blockquote><h3 id=\"ca7be09f\">元素可编辑（contenteditable）</h3><blockquote><p>HTML 给全局提供了可以让普通的元素可以像input输入框那种，可以输入文字</p></blockquote><pre data-lang=\"html\"><code>&lt;div contenteditable=&quot;true&quot;&gt;可编辑&lt;/div&gt;</code></pre><h3 id=\"2547bb16\">获取当前语言（navigator.language）</h3><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">它基于系统语言设置</span></p></blockquote><pre data-lang=\"javascript\"><code>console.log(navigator.language) // 具体的语言值是根据系统来的</code></pre><h3 id=\"728dc0aa\">使得页面震动（window.navigator.vibrate(<em>pattern</em>)）</h3><pre data-lang=\"javascript\"><code>var successBool = window.navigator.vibrate(pattern);// 兼容性不是很好 \n/*传递一个 0、一个空数组或者一个元素全部为 0 的数组会结束当前正在运行中的震动模式。*/</code></pre><h3 id=\"3c7c0f11\">全屏以及退出全屏</h3><h4 id=\"0b919881\"><code>document.documentElement.requestFullscreen()</code> （全屏）</h4><h4 id=\"567ddbe2\"><strong><code>document.exitFullscreen()</code></strong> （退出全屏）</h4><pre data-lang=\"javascript\"><code>function fullScreenFun(){\n    let self = this;\n     var fullscreenEnabled = document.fullscreenEnabled || document.mozFullScreenEnabled ||\n        document.webkitFullscreenEnabled || document.msFullscreenEnabled;\n    if (fullscreenEnabled) { //判断浏览器是不是支持全屏\n        let de = document.documentElement;\n        if(self.fullScreenInfo === '打开全屏'){\n            if( de.requestFullscreen ){\n                de.requestFullscreen();\n            }else if( de.mozRequestFullScreen ){\n                de.mozRequestFullScreen();\n            }else if( de.webkitRequestFullScreen ){\n                de.webkitRequestFullScreen();\n            }\n            self.fullScreenInfo = '退出全屏'\n        } else {\n            if( document.exitFullscreen ){\n                document.exitFullscreen();\n            }else if( document.mozCancelFullScreen ){\n                document.mozCancelFullScreen();\n            }else if( document.webkitCancelFullScreen ){\n                document.webkitCancelFullScreen();\n            }\n            self.fullScreenInfo = '打开全屏'\n        }\n    } else {\n        self.fullScreenInfo = '浏览器当前不能全屏';\n    }\n}</code></pre><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [工作常用的API]</p><p>categories<span>:</span> 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22ycaIG%22%7D\"></card><p><span style=\"background-color: transparent;\">记录一下工作中常用，但是不好归纳的 </span><strong><code>API</code></strong><span style=\"background-color: transparent;\"> </span><br /></p><p>👇 内容速览 👇</p><ul><li>获取样式表<cursor /></li><li>获取盒子准确宽高</li><li>获取联网情况</li><li>元素可编辑</li><li>获取语言</li><li>震动</li><li>全屏与退出全屏</li></ul><p>&lt;!-- more --&gt;</p><h3 id=\"58f055cd\">样式表</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(document.styleSheets)%5Cn%2F*%20%E5%8F%AF%E4%BB%A5%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E9%A1%B5%E9%9D%A2%E7%9A%84%E6%A0%B7%E5%BC%8F%E8%A1%A8%20*%2F%22%2C%22id%22%3A%22eewsn%22%7D\"></card><p><br /></p><h3 id=\"fe7fef1d\">获取包裹元素盒的宽高</h3><blockquote><p>我们常说的获取宽高，其实是获取包裹元素盒子的宽高，元素是没有宽高的，只有盒子有宽高</p></blockquote><ul><li><strong><code>getClientRects()</code></strong>  ：返回的是一个列表，里面是包裹元素的盒的矩形区域所占的尺寸，里面的 <strong><code>x、y</code></strong> 是相对于浏览器视口来定的，是个相对的数值</li><li><strong><code>getBoundingClintRect()</code></strong> ：返回的是一个对象，里面同样是盒子所占据区域的尺寸</li></ul><p><span class=\"lake-fontsize-12\">两者不同的地方在于，一个是返回列表，一个是直接返回的对象</span></p><h3 id=\"738bd8cf\">获取联网情况</h3><h4 id=\"df66e53e\">navigator.onLine（联网的时候触发）</h4><h4 id=\"feaca892\">navigator.offLine（连不上网的时候触发）</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22window.addEventListener('online'%2CFunction%2C%20true)%3B%5Cnwindow.addEventListener('offline'%2C%20Function%20%2C%20true)%3B%22%2C%22id%22%3A%22ob15j%22%7D\"></card><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">注意: </span><strong><span class=\"lake-fontsize-12\"><code>navigator.onLine</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\"> 只会在机器未连接到局域网或路由器时返回 </span><strong><span class=\"lake-fontsize-12\"><code>false</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">，其他情况下均返回 </span><strong><span class=\"lake-fontsize-12\"><code>true</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">。 也就是说，机器连接上路由器后，即使这个路由器没联通网络，</span><strong><span class=\"lake-fontsize-12\"><code>navigator.onLine</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\"> 仍然返回 </span><strong><span class=\"lake-fontsize-12\"><code>true</code></span></strong><span class=\"lake-fontsize-12\" style=\"color: #666666; background-color: #F8F8F8;\">。</span></p></blockquote><h3 id=\"ca7be09f\">元素可编辑（contenteditable）</h3><blockquote><p>HTML 给全局提供了可以让普通的元素可以像input输入框那种，可以输入文字</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cdiv%20contenteditable%3D%5C%22true%5C%22%3E%E5%8F%AF%E7%BC%96%E8%BE%91%3C%2Fdiv%3E%22%2C%22id%22%3A%22e4lcl%22%7D\"></card><h3 id=\"2547bb16\">获取当前语言（navigator.language）</h3><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #333333;\">它基于系统语言设置</span></p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(navigator.language)%20%2F%2F%20%E5%85%B7%E4%BD%93%E7%9A%84%E8%AF%AD%E8%A8%80%E5%80%BC%E6%98%AF%E6%A0%B9%E6%8D%AE%E7%B3%BB%E7%BB%9F%E6%9D%A5%E7%9A%84%22%2C%22id%22%3A%22dIHjZ%22%7D\"></card><h3 id=\"728dc0aa\">使得页面震动（window.navigator.vibrate(<em>pattern</em>)）</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20successBool%20%3D%20window.navigator.vibrate(pattern)%3B%2F%2F%20%E5%85%BC%E5%AE%B9%E6%80%A7%E4%B8%8D%E6%98%AF%E5%BE%88%E5%A5%BD%20%5Cn%2F*%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%200%E3%80%81%E4%B8%80%E4%B8%AA%E7%A9%BA%E6%95%B0%E7%BB%84%E6%88%96%E8%80%85%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E5%85%A8%E9%83%A8%E4%B8%BA%200%20%E7%9A%84%E6%95%B0%E7%BB%84%E4%BC%9A%E7%BB%93%E6%9D%9F%E5%BD%93%E5%89%8D%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E4%B8%AD%E7%9A%84%E9%9C%87%E5%8A%A8%E6%A8%A1%E5%BC%8F%E3%80%82*%2F%22%2C%22id%22%3A%22nqsyl%22%7D\"></card><h3 id=\"3c7c0f11\">全屏以及退出全屏</h3><h4 id=\"0b919881\"><code>document.documentElement.requestFullscreen()</code> （全屏）</h4><h4 id=\"567ddbe2\"><strong><code>document.exitFullscreen()</code></strong> （退出全屏）</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20fullScreenFun()%7B%5Cn%20%20%20%20let%20self%20%3D%20this%3B%5Cn%20%20%20%20%20var%20fullscreenEnabled%20%3D%20document.fullscreenEnabled%20%7C%7C%20document.mozFullScreenEnabled%20%7C%7C%5Cn%20%20%20%20%20%20%20%20document.webkitFullscreenEnabled%20%7C%7C%20document.msFullscreenEnabled%3B%5Cn%20%20%20%20if%20(fullscreenEnabled)%20%7B%20%2F%2F%E5%88%A4%E6%96%AD%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%AF%E4%B8%8D%E6%98%AF%E6%94%AF%E6%8C%81%E5%85%A8%E5%B1%8F%5Cn%20%20%20%20%20%20%20%20let%20de%20%3D%20document.documentElement%3B%5Cn%20%20%20%20%20%20%20%20if(self.fullScreenInfo%20%3D%3D%3D%20'%E6%89%93%E5%BC%80%E5%85%A8%E5%B1%8F')%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if(%20de.requestFullscreen%20)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20de.requestFullscreen()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7Delse%20if(%20de.mozRequestFullScreen%20)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20de.mozRequestFullScreen()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7Delse%20if(%20de.webkitRequestFullScreen%20)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20de.webkitRequestFullScreen()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20self.fullScreenInfo%20%3D%20'%E9%80%80%E5%87%BA%E5%85%A8%E5%B1%8F'%5Cn%20%20%20%20%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20if(%20document.exitFullscreen%20)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20document.exitFullscreen()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7Delse%20if(%20document.mozCancelFullScreen%20)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20document.mozCancelFullScreen()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7Delse%20if(%20document.webkitCancelFullScreen%20)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20%20document.webkitCancelFullScreen()%3B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%20%20%20%20%20%20%20%20self.fullScreenInfo%20%3D%20'%E6%89%93%E5%BC%80%E5%85%A8%E5%B1%8F'%5Cn%20%20%20%20%20%20%20%20%7D%5Cn%20%20%20%20%7D%20else%20%7B%5Cn%20%20%20%20%20%20%20%20self.fullScreenInfo%20%3D%20'%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BD%93%E5%89%8D%E4%B8%8D%E8%83%BD%E5%85%A8%E5%B1%8F'%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22id%22%3A%22Ad8bN%22%7D\"></card><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 1,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:54:53.000Z",
    "deleted_at": null,
    "created_at": "2019-04-22T02:46:38.000Z",
    "updated_at": "2019-04-28T01:54:53.000Z",
    "published_at": "2019-04-28T01:54:53.000Z",
    "first_published_at": "2019-04-22T10:03:43.000Z",
    "word_count": 638,
    "cover": null,
    "description": "tags: [工作常用的API]categories: 重学前端系列笔记cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33....",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1584610,
    "slug": "ix7s2g",
    "title": "14. css选择器总结",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T01:56:39.365Z",
      "updated_at": "2019-04-28T01:56:39.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [css选择器]<br />categories: 重学前端系列笔记<br />cover: \"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg\"\n\n---\n<a name=\"q1A2V\"></a>\n## 前言\n标准中为了让我们便捷的选择元素，给元素赋值样式，便设计了很多选择器，而选择器又可以分好几种：\n\n- **普通选择器![我是谁,我来自哪](https://cdn.nlark.com/yuque/0/2019/png/221851/1556261209711-aa44158e-3599-4981-88bc-ed0b0fda61de.png#align=left&display=inline&height=577&name=%E6%88%91%E6%98%AF%E8%B0%81%2C%E6%88%91%E6%9D%A5%E8%87%AA%E5%93%AA&originHeight=591&originWidth=764&size=0&status=done&width=746)**\n- **复合选择器 （**连续写在一起的简单选择器，针对元素自身特征选择单个元素。**）**\n- **全体选择器（*）**\n- **列表选择器（**由 `空格 、> 、~ 、+ 、 || ` 等符号连接的复合选择器，根据父元素或者前序元素检查单个元素**）**\n\n\n<a name=\"b2JjV\"></a>\n### 普通选择器\n\n- **类名选择器 （.class）**\n- **ID选择器（#id）**\n- **标签选择器（tag）**\n- **属性选择器**\n```css\ninput[dataType]{} /*选择 input 里含有 dataType 属性的元素*/\ninput[dataType=\"one\"]{} /*选择 input 里含有 dataType 属性并且它的值为 one 的元素*/\ninput[dataType ~=\"one two\"]{} /*选择 input 里含有 dataType 属性并且它的值为 one或者two或者一个序列 (该序列内的值用空格分隔) 的元素*/\ninput[dataType |=\"one\"]{} /*选择 input 里含有 dataType 属性并且它的值是否是 one 开头的元素*/\n```\n\n\n- **伪类选择器**\n  - 树状关系\n```css\n:nth-of-type(1){} /*获取某元素第几个元素*/\n:nth-last-of-type(1){}  /*获取某元素从后往前数第一个元素*/\nnth-child(2n) /*选择偶数节点*/\n:first-child /*表示第一个元素*/\n:last-child /*表示最后一个元素*/\n```\n\n\n  - 链接与行为\n```css\n:any-link /*表示选择任何链接的元素 比如a、area 和 link */\n:link \t/*表示未访问过的链接，*/\n:visited \t/*表示已经访问过的链接。*/\n:hover \t/*表示鼠标悬停在上的元素，*/\n:active \t/*表示用户正在激活这个元素，如用户按下按钮，鼠标还未抬起时，这个按钮就处于激活状态*/\n:focus \t/*表示焦点落在这个元素之上。*/\n:target \t/*用于选中浏览器 URL 的 hash 部分所指示的元素。*/\n```\n\n\n  - 逻辑伪类选择器\n  - 其他\n    - 国家化（处理国家化语言问题）\n      - dir\n      - lang\n    - 音频、视频（用于区分音视频播放状态）\n      - play\n      - pause\n    - 时序：用于配合读屏软件等时序性客户端的伪类\n      - current\n      - past\n      - future\n    - 表格：用于处理 table 的列的伪类。\n      - nth-col\n      - nth-last-col\n<a name=\"uM5uz\"></a>\n### 复合选择器\n```css\n.test input {}\n.test .test-child{}\n```\n<a name=\"vAuOH\"></a>\n### 列表选择器\n\n[css选择器](http://www.w3school.com.cn/cssref/css_selectors.asp)文档\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [css选择器]</p><p>categories<span>:</span> 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><hr /><h2 id=\"q1A2V\"><span style=\"background-color: transparent;\">前言</span></h2><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-14\">标准中为了让我们便捷的选择元素，给元素赋值样式，便设计了很多选择器，而选择器又可以分好几种：</span></p><ul><li><span class=\"lake-fontsize-12\"><strong>普通选择器<img alt=\"我是谁,我来自哪\" title=\"我是谁,我来自哪\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1556261209711-aa44158e-3599-4981-88bc-ed0b0fda61de.png#align=left&amp;display=inline&amp;height=577&amp;name=%E6%88%91%E6%98%AF%E8%B0%81%2C%E6%88%91%E6%9D%A5%E8%87%AA%E5%93%AA&amp;originHeight=591&amp;originWidth=764&amp;size=0&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></strong></span></li><li><span class=\"lake-fontsize-12\"><strong>复合选择器 （</strong></span><span>连续写在一起的简单选择器，针对元素自身特征选择单个元素。</span><span class=\"lake-fontsize-12\"><strong>）</strong></span></li><li><span class=\"lake-fontsize-12\"><strong>全体选择器（*）</strong></span></li><li><span class=\"lake-fontsize-12\"><strong>列表选择器（</strong></span>由 <code>空格 、&gt; 、~ 、+ 、 || </code> 等符号连接的复合选择器，根据父元素或者前序元素检查单个元素<strong>）</strong></li></ul><p><br /></p><p><br /></p><h3 id=\"b2JjV\">普通选择器</h3><ul><li><strong>类名选择</strong><strong><span>器 （.class）</span></strong></li><li><strong>ID选择器（#id）</strong></li><li><strong>标签选择器（tag）</strong></li><li><strong>属性选择器</strong></li></ul><pre data-lang=\"css\"><code>input[dataType]{} /*选择 input 里含有 dataType 属性的元素*/\ninput[dataType=&quot;one&quot;]{} /*选择 input 里含有 dataType 属性并且它的值为 one 的元素*/\ninput[dataType ~=&quot;one two&quot;]{} /*选择 input 里含有 dataType 属性并且它的值为 one或者two或者一个序列 (该序列内的值用空格分隔) 的元素*/\ninput[dataType |=&quot;one&quot;]{} /*选择 input 里含有 dataType 属性并且它的值是否是 one 开头的元素*/</code></pre><ul><p><br /></p><li><strong>伪类选择器</strong></li></ul><ul data-lake-indent=\"1\"><li>树状关系</li></ul><pre data-lang=\"css\"><code>:nth-of-type(1){} /*获取某元素第几个元素*/\n:nth-last-of-type(1){}  /*获取某元素从后往前数第一个元素*/\nnth-child(2n) /*选择偶数节点*/\n:first-child /*表示第一个元素*/\n:last-child /*表示最后一个元素*/</code></pre><ul data-lake-indent=\"1\"><p><br /></p><li>链接与行为</li></ul><pre data-lang=\"css\"><code>:any-link /*表示选择任何链接的元素 比如a、area 和 link */\n:link \t/*表示未访问过的链接，*/\n:visited \t/*表示已经访问过的链接。*/\n:hover \t/*表示鼠标悬停在上的元素，*/\n:active \t/*表示用户正在激活这个元素，如用户按下按钮，鼠标还未抬起时，这个按钮就处于激活状态*/\n:focus \t/*表示焦点落在这个元素之上。*/\n:target \t/*用于选中浏览器 URL 的 hash 部分所指示的元素。*/</code></pre><ul data-lake-indent=\"1\"><p><br /></p><li>逻辑伪类选择器</li><li>其他</li></ul><ul data-lake-indent=\"2\"><li>国家化（处理国家化语言问题）</li></ul><ul data-lake-indent=\"3\"><li>dir</li><li>lang</li></ul><ul data-lake-indent=\"2\"><li>音频、视频（用于区分音视频播放状态）</li></ul><ul data-lake-indent=\"3\"><li>play</li><li>pause</li></ul><ul data-lake-indent=\"2\"><li>时序：用于配合读屏软件等时序性客户端的伪类</li></ul><ul data-lake-indent=\"3\"><li>current</li><li>past</li><li>future</li></ul><ul data-lake-indent=\"2\"><li>表格：用于处理 table 的列的伪类。</li></ul><ul data-lake-indent=\"3\"><li>nth-col</li><li>nth-last-col</li></ul><h3 id=\"uM5uz\">复合选择器</h3><pre data-lang=\"css\"><code>.test input {}\n.test .test-child{}</code></pre><h3 id=\"vAuOH\">列表选择器</h3><p><br /></p><p><span class=\"lake-fontsize-12\"><a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\">css选择器</a>文档</span></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [css选择器]</p><p>categories<span>:</span> 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22yfZGh%22%7D\"></card><cursor /><h2 id=\"q1A2V\"><span style=\"background-color: transparent;\">前言</span></h2><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-14\">标准中为了让我们便捷的选择元素，给元素赋值样式，便设计了很多选择器，而选择器又可以分好几种：</span></p><ul><li><span class=\"lake-fontsize-12\"><strong>普通选择器<card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1556261209711-aa44158e-3599-4981-88bc-ed0b0fda61de.png%22%2C%22originWidth%22%3A764%2C%22originHeight%22%3A591%2C%22name%22%3A%22%E6%88%91%E6%98%AF%E8%B0%81%2C%E6%88%91%E6%9D%A5%E8%87%AA%E5%93%AA%22%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A577%7D\"></card></strong></span></li><li><span class=\"lake-fontsize-12\"><strong>复合选择器 （</strong></span><span>连续写在一起的简单选择器，针对元素自身特征选择单个元素。</span><span class=\"lake-fontsize-12\"><strong>）</strong></span></li><li><span class=\"lake-fontsize-12\"><strong>全体选择器（*）</strong></span></li><li><span class=\"lake-fontsize-12\"><strong>列表选择器（</strong></span>由 <code>空格 、&gt; 、~ 、+ 、 || </code> 等符号连接的复合选择器，根据父元素或者前序元素检查单个元素<strong>）</strong></li></ul><p><br /></p><p><br /></p><h3 id=\"b2JjV\">普通选择器</h3><ul><li><strong>类名选择</strong><strong><span>器 （.class）</span></strong></li><li><strong>ID选择器（#id）</strong></li><li><strong>标签选择器（tag）</strong></li><li><strong>属性选择器</strong></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22input%5BdataType%5D%7B%7D%20%2F*%E9%80%89%E6%8B%A9%20input%20%E9%87%8C%E5%90%AB%E6%9C%89%20dataType%20%E5%B1%9E%E6%80%A7%E7%9A%84%E5%85%83%E7%B4%A0*%2F%5Cninput%5BdataType%3D%5C%22one%5C%22%5D%7B%7D%20%2F*%E9%80%89%E6%8B%A9%20input%20%E9%87%8C%E5%90%AB%E6%9C%89%20dataType%20%E5%B1%9E%E6%80%A7%E5%B9%B6%E4%B8%94%E5%AE%83%E7%9A%84%E5%80%BC%E4%B8%BA%20one%20%E7%9A%84%E5%85%83%E7%B4%A0*%2F%5Cninput%5BdataType%20~%3D%5C%22one%20two%5C%22%5D%7B%7D%20%2F*%E9%80%89%E6%8B%A9%20input%20%E9%87%8C%E5%90%AB%E6%9C%89%20dataType%20%E5%B1%9E%E6%80%A7%E5%B9%B6%E4%B8%94%E5%AE%83%E7%9A%84%E5%80%BC%E4%B8%BA%20one%E6%88%96%E8%80%85two%E6%88%96%E8%80%85%E4%B8%80%E4%B8%AA%E5%BA%8F%E5%88%97%20(%E8%AF%A5%E5%BA%8F%E5%88%97%E5%86%85%E7%9A%84%E5%80%BC%E7%94%A8%E7%A9%BA%E6%A0%BC%E5%88%86%E9%9A%94)%20%E7%9A%84%E5%85%83%E7%B4%A0*%2F%5Cninput%5BdataType%20%7C%3D%5C%22one%5C%22%5D%7B%7D%20%2F*%E9%80%89%E6%8B%A9%20input%20%E9%87%8C%E5%90%AB%E6%9C%89%20dataType%20%E5%B1%9E%E6%80%A7%E5%B9%B6%E4%B8%94%E5%AE%83%E7%9A%84%E5%80%BC%E6%98%AF%E5%90%A6%E6%98%AF%20one%20%E5%BC%80%E5%A4%B4%E7%9A%84%E5%85%83%E7%B4%A0*%2F%22%2C%22id%22%3A%22bVEdF%22%7D\"></card><ul><p><br /></p><li><strong>伪类选择器</strong></li></ul><ul data-lake-indent=\"1\"><li>树状关系</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%3Anth-of-type(1)%7B%7D%20%2F*%E8%8E%B7%E5%8F%96%E6%9F%90%E5%85%83%E7%B4%A0%E7%AC%AC%E5%87%A0%E4%B8%AA%E5%85%83%E7%B4%A0*%2F%5Cn%3Anth-last-of-type(1)%7B%7D%20%20%2F*%E8%8E%B7%E5%8F%96%E6%9F%90%E5%85%83%E7%B4%A0%E4%BB%8E%E5%90%8E%E5%BE%80%E5%89%8D%E6%95%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0*%2F%5Cnnth-child(2n)%20%2F*%E9%80%89%E6%8B%A9%E5%81%B6%E6%95%B0%E8%8A%82%E7%82%B9*%2F%5Cn%3Afirst-child%20%2F*%E8%A1%A8%E7%A4%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0*%2F%5Cn%3Alast-child%20%2F*%E8%A1%A8%E7%A4%BA%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0*%2F%22%2C%22id%22%3A%22UMYeH%22%7D\"></card><ul data-lake-indent=\"1\"><p><br /></p><li>链接与行为</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%3Aany-link%20%2F*%E8%A1%A8%E7%A4%BA%E9%80%89%E6%8B%A9%E4%BB%BB%E4%BD%95%E9%93%BE%E6%8E%A5%E7%9A%84%E5%85%83%E7%B4%A0%20%E6%AF%94%E5%A6%82a%E3%80%81area%20%E5%92%8C%20link%20*%2F%5Cn%3Alink%20%5Ct%2F*%E8%A1%A8%E7%A4%BA%E6%9C%AA%E8%AE%BF%E9%97%AE%E8%BF%87%E7%9A%84%E9%93%BE%E6%8E%A5%EF%BC%8C*%2F%5Cn%3Avisited%20%5Ct%2F*%E8%A1%A8%E7%A4%BA%E5%B7%B2%E7%BB%8F%E8%AE%BF%E9%97%AE%E8%BF%87%E7%9A%84%E9%93%BE%E6%8E%A5%E3%80%82*%2F%5Cn%3Ahover%20%5Ct%2F*%E8%A1%A8%E7%A4%BA%E9%BC%A0%E6%A0%87%E6%82%AC%E5%81%9C%E5%9C%A8%E4%B8%8A%E7%9A%84%E5%85%83%E7%B4%A0%EF%BC%8C*%2F%5Cn%3Aactive%20%5Ct%2F*%E8%A1%A8%E7%A4%BA%E7%94%A8%E6%88%B7%E6%AD%A3%E5%9C%A8%E6%BF%80%E6%B4%BB%E8%BF%99%E4%B8%AA%E5%85%83%E7%B4%A0%EF%BC%8C%E5%A6%82%E7%94%A8%E6%88%B7%E6%8C%89%E4%B8%8B%E6%8C%89%E9%92%AE%EF%BC%8C%E9%BC%A0%E6%A0%87%E8%BF%98%E6%9C%AA%E6%8A%AC%E8%B5%B7%E6%97%B6%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%8C%89%E9%92%AE%E5%B0%B1%E5%A4%84%E4%BA%8E%E6%BF%80%E6%B4%BB%E7%8A%B6%E6%80%81*%2F%5Cn%3Afocus%20%5Ct%2F*%E8%A1%A8%E7%A4%BA%E7%84%A6%E7%82%B9%E8%90%BD%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%85%83%E7%B4%A0%E4%B9%8B%E4%B8%8A%E3%80%82*%2F%5Cn%3Atarget%20%5Ct%2F*%E7%94%A8%E4%BA%8E%E9%80%89%E4%B8%AD%E6%B5%8F%E8%A7%88%E5%99%A8%20URL%20%E7%9A%84%20hash%20%E9%83%A8%E5%88%86%E6%89%80%E6%8C%87%E7%A4%BA%E7%9A%84%E5%85%83%E7%B4%A0%E3%80%82*%2F%22%2C%22id%22%3A%22QMkFX%22%7D\"></card><ul data-lake-indent=\"1\"><p><br /></p><li>逻辑伪类选择器</li><li>其他</li></ul><ul data-lake-indent=\"2\"><li>国家化（处理国家化语言问题）</li></ul><ul data-lake-indent=\"3\"><li>dir</li><li>lang</li></ul><ul data-lake-indent=\"2\"><li>音频、视频（用于区分音视频播放状态）</li></ul><ul data-lake-indent=\"3\"><li>play</li><li>pause</li></ul><ul data-lake-indent=\"2\"><li>时序：用于配合读屏软件等时序性客户端的伪类</li></ul><ul data-lake-indent=\"3\"><li>current</li><li>past</li><li>future</li></ul><ul data-lake-indent=\"2\"><li>表格：用于处理 table 的列的伪类。</li></ul><ul data-lake-indent=\"3\"><li>nth-col</li><li>nth-last-col</li></ul><h3 id=\"uM5uz\">复合选择器</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22.test%20input%20%7B%7D%5Cn.test%20.test-child%7B%7D%22%2C%22id%22%3A%22ABXeg%22%7D\"></card><h3 id=\"vAuOH\">列表选择器</h3><p><br /></p><p><span class=\"lake-fontsize-12\"><a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\" target=\"_blank\">css选择器</a>文档</span></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:56:01.000Z",
    "deleted_at": null,
    "created_at": "2019-04-24T03:04:50.000Z",
    "updated_at": "2019-04-28T01:56:01.000Z",
    "published_at": "2019-04-28T01:56:01.000Z",
    "first_published_at": "2019-04-24T10:21:50.000Z",
    "word_count": 595,
    "cover": null,
    "description": "tags: [css选择器]categories: 重学前端系列笔记cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jp...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1599284,
    "slug": "kb19dh",
    "title": "15. 为什么12.tostring()会报错（转载）",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T01:56:39.365Z",
      "updated_at": "2019-04-28T01:56:39.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [词法,转载]<br />categories: 重学前端系列笔记<br />cover: \"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg\"\n\n---\n<a name=\"Bv0tc\"></a>\n## 前言\n一般来说，文法分成词法和语法两种。<br />词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。<br />从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。\n<a name=\"a4d3b02a\"></a>\n## 概述\n我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类：\n\n- WhiteSpace 空白字符\n- LineTerminator 换行符\n- Comment 注释\n- Token 词\n  - IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。\n  - Punctuator 符号，我们使用的运算符和大括号等符号。\n  - NumericLiteral 数字直接量，就是我们写的数字。\n  - StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。\n  - Template 字符串模板，用反引号``` 括起来的直接量。\n\n这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。\n\n首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。\n\n但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。\n\nJavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的：\n```javascript\n`Hello, ${name}`\n```\n\n理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。<br />是否允许“ } ”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义：\n\n- InputElementDiv；\n- InputElementRegExp；\n- InputElementRegExpOrTemplateTail；\n- InputElementTemplateTail。\n\n为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为 CommonToken。<br />但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。<br />对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript 来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。<br />接下来我来给你详细介绍一下。\n<a name=\"97f64546\"></a>\n### 空白符号 Whitespace\n说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。\n\n- `<HT>`(或称`<TAB>`) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \\t 。\n- `<VT>`是 U+000B，也就是垂直方向的 TAB 符 \\v，这个字符在键盘上很难打出来，所以很少用到。\n- `<FF>`是 U+000C，Form Feed，分页符，字符串直接量中写作 \\f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。\n- `<SP>`是 U+0020，就是最普通的空格了。\n- `<NBSP>`是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript 编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 `&nbsp;` 最后生成的就是它了。\n- `<ZWNBSP>`(旧称`<BOM>`) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF 格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。\n\n此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表：<br />![](https://cdn.nlark.com/yuque/0/2019/png/221851/1556267260565-70b7c36d-f773-4d4a-a4a7-f34d8307bb56.png#align=left&display=inline&height=575&originHeight=575&originWidth=399&size=0&status=done&width=399)<br />很多公司的编码规范要求 JavaScript 源代码控制在 ASCII 范围内，那么，就只有`<TAB>` `<VT>` `<FF>` `<SP>` `<NBSP>`五种空白可用了。\n<a name=\"638bc508\"></a>\n### 换行符 LineTerminator\n接下来我们来看看换行符，JavaScript 中只提供了 4 种字符作为换行符。\n\n- `<LF>`\n- `<CR>`\n- `<LS>`\n- `<PS>`\n\n其中，`<LF>`是 U+000A，就是最正常换行符，在字符串中的`\\n`。<br />`<CR>`是 U+000D，这个字符真正意义上的“回车”，在字符串中是`\\r`，在一部分 Windows 风格文本编辑器中，换行是两个字符`\\r\\n`。<br />`<LS>`是 U+2028，是 Unicode 中的行分隔符。`<PS>`是 U+2029，是 Unicode 中的段落分隔符。<br />大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。\n<a name=\"bd7c9a5e\"></a>\n### 注释 Comment\n**`JavaScript`**  的注释分为单行注释和多行注释两种：\n```javascript\n/* MultiLineCommentChars */ \n// SingleLineCommentChars\n```\n\n多行注释中允许自由地出现`MultiLineNotAsteriskChar`，也就是除了`*`之外的所有字符。而每一个`*`之后，不能出现正斜杠符`/`。<br />除了四种 LineTerminator 之外，所有字符都可以作为单行注释。<br />我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。\n<a name=\"b8fdb6b9\"></a>\n## 标识符名称 IdentifierName\n`IdentifierName`可以以美元符`$`下划线`_`或者 Unicode 字母开始，除了开始字符以外，`IdentifierName`中还可以使用 Unicode 中的连接标记、数字、以及连接符号。<br />`IdentifierName`的任意字符可以使用 JavaScript 的 Unicode 转义写法，使用 Unicode 转义写法时，没有任何字符限制。<br />`IdentifierName`可以是`Identifier`、`NullLiteral`、`BooleanLiteral`或者`keyword`，在`ObjectLiteral`中，`IdentifierName`还可以被直接当做属性名称使用。<br />仅当不是保留字的时候，`IdentifierName`会被解析为`Identifier`。<br />注意`<ZWNJ>`和`<ZWJ>`是 ES5 新加入的两个格式控制字符，它们都是 0 宽的。<br />我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有:\n```\nawait break case catch class const continue debugger default delete do else export extends finally for function if import ininstance of new return super switch this throw try typeof var void while with yield\n```\n\n除了上述的内容之外，还有 1 个为了未来使用而保留的关键字:\n```javascript\nenum\n```\n\n在严格模式下, 有一些额外的为未来使用而保留的关键字:\n```javascript\nimplements package protected interface private public\n```\n\n除了这些之外，`NullLiteral`（`null`）和`BooleanLiteral`（`true false`）也是保留字，不能用于`Identifier`。\n<a name=\"a9eaa3e7\"></a>\n### 符号 Punctuator\n因为前面提到的除法和正则问题, / 和 /= 两个运算符被拆分为 DivPunctuator，因为前面提到的字符串模板问题，`}`也被独立拆分。加在一起，所有符号为：\n```javascript\n{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= => / /= }\n```\n\n<a name=\"de68c116\"></a>\n### 数字直接量 NumericLiteral\n我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。<br />十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：\n```javascript\n.01\n12.\n12.01\n```\n\n这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码：\n```javascript\n12.toString()\n```\n\n这时候`12.` 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写：\n```javascript\n12 .toString()\n```\n\n数字直接量还支持科学计数法，例如：\n```javascript\n10.24E+2\n10.24e-2\n10.24e2\n```\n\n这里 e 后面的部分，只允许使用整数。当以`0x` `0b` 或者`0o` 开头时，表示特定进制的整数：\n```javascript\n0xFA\n0o73\n0b10000\n```\n\n上面这几种进制都不支持小数，也不支持科学计数法。\n<a name=\"0682a72a\"></a>\n### 字符串直接量 StringLiteral\nJavaScript 中的 StringLiteral 支持单引号和双引号两种写法。\n```javascript\n\" DoubleStringCharacters \"\n' SingleStringCharacters '\n```\n\n单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是`\\`和所有换行符。<br />JavaScript 中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。<br />第一种是单字符转义。 即一个反斜杠`\\`后面跟一个字符这种形式。<br />有特别意义的字符包括有`SingleEscapeCharacter`所定义的 9 种，见下表：<br />![](https://cdn.nlark.com/yuque/0/2019/png/221851/1556266072396-18746875-bc0c-4acd-ab05-c63f1f77854e.png#align=left&display=inline&height=568&originHeight=568&originWidth=574&size=0&status=done&width=574)<br />除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过`\\`转义后都是自身。\n<a name=\"65f39894\"></a>\n### 正则表达式直接量 RegularExpressionLiteral\n正则表达式由 Body 和 Flags 两部分组成，例如：\n```\n/RegularExpressionBody/g\n```\n\n其中 Body 部分至少有一个字符，第一个字符不能是 *（因为 /* 跟多行注释有词法冲突）.<br />正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。<br />正则表达式并非机械地见到`/`就停止，在正则表达式`[ ]`中的`/`就会被认为是普通字符。我们可以看一个例子：\n```javascript\n/[/]/.test(\"/\");\n```\n\n除了`\\`、`/` 和`[` 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。<br />用\\和一个非换行符可以组成一个转义，`[ ]`中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。<br />虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier 中合法的字符）序列在词法阶段都会被认为是合法的。\n<a name=\"3f17b162\"></a>\n### 字符串模板 Template\n从语法结构上，Template 是个整体，其中的 `${ }` 是并列关系。<br />但是实际上，在 JavaScript 词法中，包含 `${ }` 的 Template，是被拆开分析的，如：\n```javascript\n`a${b}c${d}e`\n```\n\n它在 JavaScript 中被认为是：\n```javascript\n`a${\nb\n}c${\nd\n}e`\n```\n\n它被拆成了五个部分：\n\n- ``a${` 这个被称为模板头\n- `}c${` 被称为模板中段\n- `}e`` 被称为模板尾\n- `b` 和 `d` 都是普通标识符\n\n实际上，这里的词法分析过程已经跟语法分析深度耦合了。<br />不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。<br />模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：\n```javascript\nfunction f(){\n    console.log(arguments);\n}\n\nvar a = \"world\"\nf`Hello ${a}!`; // [[\"Hello\", \"!\"], world]\n```\n\n模板字符串不需要关心大多数字符的转义，但是至少 `${` 和 ``` 还是需要处理的。<br />模板中的转义跟字符串几乎完全一样，都是使用 `\\`。\n<a name=\"biWD5\"></a>\n## 总结：\n**`JS`** 是允许直接写小数的，也就说 **`12.toString()`**  他无法分辨你是想要创建一个小数位为  **`toString()`** 的数 还是创建一个 12  然后调用 **`toString()`** 这种情况。也就说 JS里面的. 是拥有两种含义的 一种是小数点 一种是方法调用。 你可以试试 **`12..toString()`**  这样就可以消除这种歧义\n",
    "body_draft": "",
    "body_html": "<p>tags: [词法,转载]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><hr /><h2 id=\"Bv0tc\">前言</h2><p>一般来说，文法分成词法和语法两种。</p><p>词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。</p><p>从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。</p><h2 id=\"a4d3b02a\">概述</h2><p>我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类：</p><ul><li>WhiteSpace 空白字符</li><li>LineTerminator 换行符</li><li>Comment 注释</li><li>Token 词</li></ul><ul data-lake-indent=\"1\"><li>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。</li><li>Punctuator 符号，我们使用的运算符和大括号等符号。</li><li>NumericLiteral 数字直接量，就是我们写的数字。</li><li>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。</li><li>Template 字符串模板，用反引号<code>`</code> 括起来的直接量。</li></ul><p><br /></p><p>这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。</p><p><br /></p><p>首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。</p><p><br /></p><p>但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。</p><p><br /></p><p>JavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的：</p><pre data-lang=\"javascript\"><code>`Hello, ${name}`</code></pre><p><br /></p><p>理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。</p><p>是否允许“ } ”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义：</p><ul><li>InputElementDiv；</li><li>InputElementRegExp；</li><li>InputElementRegExpOrTemplateTail；</li><li>InputElementTemplateTail。</li></ul><p>为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为 CommonToken。</p><p>但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。</p><p>对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript 来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。</p><p>接下来我来给你详细介绍一下。</p><h3 id=\"97f64546\">空白符号 Whitespace</h3><p>说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。</p><ul><li><code>&lt;HT&gt;</code>(或称<code>&lt;TAB&gt;</code>) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \\t 。</li><li><code>&lt;VT&gt;</code>是 U+000B，也就是垂直方向的 TAB 符 \\v，这个字符在键盘上很难打出来，所以很少用到。</li><li><code>&lt;FF&gt;</code>是 U+000C，Form Feed，分页符，字符串直接量中写作 \\f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。</li><li><code>&lt;SP&gt;</code>是 U+0020，就是最普通的空格了。</li><li><code>&lt;NBSP&gt;</code>是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript 编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 <code>&amp;nbsp;</code> 最后生成的就是它了。</li><li><code>&lt;ZWNBSP&gt;</code>(旧称<code>&lt;BOM&gt;</code>) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF 格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。</li></ul><p><br /></p><p>此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1556267260565-70b7c36d-f773-4d4a-a4a7-f34d8307bb56.png#align=left&amp;display=inline&amp;height=575&amp;originHeight=575&amp;originWidth=399&amp;size=0&amp;status=done&amp;width=399\" style=\"max-width: 600px; width: 399px;\" /></p><p>很多公司的编码规范要求 JavaScript 源代码控制在 ASCII 范围内，那么，就只有<code>&lt;TAB&gt;</code> <code>&lt;VT&gt;</code> <code>&lt;FF&gt;</code> <code>&lt;SP&gt;</code> <code>&lt;NBSP&gt;</code>五种空白可用了。</p><h3 id=\"638bc508\">换行符 LineTerminator</h3><p>接下来我们来看看换行符，JavaScript 中只提供了 4 种字符作为换行符。</p><ul><li><code>&lt;LF&gt;</code></li><li><code>&lt;CR&gt;</code></li><li><code>&lt;LS&gt;</code></li><li><code>&lt;PS&gt;</code></li></ul><p>其中，<code>&lt;LF&gt;</code>是 U+000A，就是最正常换行符，在字符串中的<code>\\n</code>。</p><p><code>&lt;CR&gt;</code>是 U+000D，这个字符真正意义上的“回车”，在字符串中是<code>\\r</code>，在一部分 Windows 风格文本编辑器中，换行是两个字符<code>\\r\\n</code>。</p><p><code>&lt;LS&gt;</code>是 U+2028，是 Unicode 中的行分隔符。<code>&lt;PS&gt;</code>是 U+2029，是 Unicode 中的段落分隔符。</p><p>大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。</p><h3 id=\"bd7c9a5e\">注释 Comment</h3><p><strong><code>JavaScript</code></strong>  的注释分为单行注释和多行注释两种：</p><pre data-lang=\"javascript\"><code>/* MultiLineCommentChars */ \n// SingleLineCommentChars</code></pre><p><br /></p><p>多行注释中允许自由地出现<code>MultiLineNotAsteriskChar</code>，也就是除了<code>*</code>之外的所有字符。而每一个<code>*</code>之后，不能出现正斜杠符<code>/</code>。</p><p>除了四种 LineTerminator 之外，所有字符都可以作为单行注释。</p><p>我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。</p><h2 id=\"b8fdb6b9\">标识符名称 IdentifierName</h2><p><code>IdentifierName</code>可以以美元符<code>$</code>下划线<code>_</code>或者 Unicode 字母开始，除了开始字符以外，<code>IdentifierName</code>中还可以使用 Unicode 中的连接标记、数字、以及连接符号。</p><p><code>IdentifierName</code>的任意字符可以使用 JavaScript 的 Unicode 转义写法，使用 Unicode 转义写法时，没有任何字符限制。</p><p><code>IdentifierName</code>可以是<code>Identifier</code>、<code>NullLiteral</code>、<code>BooleanLiteral</code>或者<code>keyword</code>，在<code>ObjectLiteral</code>中，<code>IdentifierName</code>还可以被直接当做属性名称使用。</p><p>仅当不是保留字的时候，<code>IdentifierName</code>会被解析为<code>Identifier</code>。</p><p>注意<code>&lt;ZWNJ&gt;</code>和<code>&lt;ZWJ&gt;</code>是 ES5 新加入的两个格式控制字符，它们都是 0 宽的。</p><p>我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有:</p><pre><code>await break case catch class const continue debugger default delete do else export extends finally for function if import ininstance of new return super switch this throw try typeof var void while with yield</code></pre><p><br /></p><p>除了上述的内容之外，还有 1 个为了未来使用而保留的关键字:</p><pre data-lang=\"javascript\"><code>enum</code></pre><p><br /></p><p>在严格模式下, 有一些额外的为未来使用而保留的关键字:</p><pre data-lang=\"javascript\"><code>implements package protected interface private public</code></pre><p><br /></p><p>除了这些之外，<code>NullLiteral</code>（<code>null</code>）和<code>BooleanLiteral</code>（<code>true false</code>）也是保留字，不能用于<code>Identifier</code>。</p><h3 id=\"a9eaa3e7\">符号 Punctuator</h3><p>因为前面提到的除法和正则问题, / 和 /= 两个运算符被拆分为 DivPunctuator，因为前面提到的字符串模板问题，<code>}</code>也被独立拆分。加在一起，所有符号为：</p><pre data-lang=\"javascript\"><code>{ ( ) [ ] . ... ; , &lt; &gt; &lt;= &gt;= == != === !== + - * % ** ++ -- &lt;&lt; &gt;&gt; &gt;&gt;&gt; &amp; | ^ ! ~ &amp;&amp; || ? : = += -= *= %= **= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= &amp;= |= ^= =&gt; / /= }</code></pre><p><br /></p><h3 id=\"de68c116\">数字直接量 NumericLiteral</h3><p>我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。</p><p>十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：</p><pre data-lang=\"javascript\"><code>.01\n12.\n12.01</code></pre><p><br /></p><p>这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码：</p><pre data-lang=\"javascript\"><code>12.toString()</code></pre><p><br /></p><p>这时候<code>12.</code> 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写：</p><pre data-lang=\"javascript\"><code>12 .toString()</code></pre><p><br /></p><p>数字直接量还支持科学计数法，例如：</p><pre data-lang=\"javascript\"><code>10.24E+2\n10.24e-2\n10.24e2</code></pre><p><br /></p><p>这里 e 后面的部分，只允许使用整数。当以<code>0x</code> <code>0b</code> 或者<code>0o</code> 开头时，表示特定进制的整数：</p><pre data-lang=\"javascript\"><code>0xFA\n0o73\n0b10000</code></pre><p><br /></p><p>上面这几种进制都不支持小数，也不支持科学计数法。</p><h3 id=\"0682a72a\">字符串直接量 StringLiteral</h3><p>JavaScript 中的 StringLiteral 支持单引号和双引号两种写法。</p><pre data-lang=\"javascript\"><code>&quot; DoubleStringCharacters &quot;\n' SingleStringCharacters '</code></pre><p><br /></p><p>单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是<code>\\</code>和所有换行符。</p><p>JavaScript 中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。</p><p>第一种是单字符转义。 即一个反斜杠<code>\\</code>后面跟一个字符这种形式。</p><p>有特别意义的字符包括有<code>SingleEscapeCharacter</code>所定义的 9 种，见下表：</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1556266072396-18746875-bc0c-4acd-ab05-c63f1f77854e.png#align=left&amp;display=inline&amp;height=568&amp;originHeight=568&amp;originWidth=574&amp;size=0&amp;status=done&amp;width=574\" style=\"max-width: 600px; width: 574px;\" /></p><p>除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过<code>\\</code>转义后都是自身。</p><h3 id=\"65f39894\">正则表达式直接量 RegularExpressionLiteral</h3><p>正则表达式由 Body 和 Flags 两部分组成，例如：</p><pre><code>/RegularExpressionBody/g</code></pre><p><br /></p><p>其中 Body 部分至少有一个字符，第一个字符不能是 *（因为 /* 跟多行注释有词法冲突）.</p><p>正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。</p><p>正则表达式并非机械地见到<code>/</code>就停止，在正则表达式<code>[ ]</code>中的<code>/</code>就会被认为是普通字符。我们可以看一个例子：</p><pre data-lang=\"javascript\"><code>/[/]/.test(&quot;/&quot;);</code></pre><p><br /></p><p>除了<code>\\</code>、<code>/</code> 和<code>[</code> 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。</p><p>用\\和一个非换行符可以组成一个转义，<code>[ ]</code>中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。</p><p>虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier 中合法的字符）序列在词法阶段都会被认为是合法的。</p><h3 id=\"3f17b162\">字符串模板 Template</h3><p>从语法结构上，Template 是个整体，其中的 <code>${ }</code> 是并列关系。</p><p>但是实际上，在 JavaScript 词法中，包含 <code>${ }</code> 的 Template，是被拆开分析的，如：</p><pre data-lang=\"javascript\"><code>`a${b}c${d}e`</code></pre><p><br /></p><p>它在 JavaScript 中被认为是：</p><pre data-lang=\"javascript\"><code>`a${\nb\n}c${\nd\n}e`</code></pre><p><br /></p><p>它被拆成了五个部分：</p><ul><li><code>`a${</code> 这个被称为模板头</li><li><code>}c${</code> 被称为模板中段</li><li><code>}e`</code> 被称为模板尾</li><li><code>b</code> 和 <code>d</code> 都是普通标识符</li></ul><p>实际上，这里的词法分析过程已经跟语法分析深度耦合了。</p><p>不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。</p><p>模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：</p><pre data-lang=\"javascript\"><code>function f(){\n    console.log(arguments);\n}\n\nvar a = &quot;world&quot;\nf`Hello ${a}!`; // [[&quot;Hello&quot;, &quot;!&quot;], world]</code></pre><p><br /></p><p>模板字符串不需要关心大多数字符的转义，但是至少 <code>${</code> 和 <code>`</code> 还是需要处理的。</p><p>模板中的转义跟字符串几乎完全一样，都是使用 <code>\\</code>。</p><h2 id=\"biWD5\">总结：</h2><p><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">JS</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\">是允许直接写小数的，也就说 </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">12.toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\"> 他无法分辨你是想要创建一个小数位为  </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\">的数 还是创建一个 12  然后调用 </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\">这种情况。也就说 JS里面的. 是拥有两种含义的 一种是小数点 一种是方法调用。 你可以试试 </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">12..toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\"> 这样就可以消除这种歧义</span></p>",
    "body_lake": "<!doctype lake><p>tags: [词法,转载]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22kI3vX%22%7D\"></card><h2 id=\"Bv0tc\">前言</h2><p>一般来说，文法分成词法和语法两种。<cursor /></p><p>词法规定了语言的最小语义单元：token，可以翻译成“标记”或者“词”，在我的专栏文章中，我统一把 token 翻译成词。</p><p>从字符到词的整个过程是没有结构的，只要符合词的规则，就构成词，一般来说，词法设计不会包含冲突。词法分析技术上可以使用状态机或者正则表达式来进行，我们的课程主要是学习词法，关于它们实现的细节就不多谈了。</p><h2 id=\"a4d3b02a\">概述</h2><p>我们先来看一看 JavaScript 的词法定义。JavaScript 源代码中的输入可以这样分类：</p><ul><li>WhiteSpace 空白字符</li><li>LineTerminator 换行符</li><li>Comment 注释</li><li>Token 词</li></ul><ul data-lake-indent=\"1\"><li>IdentifierName 标识符名称，典型案例是我们使用的变量名，注意这里关键字也包含在内了。</li><li>Punctuator 符号，我们使用的运算符和大括号等符号。</li><li>NumericLiteral 数字直接量，就是我们写的数字。</li><li>StringLiteral 字符串直接量，就是我们用单引号或者双引号引起来的直接量。</li><li>Template 字符串模板，用反引号<code>`</code> 括起来的直接量。</li></ul><p><br /></p><p>这个设计符合比较通用的编程语言设计方式，不过，JavaScript 中有一些特别之处，我下面就来讲讲特别在哪里。</p><p><br /></p><p>首先是除法和正则表达式冲突问题。我们都知道，JavaScript 不但支持除法运算符“ / ”和“ /= ”，还支持用斜杠括起来的正则表达式“ /abc/ ”。</p><p><br /></p><p>但是，这时候对词法分析来说，其实是没有办法处理的，所以 JavaScript 的解决方案是定义两组词法，然后靠语法分析传一个标志给词法分析器，让它来决定使用哪一套词法。</p><p><br /></p><p>JavaScript 词法的另一个特别设计是字符串模板，模板语法大概是这样的：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%60Hello%2C%20%24%7Bname%7D%60%22%2C%22id%22%3A%22JavaScript%22%7D\"></card><p><br /></p><p>理论上，“ ${ } ”内部可以放任何 JavaScript 表达式代码，而这些代码是以“ } ” 结尾的，也就是说，这部分词法不允许出现“ } ”运算符。</p><p>是否允许“ } ”的两种情况，与除法和正则表达式的两种情况相乘就是四种词法定义，所以你在 JavaScript 标准中，可以看到四种定义：</p><ul><li>InputElementDiv；</li><li>InputElementRegExp；</li><li>InputElementRegExpOrTemplateTail；</li><li>InputElementTemplateTail。</li></ul><p>为了解决这两个问题，标准中还不得不把除法、正则表达式直接量和“ } ”从 token 中单独抽出来，用词上，也把原本的 Token 改为 CommonToken。</p><p>但是我认为，从理解的角度上出发，我们不应该受到影响，所以在本课，我们依然把它们归类到 token 来理解。</p><p>对一般的语言的词法分析过程来说，都会丢弃除了 token 之外的输入，但是对 JavaScript 来说，不太一样，换行符和注释还会影响语法分析过程，这个我们将会在语法部分给你详细讲解（所以要实现 JavaScript 的解释器，词法分析和语法分析非常麻烦，需要来回传递信息）。</p><p>接下来我来给你详细介绍一下。</p><h3 id=\"97f64546\">空白符号 Whitespace</h3><p>说起空白符号，想必给大家留下的印象就是空格，但是实际上，JavaScript 可以支持更多空白符号。</p><ul><li><code>&lt;HT&gt;</code>(或称<code>&lt;TAB&gt;</code>) 是 U+0009，是缩进 TAB 符，也就是字符串中写的 \\t 。</li><li><code>&lt;VT&gt;</code>是 U+000B，也就是垂直方向的 TAB 符 \\v，这个字符在键盘上很难打出来，所以很少用到。</li><li><code>&lt;FF&gt;</code>是 U+000C，Form Feed，分页符，字符串直接量中写作 \\f ，现代已经很少有打印源程序的事情发生了，所以这个字符在 JavaScript 源代码中很少用到。</li><li><code>&lt;SP&gt;</code>是 U+0020，就是最普通的空格了。</li><li><code>&lt;NBSP&gt;</code>是 U+00A0，非断行空格，它是 SP 的一个变体，在文字排版中，可以避免因为空格在此处发生断行，其它方面和普通空格完全一样。多数的 JavaScript 编辑环境都会把它当做普通空格（因为一般源代码编辑环境根本就不会自动折行……）。HTML 中，很多人喜欢用的 <code>&amp;nbsp;</code> 最后生成的就是它了。</li><li><code>&lt;ZWNBSP&gt;</code>(旧称<code>&lt;BOM&gt;</code>) 是 U+FEFF，这是 ES5 新加入的空白符，是 Unicode 中的零宽非断行空格，在以 UTF 格式编码的文件中，常常在文件首插入一个额外的 U+FEFF，解析 UTF 文件的程序可以根据 U+FEFF 的表示方法猜测文件采用哪种 UTF 编码方式。这个字符也叫做“bit order mark”。</li></ul><p><br /></p><p>此外，JavaScript 支持所有的 Unicode 中的空格分类下的空格，我们可以看下表：</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1556267260565-70b7c36d-f773-4d4a-a4a7-f34d8307bb56.png%22%2C%22originWidth%22%3A399%2C%22originHeight%22%3A575%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A399%2C%22height%22%3A575%7D\"></card></p><p>很多公司的编码规范要求 JavaScript 源代码控制在 ASCII 范围内，那么，就只有<code>&lt;TAB&gt;</code> <code>&lt;VT&gt;</code> <code>&lt;FF&gt;</code> <code>&lt;SP&gt;</code> <code>&lt;NBSP&gt;</code>五种空白可用了。</p><h3 id=\"638bc508\">换行符 LineTerminator</h3><p>接下来我们来看看换行符，JavaScript 中只提供了 4 种字符作为换行符。</p><ul><li><code>&lt;LF&gt;</code></li><li><code>&lt;CR&gt;</code></li><li><code>&lt;LS&gt;</code></li><li><code>&lt;PS&gt;</code></li></ul><p>其中，<code>&lt;LF&gt;</code>是 U+000A，就是最正常换行符，在字符串中的<code>\\n</code>。</p><p><code>&lt;CR&gt;</code>是 U+000D，这个字符真正意义上的“回车”，在字符串中是<code>\\r</code>，在一部分 Windows 风格文本编辑器中，换行是两个字符<code>\\r\\n</code>。</p><p><code>&lt;LS&gt;</code>是 U+2028，是 Unicode 中的行分隔符。<code>&lt;PS&gt;</code>是 U+2029，是 Unicode 中的段落分隔符。</p><p>大部分 LineTerminator 在被词法分析器扫描出之后，会被语法分析器丢弃，但是换行符会影响 JavaScript 的两个重要语法特性：自动插入分号和“no line terminator”规则。</p><h3 id=\"bd7c9a5e\">注释 Comment</h3><p><strong><code>JavaScript</code></strong>  的注释分为单行注释和多行注释两种：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F*%20MultiLineCommentChars%20*%2F%20%5Cn%2F%2F%20SingleLineCommentChars%22%2C%22id%22%3A%22JavaScript-1%22%7D\"></card><p><br /></p><p>多行注释中允许自由地出现<code>MultiLineNotAsteriskChar</code>，也就是除了<code>*</code>之外的所有字符。而每一个<code>*</code>之后，不能出现正斜杠符<code>/</code>。</p><p>除了四种 LineTerminator 之外，所有字符都可以作为单行注释。</p><p>我们需要注意，多行注释中是否包含换行符号，会对 JavaScript 语法产生影响，对于“no line terminator”规则来说，带换行的多行注释与换行符是等效的。</p><h2 id=\"b8fdb6b9\">标识符名称 IdentifierName</h2><p><code>IdentifierName</code>可以以美元符<code>$</code>下划线<code>_</code>或者 Unicode 字母开始，除了开始字符以外，<code>IdentifierName</code>中还可以使用 Unicode 中的连接标记、数字、以及连接符号。</p><p><code>IdentifierName</code>的任意字符可以使用 JavaScript 的 Unicode 转义写法，使用 Unicode 转义写法时，没有任何字符限制。</p><p><code>IdentifierName</code>可以是<code>Identifier</code>、<code>NullLiteral</code>、<code>BooleanLiteral</code>或者<code>keyword</code>，在<code>ObjectLiteral</code>中，<code>IdentifierName</code>还可以被直接当做属性名称使用。</p><p>仅当不是保留字的时候，<code>IdentifierName</code>会被解析为<code>Identifier</code>。</p><p>注意<code>&lt;ZWNJ&gt;</code>和<code>&lt;ZWJ&gt;</code>是 ES5 新加入的两个格式控制字符，它们都是 0 宽的。</p><p>我在前面提到了，关键字也属于这个部分，在 JavaScript 中，关键字有:</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22await%20break%20case%20catch%20class%20const%20continue%20debugger%20default%20delete%20do%20else%20export%20extends%20finally%20for%20function%20if%20import%20ininstance%20of%20new%20return%20super%20switch%20this%20throw%20try%20typeof%20var%20void%20while%20with%20yield%22%2C%22id%22%3A%22undefined%22%7D\"></card><p><br /></p><p>除了上述的内容之外，还有 1 个为了未来使用而保留的关键字:</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22enum%22%2C%22id%22%3A%22undefined-1%22%7D\"></card><p><br /></p><p>在严格模式下, 有一些额外的为未来使用而保留的关键字:</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22implements%20package%20protected%20interface%20private%20public%22%2C%22id%22%3A%22undefined-2%22%7D\"></card><p><br /></p><p>除了这些之外，<code>NullLiteral</code>（<code>null</code>）和<code>BooleanLiteral</code>（<code>true false</code>）也是保留字，不能用于<code>Identifier</code>。</p><h3 id=\"a9eaa3e7\">符号 Punctuator</h3><p>因为前面提到的除法和正则问题, / 和 /= 两个运算符被拆分为 DivPunctuator，因为前面提到的字符串模板问题，<code>}</code>也被独立拆分。加在一起，所有符号为：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%7B%20(%20)%20%5B%20%5D%20.%20...%20%3B%20%2C%20%3C%20%3E%20%3C%3D%20%3E%3D%20%3D%3D%20!%3D%20%3D%3D%3D%20!%3D%3D%20%2B%20-%20*%20%25%20**%20%2B%2B%20--%20%3C%3C%20%3E%3E%20%3E%3E%3E%20%26%20%7C%20%5E%20!%20~%20%26%26%20%7C%7C%20%3F%20%3A%20%3D%20%2B%3D%20-%3D%20*%3D%20%25%3D%20**%3D%20%3C%3C%3D%20%3E%3E%3D%20%3E%3E%3E%3D%20%26%3D%20%7C%3D%20%5E%3D%20%3D%3E%20%2F%20%2F%3D%20%7D%22%2C%22id%22%3A%22undefined-3%22%7D\"></card><p><br /></p><h3 id=\"de68c116\">数字直接量 NumericLiteral</h3><p>我们来看看今天标题提出的问题，JavaScript 规范中规定的数字直接量可以支持四种写法：十进制数、二进制整数、八进制整数和十六进制整数。</p><p>十进制的 Number 可以带小数，小数点前后部分都可以省略，但是不能同时省略，我们看几个例子：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22.01%5Cn12.%5Cn12.01%22%2C%22id%22%3A%22javascript%22%7D\"></card><p><br /></p><p>这都是合法的数字直接量。这里就有一个问题，也是我们标题提出的问题，我们看一段代码：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%2212.toString()%22%2C%22id%22%3A%22javascript-1%22%7D\"></card><p><br /></p><p>这时候<code>12.</code> 会被当做省略了小数点后面部分的数字而看成一个整体，所以我们要想让点单独成为一个 token，就要加入空格，这样写：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%2212%20.toString()%22%2C%22id%22%3A%22javascript-2%22%7D\"></card><p><br /></p><p>数字直接量还支持科学计数法，例如：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%2210.24E%2B2%5Cn10.24e-2%5Cn10.24e2%22%2C%22id%22%3A%22javascript-3%22%7D\"></card><p><br /></p><p>这里 e 后面的部分，只允许使用整数。当以<code>0x</code> <code>0b</code> 或者<code>0o</code> 开头时，表示特定进制的整数：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%220xFA%5Cn0o73%5Cn0b10000%22%2C%22id%22%3A%22javascript-4%22%7D\"></card><p><br /></p><p>上面这几种进制都不支持小数，也不支持科学计数法。</p><h3 id=\"0682a72a\">字符串直接量 StringLiteral</h3><p>JavaScript 中的 StringLiteral 支持单引号和双引号两种写法。</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%5C%22%20DoubleStringCharacters%20%5C%22%5Cn'%20SingleStringCharacters%20'%22%2C%22id%22%3A%22JavaScript-2%22%7D\"></card><p><br /></p><p>单双引号的区别仅仅在于写法，在双引号字符串直接量中，双引号必须转义，在单引号字符串直接量中，单引号必须转义。字符串中其他必须转义的字符是<code>\\</code>和所有换行符。</p><p>JavaScript 中支持四种转义形式，还有一种虽然标准没有定义，但是大部分实现都支持的八进制转义。</p><p>第一种是单字符转义。 即一个反斜杠<code>\\</code>后面跟一个字符这种形式。</p><p>有特别意义的字符包括有<code>SingleEscapeCharacter</code>所定义的 9 种，见下表：</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1556266072396-18746875-bc0c-4acd-ab05-c63f1f77854e.png%22%2C%22originWidth%22%3A574%2C%22originHeight%22%3A568%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A574%2C%22height%22%3A568%7D\"></card></p><p>除了这 9 种字符、数字、x 和 u 以及所有的换行符之外，其它字符经过<code>\\</code>转义后都是自身。</p><h3 id=\"65f39894\">正则表达式直接量 RegularExpressionLiteral</h3><p>正则表达式由 Body 和 Flags 两部分组成，例如：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22plain%22%2C%22code%22%3A%22%2FRegularExpressionBody%2Fg%22%2C%22id%22%3A%22undefined-4%22%7D\"></card><p><br /></p><p>其中 Body 部分至少有一个字符，第一个字符不能是 *（因为 /* 跟多行注释有词法冲突）.</p><p>正则表达式有自己的语法规则，在词法阶段，仅会对它做简单解析。</p><p>正则表达式并非机械地见到<code>/</code>就停止，在正则表达式<code>[ ]</code>中的<code>/</code>就会被认为是普通字符。我们可以看一个例子：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%5B%2F%5D%2F.test(%5C%22%2F%5C%22)%3B%22%2C%22id%22%3A%22javascript-5%22%7D\"></card><p><br /></p><p>除了<code>\\</code>、<code>/</code> 和<code>[</code> 三个字符之外，JavaScript 正则表达式中的字符都是普通字符。</p><p>用\\和一个非换行符可以组成一个转义，<code>[ ]</code>中也支持转义。正则表达式中的 flag 在词法阶段不会限制字符。</p><p>虽然只有 ig 几个是有效的，但是任何 IdentifierPart（Identifier 中合法的字符）序列在词法阶段都会被认为是合法的。</p><h3 id=\"3f17b162\">字符串模板 Template</h3><p>从语法结构上，Template 是个整体，其中的 <code>${ }</code> 是并列关系。</p><p>但是实际上，在 JavaScript 词法中，包含 <code>${ }</code> 的 Template，是被拆开分析的，如：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%60a%24%7Bb%7Dc%24%7Bd%7De%60%22%2C%22id%22%3A%22javascript-6%22%7D\"></card><p><br /></p><p>它在 JavaScript 中被认为是：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%60a%24%7B%5Cnb%5Cn%7Dc%24%7B%5Cnd%5Cn%7De%60%22%2C%22id%22%3A%22undefined-5%22%7D\"></card><p><br /></p><p>它被拆成了五个部分：</p><ul><li><code>`a${</code> 这个被称为模板头</li><li><code>}c${</code> 被称为模板中段</li><li><code>}e`</code> 被称为模板尾</li><li><code>b</code> 和 <code>d</code> 都是普通标识符</li></ul><p>实际上，这里的词法分析过程已经跟语法分析深度耦合了。</p><p>不过我们学习的时候，大可不必按照标准和引擎工程师这样去理解，可以认为模板就是一个由反引号括起来的、可以在中间插入代码的字符串。</p><p>模板支持添加处理函数的写法，这时模板的各段会被拆开，传递给函数当参数：</p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20f()%7B%5Cn%20%20%20%20console.log(arguments)%3B%5Cn%7D%5Cn%5Cnvar%20a%20%3D%20%5C%22world%5C%22%5Cnf%60Hello%20%24%7Ba%7D!%60%3B%20%2F%2F%20%5B%5B%5C%22Hello%5C%22%2C%20%5C%22!%5C%22%5D%2C%20world%5D%22%2C%22id%22%3A%22javascript-7%22%7D\"></card><p><br /></p><p>模板字符串不需要关心大多数字符的转义，但是至少 <code>${</code> 和 <code>`</code> 还是需要处理的。</p><p>模板中的转义跟字符串几乎完全一样，都是使用 <code>\\</code>。</p><h2 id=\"biWD5\">总结：</h2><p><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">JS</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\">是允许直接写小数的，也就说 </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">12.toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\"> 他无法分辨你是想要创建一个小数位为  </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\">的数 还是创建一个 12  然后调用 </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\">这种情况。也就说 JS里面的. 是拥有两种含义的 一种是小数点 一种是方法调用。 你可以试试 </span><strong><code><span class=\"lake-fontsize-14\" style=\"color: #505050;\">12..toString()</span></code></strong> <span class=\"lake-fontsize-14\" style=\"color: #505050;\"> 这样就可以消除这种歧义</span></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T01:55:44.000Z",
    "deleted_at": null,
    "created_at": "2019-04-26T08:07:10.000Z",
    "updated_at": "2019-04-28T01:55:44.000Z",
    "published_at": "2019-04-28T01:55:44.000Z",
    "first_published_at": "2019-04-26T08:47:43.000Z",
    "word_count": 3131,
    "cover": null,
    "description": "tags: [词法,转载]categories: 重学前端系列笔记cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpe...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1599159,
    "slug": "okdtdg",
    "title": "无标题",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 16,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-26T08:36:13.562Z",
      "updated_at": "2019-04-26T08:36:13.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "",
    "body_draft": "",
    "body_html": "",
    "body_lake": "",
    "public": 1,
    "status": 0,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-26T08:03:56.000Z",
    "deleted_at": null,
    "created_at": "2019-04-26T08:03:56.000Z",
    "updated_at": "2019-04-26T08:03:56.000Z",
    "published_at": null,
    "first_published_at": null,
    "word_count": 0,
    "cover": null,
    "description": "",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1608269,
    "slug": "ogkvyi",
    "title": "16. javascript执行顺序",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 18,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-05-08T02:16:47.456Z",
      "updated_at": "2019-05-08T02:16:47.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-05-05T02:30:29.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-05-05T02:30:29.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [词法,转载]<br />categories: 重学前端系列笔记<br />cover: \"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg\"\n\n---\n<a name=\"UTtjo\"></a>\n## 前言\n当我们接到一段 **`JavaScript`** 代码的时候，传递给 **`JavaScript`** 引擎要求其执行。在遇到事件的时候，会继续将其中的一些事件代码交给 **`JavaScript`** 引擎执行，当然也会提供一些 **`API`** 给 **`JavaScript`** 引擎，这样的 **`API`** 允许引擎在特定时机执行某段代码。<br />我们可以理解为 **`JavaScript`** 引擎存在于内存中，它一直在运转，在等待着我们将 **`JavaScript`** 片段代码或者事件交给它进行执行处理，但是页面一般同时会有很多代码需要执行，那么就需要指定一个顺序。\n<a name=\"V4h8r\"></a>\n### 宏任务与微任务\n> 我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。\n\n**`JavaScript`** 引擎一直在等待着宿主分配宏观任务，这个等待分配，然后执行代码的过程，称之为 **`evenLoop`** \n```javascript\n// 伪代码表述简单的evenLoop\nwhile(true) {\n    r = wait(); // 等待宿主分配任务 \n    execute(r); // 分配任务之后，执行该任务\n}\n```\n当然在等待以及执行的时候，还有其他的过程，像是检查任务队列，判断任务是否达到执行时机，判断同步的上一个任务是不是执行完毕等等。<br />而宏任务的队列就是事件循环。而 **`JavaScript`** 在执行宏观任务的时候，如果这个任务是异步的， **`JavaScript`** 要保证异步代码在一个宏观任务中执行，那么宏观任务中就有微任务队列<br />有了宏任务以及微任务概念之后，就可以理解，引擎产生的任务会在任务尾部添加微任务。而宿主产生的任务会直接扔在宏任务内\n<a name=\"SF2yN\"></a>\n### promise\n```javascript\nvar promise = new Promise(function(resolve, reject){\n  console.log(\"a\");\n  resolve();\n})\npromise.then(function(){\n\tconsole.log(\"b\");\n});\nconsole.log(\"c\");\n// 打印的顺序是 acb;\n```\n上面的运行结果之所是 **`acb`** 是因为 **`new`** 一个构造函数，会执行构造函数内的函数，然后虽然 **`console.log(\"c\")`** 在 **`.then()`** 后面，但是因为 **`resolve()`** 是异步的。所以会先打印 **`c`** \n\n<a name=\"W2RMM\"></a>\n#### setTimeout与promise混合使用\n```javascript\nvar promise = new Promise(function(resolve, reject){\n     console.log(\"a\");\n      resolve()\n});\nsetTimeout(()=>console.log(\"d\"), 0)\npromise.then(() => console.log(\"c\"));\nconsole.log(\"b\")\n```\n上面的运行结果是 **`abcd`** ，代码从上向下扫射运行。先是运行 **`new`** 关键字的构造函数里的代码，打印 **`a`** ，遇到 **`resolve()`** 运行 **`.then`** 的代码，但是由于这个是异步的，所以就会继续往下运行代码， **`setTimeout`** 的代码会放在任务队列里。而事件队列里的代码会等主线程的代码运行完之后，才会检查事件队列。所以下一步打印的是 **`b`** ，然后由于 **`promise`** 是 **`JavaScript`** 引擎产生的微任务，而 **`setTimeout`** 是浏览器产生的宏任务，所有先打印 **`c`** 再打印 **`d`** \n<a name=\"ef8my\"></a>\n##### 微任务是永远优先于宏任务的\n```javascript\n    setTimeout(()=>console.log(\"d\"), 0)\n    var promise = new Promise(function(resolve, reject){\n        resolve()\n    });\n    promise.then(() => { \n        var begin = Date.now();\n        while(Date.now() - begin < 1000);\n        console.log(\"c1\") \n        new Promise(function(resolve, reject){\n            resolve()\n        }).then(() => console.log(\"c2\"))\n    });\n```\n上面的代码运行结果为 **`c1/c2/d`** \n<a name=\"GzHcm\"></a>\n### 由上面的两个示例可以得出\n\n- 先确定有多少个宏任务、\n- 然后确定每个宏任务里有多少个微任务\n- 根据调用的循序，确定每个微任务的执行顺序\n- 然后将整个的环境执行顺序确定下来\n",
    "body_draft": "",
    "body_html": "<p>tags: [词法,转载]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><hr /><h2 id=\"UTtjo\"><span style=\"background-color: transparent;\">前言</span></h2><p><span class=\"lake-fontsize-12\">当我们接到一段 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 代码的时候，传递给 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎要求其执行。在遇到事件的时候，会继续将其中的一些事件代码交给 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎执行，当然也会提供一些 </span><span class=\"lake-fontsize-12\"><strong><code>API</code></strong></span><span class=\"lake-fontsize-12\"> 给 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎，这样的 </span><span class=\"lake-fontsize-12\"><strong><code>API</code></strong></span><span class=\"lake-fontsize-12\"> 允许引擎在特定时机执行某段代码。</span></p><p><span class=\"lake-fontsize-12\">我们可以理解为 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎存在于内存中，它一直在运转，在等待着我们将 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 片段代码或者事件交给它进行执行处理，但是页面一般同时会有很多代码需要执行，那么就需要指定一个顺序。</span></p><h3 id=\"V4h8r\">宏任务与微任务</h3><blockquote><p><span class=\"lake-fontsize-14\">我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</span></p></blockquote><p><strong><code>JavaScript</code></strong> 引擎一直在等待着宿主分配宏观任务，这个等待分配，然后执行代码的过程，称之为 <strong><code>evenLoop</code></strong> </p><pre data-lang=\"javascript\"><code>// 伪代码表述简单的evenLoop\nwhile(true) {\n    r = wait(); // 等待宿主分配任务 \n    execute(r); // 分配任务之后，执行该任务\n}</code></pre><p><span class=\"lake-fontsize-12\">当然在等待以及执行的时候，还有其他的过程，像是检查任务队列，判断任务是否达到执行时机，判断同步的上一个任务是不是执行完毕等等。</span></p><p><span class=\"lake-fontsize-12\">而宏任务的队列就是事件循环。而 </span><strong><code><span class=\"lake-fontsize-12\">JavaScript</span></code></strong> <span class=\"lake-fontsize-12\">在执行宏观任务的时候，如果这个任务是异步的， </span><strong><code><span class=\"lake-fontsize-12\">JavaScript</span></code></strong> <span class=\"lake-fontsize-12\">要保证异步代码在一个宏观任务中执行，那么宏观任务中就有微任务队列</span></p><p><span class=\"lake-fontsize-12\">有了宏任务以及微任务概念之后，就可以理解，引擎产生的任务会在任务尾部添加微任务。而宿主产生的任务会直接扔在宏任务内</span></p><h3 id=\"SF2yN\">promise</h3><pre data-lang=\"javascript\"><code>var promise = new Promise(function(resolve, reject){\n  console.log(&quot;a&quot;);\n  resolve();\n})\npromise.then(function(){\n\tconsole.log(&quot;b&quot;);\n});\nconsole.log(&quot;c&quot;);\n// 打印的顺序是 acb;</code></pre><p>上面的运行结果之所是 <strong><code>acb</code></strong> 是因为 <strong><code>new</code></strong> 一个构造函数，会执行构造函数内的函数，然后虽然 <strong><code>console.log(&quot;c&quot;)</code></strong> 在 <strong><code>.then()</code></strong> 后面，但是因为 <strong><code>resolve()</code></strong> 是异步的。所以会先打印 <strong><code>c</code></strong> </p><p><br /></p><h4 id=\"W2RMM\">setTimeout与promise混合使用</h4><pre data-lang=\"javascript\"><code>var promise = new Promise(function(resolve, reject){\n     console.log(&quot;a&quot;);\n      resolve()\n});\nsetTimeout(()=&gt;console.log(&quot;d&quot;), 0)\npromise.then(() =&gt; console.log(&quot;c&quot;));\nconsole.log(&quot;b&quot;)</code></pre><p>上面的运行结果是 <strong><code>abcd</code></strong> ，代码从上向下扫射运行。先是运行 <strong><code>new</code></strong> 关键字的构造函数里的代码，打印 <strong><code>a</code></strong> ，遇到 <strong><code>resolve()</code></strong> 运行 <strong><code>.then</code></strong> 的代码，但是由于这个是异步的，所以就会继续往下运行代码， <strong><code>setTimeout</code></strong> 的代码会放在任务队列里。而事件队列里的代码会等主线程的代码运行完之后，才会检查事件队列。所以下一步打印的是 <strong><code>b</code></strong> ，然后由于 <strong><code>promise</code></strong> 是 <strong><code>JavaScript</code></strong> 引擎产生的微任务，而 <strong><code>setTimeout</code></strong> 是浏览器产生的宏任务，所有先打印 <strong><code>c</code></strong> 再打印 <strong><code>d</code></strong> </p><h5 id=\"ef8my\">微任务是永远优先于宏任务的</h5><pre data-lang=\"javascript\"><code>    setTimeout(()=&gt;console.log(&quot;d&quot;), 0)\n    var promise = new Promise(function(resolve, reject){\n        resolve()\n    });\n    promise.then(() =&gt; { \n        var begin = Date.now();\n        while(Date.now() - begin &lt; 1000);\n        console.log(&quot;c1&quot;) \n        new Promise(function(resolve, reject){\n            resolve()\n        }).then(() =&gt; console.log(&quot;c2&quot;))\n    });</code></pre><p>上面的代码运行结果为 <strong><code>c1/c2/d</code></strong> </p><h3 id=\"GzHcm\">由上面的两个示例可以得出</h3><ul><li>先确定有多少个宏任务、</li><li>然后确定每个宏任务里有多少个微任务</li><li><span>根据调用的循序，确定每个微任务的执行顺序</span></li><li>然后将整个的环境执行顺序确定下来</li></ul>",
    "body_lake": "<!doctype lake><p>tags: [词法,转载]</p><p>categories: 重学前端系列笔记</p><p>cover: &quot;<span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg</span>&quot;</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22jbX6K%22%7D\"></card><h2 id=\"UTtjo\"><span style=\"background-color: transparent;\">前言</span></h2><p><span class=\"lake-fontsize-12\">当我们接到一段 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 代码的时候，传递给 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎要求其执行。在遇到事件的时候，会继续将其中的一些事件代码交给 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎执行，当然也会提供一些 </span><span class=\"lake-fontsize-12\"><strong><code>API</code></strong></span><span class=\"lake-fontsize-12\"> 给 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎，这样的 </span><span class=\"lake-fontsize-12\"><strong><code>API</code></strong></span><span class=\"lake-fontsize-12\"> 允许引擎在特定时机执行某段代码。</span></p><p><span class=\"lake-fontsize-12\">我们可以理解为 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 引擎存在于内存中，它一直在运转，在等待着我们将 </span><span class=\"lake-fontsize-12\"><strong><code>JavaScript</code></strong></span><span class=\"lake-fontsize-12\"> 片段代码或者事件交给它进行执行处理，但是页面一般同时会有很多代码需要执行，那么就需要指定一个顺序。</span></p><h3 id=\"V4h8r\">宏任务与微任务</h3><blockquote><p><span class=\"lake-fontsize-14\">我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</span></p></blockquote><p><strong><code>JavaScript</code></strong> 引擎一直在等待着宿主分配宏观任务，这个等待分配，然后执行代码的过程，称之为 <strong><code>evenLoop</code></strong> </p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E4%BC%AA%E4%BB%A3%E7%A0%81%E8%A1%A8%E8%BF%B0%E7%AE%80%E5%8D%95%E7%9A%84evenLoop%5Cnwhile(true)%20%7B%5Cn%20%20%20%20r%20%3D%20wait()%3B%20%2F%2F%20%E7%AD%89%E5%BE%85%E5%AE%BF%E4%B8%BB%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%20%5Cn%20%20%20%20execute(r)%3B%20%2F%2F%20%E5%88%86%E9%85%8D%E4%BB%BB%E5%8A%A1%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%89%A7%E8%A1%8C%E8%AF%A5%E4%BB%BB%E5%8A%A1%5Cn%7D%22%2C%22id%22%3A%22Y7fD2%22%7D\"></card><p><span class=\"lake-fontsize-12\">当然在等待以及执行的时候，还有其他的过程，像是检查任务队列，判断任务是否达到执行时机，判断同步的上一个任务是不是执行完毕等等。</span></p><p><span class=\"lake-fontsize-12\">而宏任务的队列就是事件循环。而 </span><strong><code><span class=\"lake-fontsize-12\">JavaScript</span></code></strong> <span class=\"lake-fontsize-12\">在执行宏观任务的时候，如果这个任务是异步的， </span><strong><code><span class=\"lake-fontsize-12\">JavaScript</span></code></strong> <span class=\"lake-fontsize-12\">要保证异步代码在一个宏观任务中执行，那么宏观任务中就有微任务队列</span></p><p><span class=\"lake-fontsize-12\">有了宏任务以及微任务概念之后，就可以理解，引擎产生的任务会在任务尾部添加微任务。而宿主产生的任务会直接扔在宏任务内</span></p><h3 id=\"SF2yN\">promise</h3><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20promise%20%3D%20new%20Promise(function(resolve%2C%20reject)%7B%5Cn%20%20console.log(%5C%22a%5C%22)%3B%5Cn%20%20resolve()%3B%5Cn%7D)%5Cnpromise.then(function()%7B%5Cn%5Ctconsole.log(%5C%22b%5C%22)%3B%5Cn%7D)%3B%5Cnconsole.log(%5C%22c%5C%22)%3B%5Cn%2F%2F%20%E6%89%93%E5%8D%B0%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%98%AF%20acb%3B%22%2C%22id%22%3A%227HCpg%22%7D\"></card><p>上面的运行结果之所是 <strong><code>acb</code></strong> 是因为 <strong><code>new</code></strong> 一个构造函数，会执行构造函数内的函数，然后虽然 <strong><code>console.log(&quot;c&quot;)</code></strong> 在 <strong><code>.then()</code></strong> 后面，但是因为 <strong><code>resolve()</code></strong> 是异步的。所以会先打印 <strong><code>c</code></strong> </p><p><br /></p><h4 id=\"W2RMM\">setTimeout与promise混合使用</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20promise%20%3D%20new%20Promise(function(resolve%2C%20reject)%7B%5Cn%20%20%20%20%20console.log(%5C%22a%5C%22)%3B%5Cn%20%20%20%20%20%20resolve()%5Cn%7D)%3B%5CnsetTimeout(()%3D%3Econsole.log(%5C%22d%5C%22)%2C%200)%5Cnpromise.then(()%20%3D%3E%20console.log(%5C%22c%5C%22))%3B%5Cnconsole.log(%5C%22b%5C%22)%22%2C%22id%22%3A%22yAnp3%22%7D\"></card><p>上面的运行结果是 <strong><code>abcd</code></strong> ，代码从上向下扫射运行。先是运行 <strong><code>new</code></strong> 关键字的构造函数里的代码，打印 <strong><code>a</code></strong> ，遇到 <strong><code>resolve()</code></strong> 运行 <strong><code>.then</code></strong> 的代码，但是由于这个是异步的，所以就会继续往下运行代码， <strong><code>setTimeout</code></strong> 的代码会放在任务队列里。而事件队列里的代码会等主线程的代码运行完之后，才会检查事件队列。所以下一步打印的是 <strong><code>b</code></strong> ，然后由于 <strong><code>promise</code></strong> 是 <strong><code>JavaScript</code></strong> 引擎产生的微任务，而 <strong><code>setTimeout</code></strong> 是浏览器产生的宏任务，所有先打印 <strong><code>c</code></strong> 再打印 <strong><code>d</code></strong> </p><h5 id=\"ef8my\">微任务是永远优先于宏任务的</h5><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20%20%20%20setTimeout(()%3D%3Econsole.log(%5C%22d%5C%22)%2C%200)%5Cn%20%20%20%20var%20promise%20%3D%20new%20Promise(function(resolve%2C%20reject)%7B%5Cn%20%20%20%20%20%20%20%20resolve()%5Cn%20%20%20%20%7D)%3B%5Cn%20%20%20%20promise.then(()%20%3D%3E%20%7B%20%5Cn%20%20%20%20%20%20%20%20var%20begin%20%3D%20Date.now()%3B%5Cn%20%20%20%20%20%20%20%20while(Date.now()%20-%20begin%20%3C%201000)%3B%5Cn%20%20%20%20%20%20%20%20console.log(%5C%22c1%5C%22)%20%5Cn%20%20%20%20%20%20%20%20new%20Promise(function(resolve%2C%20reject)%7B%5Cn%20%20%20%20%20%20%20%20%20%20%20%20resolve()%5Cn%20%20%20%20%20%20%20%20%7D).then(()%20%3D%3E%20console.log(%5C%22c2%5C%22))%5Cn%20%20%20%20%7D)%3B%22%2C%22id%22%3A%22wQMga%22%7D\"></card><p>上面的代码运行结果为 <strong><code>c1/c2/d</code></strong> </p><h3 id=\"GzHcm\">由上面的两个示例可以得出</h3><ul><li>先确定有多少个宏任务、</li><li>然后确定每个宏任务里有多少个微任务<cursor /></li><li><span>根据调用的循序，确定每个微任务的执行顺序</span></li><li>然后将整个的环境执行顺序确定下来</li></ul>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-05-08T02:16:47.000Z",
    "deleted_at": null,
    "created_at": "2019-04-28T03:46:22.000Z",
    "updated_at": "2019-05-08T02:16:47.000Z",
    "published_at": "2019-05-08T02:16:47.000Z",
    "first_published_at": "2019-04-28T09:55:55.000Z",
    "word_count": 934,
    "cover": null,
    "description": "tags: [词法,转载]categories: 重学前端系列笔记cover: &quot;https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpe...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1612680,
    "slug": "uquqqh",
    "title": "观影随想",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点\n个人博客网站 https://wuxin.netlify.com  欢迎来嫖",
      "creator_id": 221851,
      "public": 1,
      "items_count": 18,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-28T10:05:43.849Z",
      "updated_at": "2019-04-28T10:05:43.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-17T08:46:13.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2019/png/221851/1555490772513-avatar/b839376d-2e96-4b39-b872-b525f8879a96.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-17T08:46:13.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "title: 观影随想<br />date: 2019-4-21<br />categories: 个人杂记<br />cover: https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445747414-e3cc34cb-3efe-44e4-83c6-2d203bf9a5a3.jpeg<br />tags:\n\n- 无\n\npassword:\n\n- 8b269a355119aab55807687de32e16d2c77592a10e3006139661ce5c4483c262\n\nlock: true\n\n---\n最近追完了一下金庸同名小说改编的《连城诀》，里面通过梁元帝藏匿的宝藏为主线，引出了各种人性思考<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648196-1e66b2a6-9744-480c-8d6d-85890ec48778.jpeg#align=left&display=inline&height=720&originHeight=720&originWidth=1280&size=0&status=done&width=1280)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445649795-01a60dae-7c6b-48c5-af28-dad3a617d81e.jpeg#align=left&display=inline&height=720&originHeight=720&originWidth=1280&size=0&status=done&width=1280)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648364-4ff2a6e5-4f5d-4c9a-a875-1d5594785ba5.jpeg#align=left&display=inline&height=720&originHeight=720&originWidth=1280&size=0&status=done&width=1280)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445649028-260d3948-42e7-4932-aa01-2151b823108a.jpeg#align=left&display=inline&height=720&originHeight=720&originWidth=1280&size=0&status=done&width=1280)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648205-915f568d-0ba6-42e6-b3ca-b2ad600444da.jpeg#align=left&display=inline&height=720&originHeight=720&originWidth=1280&size=0&status=done&width=1280)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445649777-351dbe98-ae8e-4dfc-aa54-ff154942f66e.jpeg#align=left&display=inline&height=720&originHeight=720&originWidth=1280&size=0&status=done&width=1280)<br />![](https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648325-e4c93993-3091-47c8-a7cb-fa7d5a42fada.jpeg#align=left&display=inline&height=720&originHeight=720&originWidth=1280&size=0&status=done&width=1280)\n\n- 世上最是人心贪\n- 凡事未了又来了，难以不了了之啊<br />\n\n",
    "body_draft": "",
    "body_html": "<p>title: 观影随想</p><p>date: 2019-4-21</p><p>categories: 个人杂记</p><p>cover: <span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445747414-e3cc34cb-3efe-44e4-83c6-2d203bf9a5a3.jpeg</span></p><p>tags:</p><ul><li>无</li></ul><p>password:</p><ul><li>8b269a355119aab55807687de32e16d2c77592a10e3006139661ce5c4483c262</li></ul><p>lock: true</p><hr /><p>最近追完了一下金庸同名小说改编的《连城诀》，里面通过梁元帝藏匿的宝藏为主线，引出了各种人性思考</p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648196-1e66b2a6-9744-480c-8d6d-85890ec48778.jpeg#align=left&amp;display=inline&amp;height=720&amp;originHeight=720&amp;originWidth=1280&amp;size=0&amp;status=done&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445649795-01a60dae-7c6b-48c5-af28-dad3a617d81e.jpeg#align=left&amp;display=inline&amp;height=720&amp;originHeight=720&amp;originWidth=1280&amp;size=0&amp;status=done&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648364-4ff2a6e5-4f5d-4c9a-a875-1d5594785ba5.jpeg#align=left&amp;display=inline&amp;height=720&amp;originHeight=720&amp;originWidth=1280&amp;size=0&amp;status=done&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445649028-260d3948-42e7-4932-aa01-2151b823108a.jpeg#align=left&amp;display=inline&amp;height=720&amp;originHeight=720&amp;originWidth=1280&amp;size=0&amp;status=done&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648205-915f568d-0ba6-42e6-b3ca-b2ad600444da.jpeg#align=left&amp;display=inline&amp;height=720&amp;originHeight=720&amp;originWidth=1280&amp;size=0&amp;status=done&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445649777-351dbe98-ae8e-4dfc-aa54-ff154942f66e.jpeg#align=left&amp;display=inline&amp;height=720&amp;originHeight=720&amp;originWidth=1280&amp;size=0&amp;status=done&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><p><img src=\"https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445648325-e4c93993-3091-47c8-a7cb-fa7d5a42fada.jpeg#align=left&amp;display=inline&amp;height=720&amp;originHeight=720&amp;originWidth=1280&amp;size=0&amp;status=done&amp;width=1280\" style=\"max-width: 600px; width: 1280px;\" /></p><p><br /></p><ul><li>世上最是人心贪</li><li>凡事未了又来了，难以不了了之啊<br /></li></ul><p><br /></p>",
    "body_lake": "<!doctype lake><p>title: 观影随想</p><p>date: 2019-4-21<cursor /></p><p>categories: 个人杂记</p><p>cover: <span class=\"lake-fontsize-10\" style=\"color: #222222;\">https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445747414-e3cc34cb-3efe-44e4-83c6-2d203bf9a5a3.jpeg</span></p><p>tags:</p><ul><li>无</li></ul><p>password:</p><ul><li>8b269a355119aab55807687de32e16d2c77592a10e3006139661ce5c4483c262</li></ul><p>lock: true</p><card type=\"block\" name=\"hr\" value=\"data:%7B%22id%22%3A%22et6ii%22%7D\"></card><p>最近追完了一下金庸同名小说改编的《连城诀》，里面通过梁元帝藏匿的宝藏为主线，引出了各种人性思考</p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F221851%2F1556445648196-1e66b2a6-9744-480c-8d6d-85890ec48778.jpeg%22%2C%22originWidth%22%3A1280%2C%22originHeight%22%3A720%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1280%2C%22height%22%3A720%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F221851%2F1556445649795-01a60dae-7c6b-48c5-af28-dad3a617d81e.jpeg%22%2C%22originWidth%22%3A1280%2C%22originHeight%22%3A720%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1280%2C%22height%22%3A720%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F221851%2F1556445648364-4ff2a6e5-4f5d-4c9a-a875-1d5594785ba5.jpeg%22%2C%22originWidth%22%3A1280%2C%22originHeight%22%3A720%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1280%2C%22height%22%3A720%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F221851%2F1556445649028-260d3948-42e7-4932-aa01-2151b823108a.jpeg%22%2C%22originWidth%22%3A1280%2C%22originHeight%22%3A720%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1280%2C%22height%22%3A720%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F221851%2F1556445648205-915f568d-0ba6-42e6-b3ca-b2ad600444da.jpeg%22%2C%22originWidth%22%3A1280%2C%22originHeight%22%3A720%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1280%2C%22height%22%3A720%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F221851%2F1556445649777-351dbe98-ae8e-4dfc-aa54-ff154942f66e.jpeg%22%2C%22originWidth%22%3A1280%2C%22originHeight%22%3A720%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1280%2C%22height%22%3A720%7D\"></card></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fjpeg%2F221851%2F1556445648325-e4c93993-3091-47c8-a7cb-fa7d5a42fada.jpeg%22%2C%22originWidth%22%3A1280%2C%22originHeight%22%3A720%2C%22size%22%3A0%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A1280%2C%22height%22%3A720%7D\"></card></p><p><br /></p><ul><li>世上最是人心贪</li><li>凡事未了又来了，难以不了了之啊<br /></li></ul><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-28T10:04:53.000Z",
    "deleted_at": null,
    "created_at": "2019-04-28T10:00:40.000Z",
    "updated_at": "2019-04-28T10:04:53.000Z",
    "published_at": "2019-04-28T10:04:53.000Z",
    "first_published_at": "2019-04-28T10:03:53.000Z",
    "word_count": 101,
    "cover": null,
    "description": "title: 观影随想date: 2019-4-21categories: 个人杂记cover: https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1556445747414-e3cc34cb-3efe-44e4-83c6-2d203bf9a5a3....",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  }
]