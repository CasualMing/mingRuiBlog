[
  {
    "id": 1486157,
    "slug": "ql82hg",
    "title": "7. 浏览器是如何解析代码构建DOM树",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [解析构建Dom树过程]<br />\ncategories: 重学前端系列笔记<br />---------------\n\n浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？<br />\n![dom.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554713541318-2b1f1852-9f7c-4d9e-a65e-104554a4d764.png#align=left&display=inline&height=279&name=dom.png&originHeight=279&originWidth=732&size=7377&status=done&width=732)\n<a name=\"d9457fa5\"></a>\n### 解析代码\n<a name=\"ebf465eb\"></a>\n#### 词（token）拆分\n\n```html\n<p class=\"a\">text text text</p>\n```\n\n如果把整个标签当做一个词来解析。那么就会很大，因为内部可以进行嵌套，所以：\n\n* **<p :**“标签开始”的开始；\n* **class=\"a\" :** 属性；\n* **>**  ：“标签开始”的结束；\n* **text text text   :** 文本；\n* **</p>** ：标签结束。\n\n![f98444aa3ea7471d2414dd7d0f5e3a84.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554716167971-678c95cc-a83c-4e81-acf9-cca7834bfa46.png#align=left&display=inline&height=232&name=f98444aa3ea7471d2414dd7d0f5e3a84.png&originHeight=252&originWidth=624&size=25083&status=done&width=574)\n\n> 当我们通过http协议，获得一串字符流时，从接受的第一个字符开始解析，当遇到 **`<`** 的时候。判断出这是标签文本，然后再读一个 **`xx`** ，就可以判断这不是个注释节点，然后再读取 **`xx =\"xxx\"`** ，就可以将其解析为该标签的属性。当碰到 **`/>`** 就可以判断出，这个标签解析结束。可以将其展现。\n\n\n<a name=\"3a5d8e29\"></a>\n#### 状态机\n上面解析每解析一个字符，都要做一次决策。而每一次决策就要涉及到**状态机**，这就引来了另一个问题，状态机是什么？\n<a name=\"81b512f5\"></a>\n##### 状态机是什么？\n其实，绝大多数的语言的词法部分是使用**状态机**实现的，下面是一个**词**解析过程，画成**状态机<br />![8b43d598bc1f83a8a1e7e8f922013ab0.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554779834110-f769f2e5-d1f1-4dcd-b806-7e45ac6aee42.png#align=left&display=inline&height=718&name=8b43d598bc1f83a8a1e7e8f922013ab0.png&originHeight=739&originWidth=768&size=48178&status=done&width=746)**<br />**完整的状态机可以参照 **[**HTML官方词法状态机解析**](https://html.spec.whatwg.org/multipage/parsing.html#tokenization)\n\n状态机解析过程：<br />**初始部分：**\n* 只区分 **`<`**`非>`**`<`**`非<`**  就进入文本状态\n\n**进入标签状态之后：**\n* 如果下一个字符是 \"！\"，那么就进入到了注释节点状态或者 CDATA节点\n* 如果下一个字符是 \"/ \"，那么就进入标签结束状态\n* 如果下一个字符是一个字母。那么进入标签解析开始的状态\n* 如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。\n\n其实用状态机做词法解析，只是将各种特征字符拆分成单独状态，然后通过判断单独的状态，最终连成图结构输出。我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。\n\n```javascript\nvar data = function(c){\n    if(c===\"&\") {\n        return characterReferenceInData;\n    }\n    if(c===\"<\") {\n        return tagOpen;\n    }\n    else if(c===\"\\0\") {\n        error();\n        emitToken(c);\n        return data;\n    }\n    else if(c===EOF) {\n        emitToken(EOF);\n        return data;\n    }\n    else {\n        emitToken(c);\n        return data;\n    }\n};\nvar tagOpenState = function tagOpenState(c){\n    if(c===\"/\") {\n        return endTagOpenState;\n    }\n    if(c.match(/[A-Z]/)) {\n        token = new StartTagToken();\n        token.name = c.toLowerCase();\n        return tagNameState;\n    }\n    if(c.match(/[a-z]/)) {\n        token = new StartTagToken();\n        token.name = c;\n        return tagNameState;\n    }\n    if(c===\"?\") {\n        return bogusCommentState;\n    }\n    else {\n        error();\n        return dataState;\n    }\n};\n//……\n```\n\n这里通过 **`if....else`** 来区分解析的字符来进行状态迁移。状态迁移其实就是当前状态的函数通过判断返回下一个字符的状态函数。\n\n```javascript\nvar state = data;\nvar char\nwhile(char = getInput())\n    state = state(char);\n```\n> 这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。\n> \n\n```javascript\nfunction HTMLLexicalParser(){\n    // 状态函数们……\n    function data() {\n        // ……\n    }\n    function tagOpen() {\n        // ……\n    }\n    // ……\n    var state = data;\n    this.receiveInput = function(char) {\n        state = state(char);\n    }\n}\n```\n\n<a name=\"ee86bc99\"></a>\n### 构建 `DOM` 树\n通过上面的词拆分进行解析。简单的词到后来的 **`DOM`** 树。整个过程是通过栈实现的。任何语言都有栈这个东西。\n* 栈顶元素就是当前节点；\n* 遇到属性，就添加到当前节点；\n* 遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；\n* 遇到注释节点，作为当前节点的子节点；\n* 遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；\n* 遇到 tag end 就出栈一个节点（还可以检查是否匹配）。\n\n```html\n<html maaa=a >\n    <head>\n        <title>cool</title>\n    </head>\n    <body>\n        <img src=\"a\" />\n    </body>\n</html>\n```\n\n![GIF.gif](https://cdn.nlark.com/yuque/0/2019/gif/221851/1554867046508-68bb4743-b838-408e-96f9-da392ee7c321.gif#align=left&display=inline&height=227&name=GIF.gif&originHeight=563&originWidth=1852&size=2376616&status=done&width=746)\n\n[GitHub上的HTML解析器](https://github.com/aimergenge/toy-html-parser)\n",
    "body_draft": "",
    "body_html": "<p>tags: [解析构建Dom树过程]<br />\ncategories: 重学前端系列笔记</p><p>---------------</p><p><br /></p><p>浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？</p><p><br /><img alt=\"dom.png\" title=\"dom.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554713541318-2b1f1852-9f7c-4d9e-a65e-104554a4d764.png#align=left&amp;display=inline&amp;height=279&amp;name=dom.png&amp;originHeight=279&amp;originWidth=732&amp;size=7377&amp;status=done&amp;width=732\" style=\"max-width: 600px; width: 732px;\" /></p><h3 id=\"d9457fa5\">解析代码</h3><h4 id=\"ebf465eb\">词（token）拆分</h4><p><br /></p><pre data-lang=\"html\"><code>&lt;p class=&quot;a&quot;&gt;text text text&lt;/p&gt;</code></pre><p><br /></p><p>如果把整个标签当做一个词来解析。那么就会很大，因为内部可以进行嵌套，所以：</p><p><br /></p><ul><li><strong>&lt;p :</strong>“标签开始”的开始；</li><li><strong>class=&quot;a&quot; :</strong> 属性；</li><li><strong>&gt;</strong>  ：“标签开始”的结束；</li><li><strong>text text text   :</strong> 文本；</li><li><strong>&lt;/p&gt;</strong> ：标签结束。</li></ul><p><img alt=\"f98444aa3ea7471d2414dd7d0f5e3a84.png\" title=\"f98444aa3ea7471d2414dd7d0f5e3a84.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554716167971-678c95cc-a83c-4e81-acf9-cca7834bfa46.png#align=left&amp;display=inline&amp;height=232&amp;name=f98444aa3ea7471d2414dd7d0f5e3a84.png&amp;originHeight=252&amp;originWidth=624&amp;size=25083&amp;status=done&amp;width=574\" style=\"max-width: 600px; width: 574px;\" /></p><p><br /></p><blockquote><p><span class=\"lake-fontsize-12\">当我们通过http协议，获得一串字符流时，从接受的第一个字符开始解析，当遇到 </span><span class=\"lake-fontsize-12\"><strong><code>&lt;</code></strong></span><span class=\"lake-fontsize-12\"> 的时候。判断出这是标签文本，然后再读一个 </span><span class=\"lake-fontsize-12\"><strong><code>xx</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以判断这不是个注释节点，然后再读取 </span><span class=\"lake-fontsize-12\"><strong><code>xx =&quot;xxx&quot;</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以将其解析为该标签的属性。当碰到 </span><span class=\"lake-fontsize-12\"><strong><code>/&gt;</code></strong></span><span class=\"lake-fontsize-12\"> 就可以判断出，这个标签解析结束。可以将其展现。</span></p></blockquote><p><br /></p><h4 id=\"3a5d8e29\">状态机</h4><p>上面解析每解析一个字符，都要做一次决策。而每一次决策就要涉及到<strong>状态机</strong>，这就引来了另一个问题，状态机是什么？</p><h5 id=\"81b512f5\">状态机是什么？</h5><p>其实，绝大多数的语言的词法部分是使用<strong>状态机</strong>实现的，下面是一个<strong>词</strong>解析过程，画成<strong>状态机<br /><img alt=\"8b43d598bc1f83a8a1e7e8f922013ab0.png\" title=\"8b43d598bc1f83a8a1e7e8f922013ab0.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554779834110-f769f2e5-d1f1-4dcd-b806-7e45ac6aee42.png#align=left&amp;display=inline&amp;height=718&amp;name=8b43d598bc1f83a8a1e7e8f922013ab0.png&amp;originHeight=739&amp;originWidth=768&amp;size=48178&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></strong></p><p><strong>完整的状态机可以参照 </strong><a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\"><strong>HTML官方词法状态机解析</strong></a></p><p><br /></p><p>状态机解析过程：</p><p><span class=\"lake-fontsize-12\"><strong>初始部分：</strong></span></p><ul><li>只区分 <strong><code>&lt;</code></strong> 和 <strong><code>非&gt;</code></strong>  ，如果是 <strong><code>&lt;</code></strong> 可以进入标签状态，如果是 <strong><code>非&lt;</code></strong>  就进入文本状态</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\"><strong>进入标签状态之后：</strong></span></p><ul><li>如果下一个字符是 &quot;！&quot;，那么就进入到了注释节点状态或者 CDATA节点</li><li>如果<span>下一个字符是 &quot;/ &quot;，那么就进入标签结束状态</span></li><li>如果下一个字符是一个字母。那么进入标签解析开始的状态</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。</span></li></ul><p><br /></p><p><span class=\"lake-fontsize-14\">其实用状态机做词法解析，只是将各种特征字符拆分成单独状态，然后通过判断单独的状态，最终连成图结构输出。</span><span class=\"lake-fontsize-14\">我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。</span></p><p><br /></p><pre data-lang=\"javascript\"><code>var data = function(c){\n    if(c===&quot;&amp;&quot;) {\n        return characterReferenceInData;\n    }\n    if(c===&quot;&lt;&quot;) {\n        return tagOpen;\n    }\n    else if(c===&quot;\\0&quot;) {\n        error();\n        emitToken(c);\n        return data;\n    }\n    else if(c===EOF) {\n        emitToken(EOF);\n        return data;\n    }\n    else {\n        emitToken(c);\n        return data;\n    }\n};\nvar tagOpenState = function tagOpenState(c){\n    if(c===&quot;/&quot;) {\n        return endTagOpenState;\n    }\n    if(c.match(/[A-Z]/)) {\n        token = new StartTagToken();\n        token.name = c.toLowerCase();\n        return tagNameState;\n    }\n    if(c.match(/[a-z]/)) {\n        token = new StartTagToken();\n        token.name = c;\n        return tagNameState;\n    }\n    if(c===&quot;?&quot;) {\n        return bogusCommentState;\n    }\n    else {\n        error();\n        return dataState;\n    }\n};\n//……</code></pre><p><br /></p><p>这里通过 <strong><code>if....else</code></strong> 来区分解析的字符来进行状态迁移。状态迁移其实就是当前状态的函数通过判断返回下一个字符的状态函数。</p><p><br /></p><pre data-lang=\"javascript\"><code>var state = data;\nvar char\nwhile(char = getInput())\n    state = state(char);</code></pre><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。</span></p><p><br /></p></blockquote><pre data-lang=\"javascript\"><code>function HTMLLexicalParser(){\n    // 状态函数们……\n    function data() {\n        // ……\n    }\n    function tagOpen() {\n        // ……\n    }\n    // ……\n    var state = data;\n    this.receiveInput = function(char) {\n        state = state(char);\n    }\n}</code></pre><p><br /></p><h3 id=\"ee86bc99\">构建 <code>DOM</code> 树</h3><p>通过上面的词拆分进行解析。简单的词到后来的 <strong><code>DOM</code></strong> 树。整个过程是通过栈实现的。任何语言都有栈这个东西。</p><ul><li>栈顶元素就是当前节点；</li><li>遇到属性，就添加到当前节点；</li><li>遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；</li><li>遇到注释节点，作为当前节点的子节点；</li><li>遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；</li><li>遇到 tag end 就出栈一个节点（还可以检查是否匹配）。</li><p><br /></p></ul><pre data-lang=\"html\"><code>&lt;html maaa=a &gt;\n    &lt;head&gt;\n        &lt;title&gt;cool&lt;/title&gt;\n    &lt;/head&gt;\n    &lt;body&gt;\n        &lt;img src=&quot;a&quot; /&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre><p><br /></p><p><img alt=\"GIF.gif\" title=\"GIF.gif\" src=\"https://cdn.nlark.com/yuque/0/2019/gif/221851/1554867046508-68bb4743-b838-408e-96f9-da392ee7c321.gif#align=left&amp;display=inline&amp;height=227&amp;name=GIF.gif&amp;originHeight=563&amp;originWidth=1852&amp;size=2376616&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /></p><p><br /></p><p><a href=\"https://github.com/aimergenge/toy-html-parser\" target=\"_blank\">GitHub上的HTML解析器</a></p>",
    "body_lake": "<!doctype lake><p>tags: [解析构建Dom树过程]<cursor /><br />\ncategories: 重学前端系列笔记</p><p>---------------</p><p><br /></p><p>浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？</p><p><br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554713541318-2b1f1852-9f7c-4d9e-a65e-104554a4d764.png%22%2C%22originWidth%22%3A732%2C%22originHeight%22%3A279%2C%22name%22%3A%22dom.png%22%2C%22size%22%3A7377%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A732%2C%22height%22%3A279%7D\"></card></p><h3 id=\"d9457fa5\">解析代码</h3><h4 id=\"ebf465eb\">词（token）拆分</h4><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cp%20class%3D%5C%22a%5C%22%3Etext%20text%20text%3C%2Fp%3E%22%2C%22id%22%3A%221KfpU%22%7D\"></card><p><br /></p><p>如果把整个标签当做一个词来解析。那么就会很大，因为内部可以进行嵌套，所以：</p><p><br /></p><ul><li><strong>&lt;p :</strong>“标签开始”的开始；</li><li><strong>class=&quot;a&quot; :</strong> 属性；</li><li><strong>&gt;</strong>  ：“标签开始”的结束；</li><li><strong>text text text   :</strong> 文本；</li><li><strong>&lt;/p&gt;</strong> ：标签结束。</li></ul><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554716167971-678c95cc-a83c-4e81-acf9-cca7834bfa46.png%22%2C%22originWidth%22%3A624%2C%22originHeight%22%3A252%2C%22name%22%3A%22f98444aa3ea7471d2414dd7d0f5e3a84.png%22%2C%22size%22%3A25083%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A574%2C%22height%22%3A232%7D\"></card></p><p><br /></p><blockquote><p><span class=\"lake-fontsize-12\">当我们通过http协议，获得一串字符流时，从接受的第一个字符开始解析，当遇到 </span><span class=\"lake-fontsize-12\"><strong><code>&lt;</code></strong></span><span class=\"lake-fontsize-12\"> 的时候。判断出这是标签文本，然后再读一个 </span><span class=\"lake-fontsize-12\"><strong><code>xx</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以判断这不是个注释节点，然后再读取 </span><span class=\"lake-fontsize-12\"><strong><code>xx =&quot;xxx&quot;</code></strong></span><span class=\"lake-fontsize-12\"> ，就可以将其解析为该标签的属性。当碰到 </span><span class=\"lake-fontsize-12\"><strong><code>/&gt;</code></strong></span><span class=\"lake-fontsize-12\"> 就可以判断出，这个标签解析结束。可以将其展现。</span></p></blockquote><p><br /></p><h4 id=\"3a5d8e29\">状态机</h4><p>上面解析每解析一个字符，都要做一次决策。而每一次决策就要涉及到<strong>状态机</strong>，这就引来了另一个问题，状态机是什么？</p><h5 id=\"81b512f5\">状态机是什么？</h5><p>其实，绝大多数的语言的词法部分是使用<strong>状态机</strong>实现的，下面是一个<strong>词</strong>解析过程，画成<strong>状态机<br /><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554779834110-f769f2e5-d1f1-4dcd-b806-7e45ac6aee42.png%22%2C%22originWidth%22%3A768%2C%22originHeight%22%3A739%2C%22name%22%3A%228b43d598bc1f83a8a1e7e8f922013ab0.png%22%2C%22size%22%3A48178%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A718%7D\"></card></strong></p><p><strong>完整的状态机可以参照 </strong><a href=\"https://html.spec.whatwg.org/multipage/parsing.html#tokenization\" target=\"_blank\"><strong>HTML官方词法状态机解析</strong></a></p><p><br /></p><p>状态机解析过程：</p><p><span class=\"lake-fontsize-12\"><strong>初始部分：</strong></span></p><ul><li>只区分 <strong><code>&lt;</code></strong> 和 <strong><code>非&gt;</code></strong>  ，如果是 <strong><code>&lt;</code></strong> 可以进入标签状态，如果是 <strong><code>非&lt;</code></strong>  就进入文本状态</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\"><strong>进入标签状态之后：</strong></span></p><ul><li>如果下一个字符是 &quot;！&quot;，那么就进入到了注释节点状态或者 CDATA节点</li><li>如果<span>下一个字符是 &quot;/ &quot;，那么就进入标签结束状态</span></li><li>如果下一个字符是一个字母。那么进入标签解析开始的状态</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">如果我们要完整处理各种 HTML 标准中定义的东西，那么还要考虑“ ? ”“% ”等内容。</span></li></ul><p><br /></p><p><span class=\"lake-fontsize-14\">其实用状态机做词法解析，只是将各种特征字符拆分成单独状态，然后通过判断单独的状态，最终连成图结构输出。</span><span class=\"lake-fontsize-14\">我们把每个函数当做一个状态，参数是接受的字符，返回值是下一个状态函数。</span></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20data%20%3D%20function(c)%7B%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%26%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20characterReferenceInData%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%3C%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20tagOpen%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20if(c%3D%3D%3D%5C%22%5C%5C0%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20error()%3B%5Cn%20%20%20%20%20%20%20%20emitToken(c)%3B%5Cn%20%20%20%20%20%20%20%20return%20data%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20if(c%3D%3D%3DEOF)%20%7B%5Cn%20%20%20%20%20%20%20%20emitToken(EOF)%3B%5Cn%20%20%20%20%20%20%20%20return%20data%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20emitToken(c)%3B%5Cn%20%20%20%20%20%20%20%20return%20data%3B%5Cn%20%20%20%20%7D%5Cn%7D%3B%5Cnvar%20tagOpenState%20%3D%20function%20tagOpenState(c)%7B%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%2F%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20endTagOpenState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c.match(%2F%5BA-Z%5D%2F))%20%7B%5Cn%20%20%20%20%20%20%20%20token%20%3D%20new%20StartTagToken()%3B%5Cn%20%20%20%20%20%20%20%20token.name%20%3D%20c.toLowerCase()%3B%5Cn%20%20%20%20%20%20%20%20return%20tagNameState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c.match(%2F%5Ba-z%5D%2F))%20%7B%5Cn%20%20%20%20%20%20%20%20token%20%3D%20new%20StartTagToken()%3B%5Cn%20%20%20%20%20%20%20%20token.name%20%3D%20c%3B%5Cn%20%20%20%20%20%20%20%20return%20tagNameState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20if(c%3D%3D%3D%5C%22%3F%5C%22)%20%7B%5Cn%20%20%20%20%20%20%20%20return%20bogusCommentState%3B%5Cn%20%20%20%20%7D%5Cn%20%20%20%20else%20%7B%5Cn%20%20%20%20%20%20%20%20error()%3B%5Cn%20%20%20%20%20%20%20%20return%20dataState%3B%5Cn%20%20%20%20%7D%5Cn%7D%3B%5Cn%2F%2F%E2%80%A6%E2%80%A6%22%2C%22id%22%3A%22pnqM1%22%7D\"></card><p><br /></p><p>这里通过 <strong><code>if....else</code></strong> 来区分解析的字符来进行状态迁移。状态迁移其实就是当前状态的函数通过判断返回下一个字符的状态函数。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22var%20state%20%3D%20data%3B%5Cnvar%20char%5Cnwhile(char%20%3D%20getInput())%5Cn%20%20%20%20state%20%3D%20state(char)%3B%22%2C%22id%22%3A%22u38mi%22%7D\"></card><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">这段代码的关键一句是“ state = state(char) ”，不论我们用何种方式来读取字符串流，我们都可以通过 state 来处理输入的字符流，这里用循环是一个示例，真实场景中，可能是来自 TCP 的输出流。</span></p><p><br /></p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20HTMLLexicalParser()%7B%5Cn%20%20%20%20%2F%2F%20%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0%E4%BB%AC%E2%80%A6%E2%80%A6%5Cn%20%20%20%20function%20data()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20%7D%5Cn%20%20%20%20function%20tagOpen()%20%7B%5Cn%20%20%20%20%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20%7D%5Cn%20%20%20%20%2F%2F%20%E2%80%A6%E2%80%A6%5Cn%20%20%20%20var%20state%20%3D%20data%3B%5Cn%20%20%20%20this.receiveInput%20%3D%20function(char)%20%7B%5Cn%20%20%20%20%20%20%20%20state%20%3D%20state(char)%3B%5Cn%20%20%20%20%7D%5Cn%7D%22%2C%22id%22%3A%229efNH%22%7D\"></card><p><br /></p><h3 id=\"ee86bc99\">构建 <code>DOM</code> 树</h3><p>通过上面的词拆分进行解析。简单的词到后来的 <strong><code>DOM</code></strong> 树。整个过程是通过栈实现的。任何语言都有栈这个东西。</p><ul><li>栈顶元素就是当前节点；</li><li>遇到属性，就添加到当前节点；</li><li>遇到文本节点，如果当前节点是文本节点，则跟文本节点合并，否则入栈成为当前节点的子节点；</li><li>遇到注释节点，作为当前节点的子节点；</li><li>遇到 tag start 就入栈一个节点，当前节点就是这个节点的父节点；</li><li>遇到 tag end 就出栈一个节点（还可以检查是否匹配）。</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Chtml%20maaa%3Da%20%3E%5Cn%20%20%20%20%3Chead%3E%5Cn%20%20%20%20%20%20%20%20%3Ctitle%3Ecool%3C%2Ftitle%3E%5Cn%20%20%20%20%3C%2Fhead%3E%5Cn%20%20%20%20%3Cbody%3E%5Cn%20%20%20%20%20%20%20%20%3Cimg%20src%3D%5C%22a%5C%22%20%2F%3E%5Cn%20%20%20%20%3C%2Fbody%3E%5Cn%3C%2Fhtml%3E%22%2C%22id%22%3A%22RFMZf%22%7D\"></card><p><br /></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fgif%2F221851%2F1554867046508-68bb4743-b838-408e-96f9-da392ee7c321.gif%22%2C%22originWidth%22%3A1852%2C%22originHeight%22%3A563%2C%22name%22%3A%22GIF.gif%22%2C%22size%22%3A2376616%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A227%7D\"></card></p><p><br /></p><p><a href=\"https://github.com/aimergenge/toy-html-parser\" target=\"_blank\">GitHub上的HTML解析器</a></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:58:18.000Z",
    "deleted_at": null,
    "created_at": "2019-04-08T08:48:39.000Z",
    "updated_at": "2019-04-11T09:58:18.000Z",
    "published_at": "2019-04-11T09:58:18.000Z",
    "first_published_at": "2019-04-08T08:49:47.000Z",
    "word_count": 1070,
    "cover": null,
    "description": "tags: [解析构建Dom树过程] categories: 重学前端系列笔记---------------浏览器在请求放在服务器端的代码之后，如果解析又如何渲染成dom树，展示在页面中呢？解析代码词（token）拆分&lt;p class=&quot;a&quot;&gt;text text...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1486155,
    "slug": "lssef8",
    "title": "8.文档排版布局",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [ 文档排版布局 ]<br />categories: 重学前端系列笔记<br />----------------------\n<a name=\"9243ba6c\"></a>\n### 浏览器默认排版 - 正常流\n> 浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样\n\n<br /><br />浏览器默认的文字排版规则：规定了**行模型及文字在行模型中的排版。**行模型中规定了，文字的**行顶、行底、中心（文字区域）、基线**几种对齐方式。一般**默认是基线对齐。**\n\n浏览器不仅支持文字排版，还支持文字与其他元素排版。元素被定义为拥有一定区域的盒子。这个盒子由：**元素内容、内边距、边框、外边距**组成。\n\n浏览器排版，还包括：**flex布局（**这里主要是通过display的属性控制排版方式**） 、定位布局（**这里包括**绝对定位、相对定位，固定定位）、浮动布局** 、还有老式的**table布局。**\n\n<a name=\"335b97c0\"></a>\n#### 盒模型\n> 讲到布局，就不能不讲一下盒模型，\n\n一般元素都具有盒模型特征，主要由\n* content （内容）\n* padding（内边距）\n* border（边框）\n* margin（外边距）\n\n元素还分为三类：\n* **行内元素（inline）**无法赋值宽高**，元素的宽高由内容撑开，**上内边距**无法生效**上下的外边距**无法生效**\n* **行内块元素（inline-block）**：这类元素可以的赋值宽高，也可以设置内外边距\n* **块级元素（block）**：这类元素独占一行，不管元素是否有一行的宽，宽高内外边距都可以赋值。\n\n<a name=\"2e169b41\"></a>\n### flex布局\n\n```css\ndisplay:flex;\njustify-content: center;\nalign-items: center;\n```\n\n详细的可以看我之前的文章  [flex布局总结](https://wuxin.netlify.com/passages/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bflex%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/)<br />另外说一点就是。 **`display`** 这个属性的不同的值可以改变元素的布局方式\n\n<a name=\"4eb6b409\"></a>\n### 定位布局\n<a name=\"d0285350\"></a>\n#### 相对定位\n**`position`** 为 **`absolute`** 属性的元素，这类元素根据父级元素定位，一层层向上查找，如果没找到。最终会找到   **`body`** ，这类布局不参与正常流排版，他自有自己的一套排版规则。按照这种定位布局之后，将在文档中不占位置\n<a name=\"ff40a9ca\"></a>\n#### 绝对定位\n**`position`** 为  **`relative`**  属性的元素，这类元素是根据自己定位，定位移动的话，是根据自己自身移动，自身本身占据的位置不管是随着如何移动，依然在文档中占据位置\n<a name=\"7d121dca\"></a>\n#### 固定定位\n**`position`** 为 **`fixed`** 属性的元素，这类元素是根据浏览器可视定位。最大宽高是浏览器视口的宽高。超出部分会被裁剪隐藏。定位移动是根据浏览器定位移动，在正常文档流中不占据位置。\n\n<a name=\"ad793c09\"></a>\n### 浮动布局\n当元素使用 **`float: right`** 或者 **`float:left`** 的时候，就可以开启浮动布局。不过相对于其他的布局来说， **`float`** 的布局，浏览器会先将其排入正常流，然后再其排到其父元素最左/最右。移动之后的浮动元素，在没清除浮动之前，其父级元素是不占据位置。同级的浮动元素处于同一空间内，在浮动空间内的布局的规则，很像正常元素在正常流上的布局。\n\n<a name=\"a8fb79d2\"></a>\n### table布局（表格布局）\n> 顾名思，就是讲网页分割成一个个网格，然后对网格进行排版\n\n```html\n<style>\n  div{\n    /*这里记得给宽高\\(^o^)/~*/\n    display:table-cell;\n    text-align:center;\n    vertical-align: middle;\n  }\n</style>\n<body>\n  <div>\n    <em>爱是一种病，你病的不轻，还从来没有好过。</em>\n  </div>\n</body>\n```\n\n* 当父元素是要 **`display : table-row`**`display : table-cell`**  的时候。子元素是等高的\n* 当父元素是要 **`display : table-row`**`display : table-row`**  的时候。子元素是等宽的\n<a name=\"a5bed4e2\"></a>\n### Grid布局（网格布局）\n> 这种布局和 **`flex`**`grid`** 布局更倾向于二维布局。\n\n<a name=\"df368884\"></a>\n#### 前言\n* 在 **`Grid`**\"容器\"**\"项目\"**\n```html\n<article>\n    <div>\n        <p>一生一世一双人</p>\n    </div>\n    <div>\n        <p>一生一世一双人</p>\n    </div>\n    <div>\n        <p>一生一世一双人</p>\n    </div>\n</article>\n```\n> 上面的 **`article`** 就可以作为一个**容器，**作为他的子元素 **`div`**  便是 **项目 **，但是作为子元素的子元素 **`p`** 便不是项目，项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 **`p`** 元素就不是项目。 **`Grid`**  布局只对项目生效\n\n\n* **行（row）与列（column）：**正常的是横为行，竖为列\n* **单元格（cell）：**单元格**\n* **网格线：**网格线**\n\n<a name=\"1527f2de\"></a>\n#### 属性介绍\n<a name=\"0e8a88a1\"></a>\n##### 开启grid布局\n\n```css\ndisplay:grid /*这种元素独占一行*/\ndisplay:inline-grid /*这种布局类似于inline-block*/\n```\n> 注意，设为网格布局以后，容器子元素（项目）的 **`float、display: inline-block、display: table-cell、vertical-align 和 column-*`**  等设置都将失效。\n\n\n<a name=\"fe36677d\"></a>\n##### 划分行与列布局\n\n```css\n/*下面定义是宽高都是200px的三行三列网格*/\ngrid-template-columns: 200px 200px 200px; /*这里的单位不仅可以使用固定单位，也可以使用百分比*/\ngrid-template-rows: 200px 200px 200px;\n```\n \n<a name=\"8b54c79e\"></a>\n##### 重复数值 `repeat()` \n\n```css\ngrid-template-columns: reqeat(3,200px); \ngrid-template-rows: reqeat(3,200px);\n```\n**`repeat()`** 接受两个值，第一个值为重复的次数，第二个值是重复的数值。\n\n<a name=\"80ae2394\"></a>\n##### 重复的次数自动填充\n\n```css\ngrid-template-columns: reqeat(auto-fill,200px); \ngrid-template-rows: reqeat(3,200px);\n```\n\n> **`auto-fill`** 可以按照重复的数值，将子元素铺满父元素，超出便会换行\n\n\n<a name=\"07b55829\"></a>\n##### fr 关键词\n这关键词有点类似 **`flex`**  布局的 **`flex:1`** \n\n```css\ngrid-template-columns: 1fr 2fr; /* 2fr相当于1fr的两倍 */\n```\n\n<a name=\"e8bd0e48\"></a>\n##### 行间距、列间距\n\n```css\n grid-row-gap: 20px; /*行间距*/\ngrid-column-gap: 20px; /*列间距*/\n```\n\n<a name=\"969e849d\"></a>\n##### 排列先后问题 `grid-auto-flow` \n\n```css\ngrid-auto-flow: column;\ngrid-auto-flow:row /*默认*/\n```\n\n更详细的可以去看下阮一峰老师的[**grid教程**](http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html)\n\n\n\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [ 文档排版布局 ]</p><p>categories: 重学前端系列笔记</p><p>----------------------</p><h3 id=\"9243ba6c\">浏览器默认排版 - 正常流</h3><blockquote><p><span class=\"lake-fontsize-14\">浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样</span></p></blockquote><p><span class=\"lake-fontsize-14\"><br /></span></p><p><span class=\"lake-fontsize-12\">浏览器默认的文字排版规则：规定了</span><span class=\"lake-fontsize-12\"><strong>行模型及文字在行模型中的排版。</strong>行模型中规定了，文字的</span><strong><span class=\"lake-fontsize-12\">行顶</span></strong><strong><span class=\"lake-fontsize-12\">、</span></strong><strong><span class=\"lake-fontsize-12\">行底、中心（文字区域）、基线</span></strong><span class=\"lake-fontsize-12\">几种对齐方式。一般</span><strong><span class=\"lake-fontsize-12\">默认是基线对齐。</span></strong></p><p><br /></p><p>浏览器不仅支持文字排版，还支持文字与其他元素排版。元素被定义为拥有一定区域的盒子。这个盒子由：<strong>元素内容、</strong><strong>内边距、边框、外边距</strong>组成。</p><p><br /></p><p><span class=\"lake-fontsize-12\">浏览器排版，还包括：</span><strong><span class=\"lake-fontsize-12\">flex布局（</span></strong><span class=\"lake-fontsize-12\">这里主要是通过display的属性控制排版方式</span><strong><span class=\"lake-fontsize-12\">） 、定位布局（</span></strong><span class=\"lake-fontsize-12\">这里包括</span><strong><span class=\"lake-fontsize-12\">绝对定位、相对定位，固定定位）、浮动布局</span></strong><span class=\"lake-fontsize-12\"> 、还有老式的</span><strong><span class=\"lake-fontsize-12\">table布局</span></strong><strong><span class=\"lake-fontsize-12\">。</span></strong></p><p><br /></p><h4 id=\"335b97c0\">盒模型</h4><blockquote><p>讲到布局，就不能不讲一下盒模型，</p></blockquote><p>一般元素都具有盒模型特征，主要由</p><ul><li>content （内容）</li><li>padding（内边距）</li><li>border（边框）</li><li>margin（外边距）</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\">元素还分为三类：</span></p><ul><li><strong>行内元素（inline）</strong>：这类元素<strong>无法赋值宽高</strong><span>，元素的宽高由内容撑开</span>，<strong>上内边距</strong>赋值之后<strong>无法生效</strong>。<strong>上下的外边距</strong>赋值之后是<strong>无法生效</strong></li><li><strong>行内块元素（inline-block）</strong>：这类元素可以的赋值宽高，也可以设置内外边距</li><li><strong>块级元素（block）</strong>：这类元素独占一行，不管元素是否有一行的宽，宽高内外边距都可以赋值。</li></ul><p><br /></p><h3 id=\"2e169b41\">flex布局</h3><p><br /></p><pre data-lang=\"css\"><code>display:flex;\njustify-content: center;\nalign-items: center;</code></pre><p><br /></p><p>详细的可以看我之前的文章  <a href=\"https://wuxin.netlify.com/passages/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bflex%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/\" target=\"_blank\">flex布局总结</a></p><p>另外说一点就是。 <strong><code>display</code></strong> 这个属性的不同的值可以改变元素的布局方式</p><p><br /></p><h3 id=\"4eb6b409\">定位布局</h3><h4 id=\"d0285350\">相对定位</h4><p style=\"text-indent: 2em;\"><strong><code>position</code></strong> 为 <strong><code>absolute</code></strong> 属性的元素，这类元素根据父级元素定位，一层层向上查找，如果没找到。最终会找到   <strong><code>body</code></strong> ，这类布局不参与正常流排版，他自有自己的一套排版规则。按照这种定位布局之后，将在文档中不占位置</p><h4 id=\"ff40a9ca\">绝对定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为  </span><span class=\"lake-fontsize-11\"><strong><code>relative</code></strong></span><span class=\"lake-fontsize-11\">  属性的元素，这类元素是根据自己定位，定位移动的话，是根据自己自身移动，自身本身占据的位置不管是随着如何移动，依然在文档中占据位置</span></p><h4 id=\"7d121dca\">固定定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为 </span><strong><code><span class=\"lake-fontsize-11\">fixed</span></code></strong> <span class=\"lake-fontsize-11\">属性的元素</span>，这类元素是根据浏览器可视定位。最大宽高是浏览器视口的宽高。超出部分会被裁剪隐藏。定位移动是根据浏览器定位移动，在正常文档流中不占据位置。</p><p><br /></p><h3 id=\"ad793c09\">浮动布局</h3><p>当元素使用 <strong><code>float: right</code></strong> 或者 <strong><code>float:left</code></strong> 的时候，就可以开启浮动布局。不过相对于其他的布局来说， <strong><code>float</code></strong> 的布局，浏览器会先将其排入正常流，然后再其排到其父元素最左/最右。移动之后的浮动元素，在没清除浮动之前，其父级元素是不占据位置。同级的浮动元素处于同一空间内，在浮动空间内的布局的规则，很像正常元素在正常流上的布局。</p><p><br /></p><h3 id=\"a8fb79d2\">table布局（表格布局）</h3><blockquote><p>顾名思，就是讲网页分割成一个个网格，然后对网格进行排版</p></blockquote><pre data-lang=\"html\"><code>&lt;style&gt;\n  div{\n    /*这里记得给宽高\\(^o^)/~*/\n    display:table-cell;\n    text-align:center;\n    vertical-align: middle;\n  }\n&lt;/style&gt;\n&lt;body&gt;\n  &lt;div&gt;\n    &lt;em&gt;爱是一种病，你病的不轻，还从来没有好过。&lt;/em&gt;\n  &lt;/div&gt;\n&lt;/body&gt;</code></pre><p><br /></p><ul><li>当父元素是要 <strong><code>display : table-row</code></strong> ，子元素使用 <strong><code>display : table-cell</code></strong>  的时候。子元素是等高的</li><li>当父元素是要 <strong><code>display : table-row</code></strong> ，子元素使用 <strong><code>display : table-row</code></strong>  的时候。子元素是等宽的</li></ul><h3 id=\"a5bed4e2\">Grid布局（网格布局）</h3><blockquote><p>这种布局和 <strong><code>flex</code></strong> 布局很像，但是 <strong><code>grid</code></strong> 布局更倾向于二维布局。</p></blockquote><h4 id=\"df368884\">前言</h4><ul><li>在 <strong><code>Grid</code></strong> 布局中，采用布局的区域称之为<strong>&quot;容器&quot;</strong>，容器内采用网格布局的子元素称之为 <strong>&quot;项目&quot;</strong></li></ul><pre data-lang=\"html\"><code>&lt;article&gt;\n    &lt;div&gt;\n        &lt;p&gt;一生一世一双人&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;p&gt;一生一世一双人&lt;/p&gt;\n    &lt;/div&gt;\n    &lt;div&gt;\n        &lt;p&gt;一生一世一双人&lt;/p&gt;\n    &lt;/div&gt;\n&lt;/article&gt;</code></pre><blockquote><p><span class=\"lake-fontsize-12\">上面的 </span><span class=\"lake-fontsize-12\"><strong><code>article</code></strong></span><span class=\"lake-fontsize-12\"> 就可以作为一个</span><span class=\"lake-fontsize-12\"><strong>容器，</strong></span><span class=\"lake-fontsize-12\">作为他的子元素 </span><strong><code><span class=\"lake-fontsize-12\">div</span></code></strong> <span class=\"lake-fontsize-12\"> 便是 </span><span class=\"lake-fontsize-12\"><strong>项目 </strong></span><span class=\"lake-fontsize-12\">，但是作为子元素的子元素 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">便不是项目，项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">元素就不是项目。 </span><strong><code><span class=\"lake-fontsize-12\">Grid</span></code></strong> <span class=\"lake-fontsize-12\"> 布局只对项目生效</span></p></blockquote><p><br /></p><ul><li><strong>行（row）与列（column）：</strong>正常的是横为行，竖为列</li><li><strong>单元格（cell）：</strong>行与列相交的地方，称之为<strong>单元格</strong></li><li><strong>网格线：</strong>划分单元格的线称之为<strong>网格线</strong></li></ul><p><br /></p><h4 id=\"1527f2de\">属性介绍</h4><h5 id=\"0e8a88a1\">开启grid布局</h5><p><br /></p><pre data-lang=\"css\"><code>display:grid /*这种元素独占一行*/\ndisplay:inline-grid /*这种布局类似于inline-block*/</code></pre><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">注意，设为网格布局以后，容器子元素（项目）的 </span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\"><strong><code>float、display: inline-block、display: table-cell、vertical-align 和 column-*</code></strong></span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">  等设置都将失效。</span></p></blockquote><p><br /></p><h5 id=\"fe36677d\">划分行与列布局</h5><p><br /></p><pre data-lang=\"css\"><code>/*下面定义是宽高都是200px的三行三列网格*/\ngrid-template-columns: 200px 200px 200px; /*这里的单位不仅可以使用固定单位，也可以使用百分比*/\ngrid-template-rows: 200px 200px 200px;</code></pre><p> </p><h5 id=\"8b54c79e\">重复数值 <code>repeat()</code> </h5><p><br /></p><pre data-lang=\"css\"><code>grid-template-columns: reqeat(3,200px); \ngrid-template-rows: reqeat(3,200px);</code></pre><p><strong><code>repeat()</code></strong> 接受两个值，第一个值为重复的次数，第二个值是重复的数值。</p><p><br /></p><h5 id=\"80ae2394\">重复的次数自动填充</h5><p><br /></p><pre data-lang=\"css\"><code>grid-template-columns: reqeat(auto-fill,200px); \ngrid-template-rows: reqeat(3,200px);</code></pre><p><br /></p><blockquote><p><strong><code>auto-fill</code></strong> 可以按照重复的数值，将子元素铺满父元素，超出便会换行</p></blockquote><p><br /></p><h5 id=\"07b55829\">fr <span style=\"background-color: \"rgba(0, 0, 0, 0)\";\">关键词</span></h5><p>这关键词有点类似 <strong><code>flex</code></strong>  布局的 <strong><code>flex:1</code></strong> </p><p><br /></p><pre data-lang=\"css\"><code>grid-template-columns: 1fr 2fr; /* 2fr相当于1fr的两倍 */</code></pre><p><br /></p><h5 id=\"e8bd0e48\">行间距、列间距</h5><p><br /></p><pre data-lang=\"css\"><code> grid-row-gap: 20px; /*行间距*/\ngrid-column-gap: 20px; /*列间距*/</code></pre><p><br /></p><h5 id=\"969e849d\">排列先后问题 <code>grid-auto-flow</code> </h5><p><br /></p><pre data-lang=\"css\"><code>grid-auto-flow: column;\ngrid-auto-flow:row /*默认*/</code></pre><p><br /></p><p>更详细的可以去看下阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\"><strong>grid教程</strong></a></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [ 文档排版布局 ]</p><p>categories: 重学前端系列笔记</p><p>----------------------<cursor /></p><h3 id=\"9243ba6c\">浏览器默认排版 - 正常流</h3><blockquote><p><span class=\"lake-fontsize-14\">浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样</span></p></blockquote><p><span class=\"lake-fontsize-14\"><br /></span></p><p><span class=\"lake-fontsize-12\">浏览器默认的文字排版规则：规定了</span><span class=\"lake-fontsize-12\"><strong>行模型及文字在行模型中的排版。</strong>行模型中规定了，文字的</span><strong><span class=\"lake-fontsize-12\">行顶</span></strong><strong><span class=\"lake-fontsize-12\">、</span></strong><strong><span class=\"lake-fontsize-12\">行底、中心（文字区域）、基线</span></strong><span class=\"lake-fontsize-12\">几种对齐方式。一般</span><strong><span class=\"lake-fontsize-12\">默认是基线对齐。</span></strong></p><p><br /></p><p>浏览器不仅支持文字排版，还支持文字与其他元素排版。元素被定义为拥有一定区域的盒子。这个盒子由：<strong>元素内容、</strong><strong>内边距、边框、外边距</strong>组成。</p><p><br /></p><p><span class=\"lake-fontsize-12\">浏览器排版，还包括：</span><strong><span class=\"lake-fontsize-12\">flex布局（</span></strong><span class=\"lake-fontsize-12\">这里主要是通过display的属性控制排版方式</span><strong><span class=\"lake-fontsize-12\">） 、定位布局（</span></strong><span class=\"lake-fontsize-12\">这里包括</span><strong><span class=\"lake-fontsize-12\">绝对定位、相对定位，固定定位）、浮动布局</span></strong><span class=\"lake-fontsize-12\"> 、还有老式的</span><strong><span class=\"lake-fontsize-12\">table布局</span></strong><strong><span class=\"lake-fontsize-12\">。</span></strong></p><p><br /></p><h4 id=\"335b97c0\">盒模型</h4><blockquote><p>讲到布局，就不能不讲一下盒模型，</p></blockquote><p>一般元素都具有盒模型特征，主要由</p><ul><li>content （内容）</li><li>padding（内边距）</li><li>border（边框）</li><li>margin（外边距）</li></ul><p><br /></p><p><span class=\"lake-fontsize-12\">元素还分为三类：</span></p><ul><li><strong>行内元素（inline）</strong>：这类元素<strong>无法赋值宽高</strong><span>，元素的宽高由内容撑开</span>，<strong>上内边距</strong>赋值之后<strong>无法生效</strong>。<strong>上下的外边距</strong>赋值之后是<strong>无法生效</strong></li><li><strong>行内块元素（inline-block）</strong>：这类元素可以的赋值宽高，也可以设置内外边距</li><li><strong>块级元素（block）</strong>：这类元素独占一行，不管元素是否有一行的宽，宽高内外边距都可以赋值。</li></ul><p><br /></p><h3 id=\"2e169b41\">flex布局</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22display%3Aflex%3B%5Cnjustify-content%3A%20center%3B%5Cnalign-items%3A%20center%3B%22%2C%22id%22%3A%222nydV%22%7D\"></card><p><br /></p><p>详细的可以看我之前的文章  <a href=\"https://wuxin.netlify.com/passages/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bflex%E5%B8%83%E5%B1%80%E4%BD%BF%E7%94%A8/\" target=\"_blank\">flex布局总结</a></p><p>另外说一点就是。 <strong><code>display</code></strong> 这个属性的不同的值可以改变元素的布局方式</p><p><br /></p><h3 id=\"4eb6b409\">定位布局</h3><h4 id=\"d0285350\">相对定位</h4><p style=\"text-indent: 2em;\"><strong><code>position</code></strong> 为 <strong><code>absolute</code></strong> 属性的元素，这类元素根据父级元素定位，一层层向上查找，如果没找到。最终会找到   <strong><code>body</code></strong> ，这类布局不参与正常流排版，他自有自己的一套排版规则。按照这种定位布局之后，将在文档中不占位置</p><h4 id=\"ff40a9ca\">绝对定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为  </span><span class=\"lake-fontsize-11\"><strong><code>relative</code></strong></span><span class=\"lake-fontsize-11\">  属性的元素，这类元素是根据自己定位，定位移动的话，是根据自己自身移动，自身本身占据的位置不管是随着如何移动，依然在文档中占据位置</span></p><h4 id=\"7d121dca\">固定定位</h4><p style=\"text-indent: 2em;\"><span class=\"lake-fontsize-11\"><strong><code>position</code></strong></span><span class=\"lake-fontsize-11\"> 为 </span><strong><code><span class=\"lake-fontsize-11\">fixed</span></code></strong> <span class=\"lake-fontsize-11\">属性的元素</span>，这类元素是根据浏览器可视定位。最大宽高是浏览器视口的宽高。超出部分会被裁剪隐藏。定位移动是根据浏览器定位移动，在正常文档流中不占据位置。</p><p><br /></p><h3 id=\"ad793c09\">浮动布局</h3><p>当元素使用 <strong><code>float: right</code></strong> 或者 <strong><code>float:left</code></strong> 的时候，就可以开启浮动布局。不过相对于其他的布局来说， <strong><code>float</code></strong> 的布局，浏览器会先将其排入正常流，然后再其排到其父元素最左/最右。移动之后的浮动元素，在没清除浮动之前，其父级元素是不占据位置。同级的浮动元素处于同一空间内，在浮动空间内的布局的规则，很像正常元素在正常流上的布局。</p><p><br /></p><h3 id=\"a8fb79d2\">table布局（表格布局）</h3><blockquote><p>顾名思，就是讲网页分割成一个个网格，然后对网格进行排版</p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cstyle%3E%5Cn%20%20div%7B%5Cn%20%20%20%20%2F*%E8%BF%99%E9%87%8C%E8%AE%B0%E5%BE%97%E7%BB%99%E5%AE%BD%E9%AB%98%5C%5C(%5Eo%5E)%2F~*%2F%5Cn%20%20%20%20display%3Atable-cell%3B%5Cn%20%20%20%20text-align%3Acenter%3B%5Cn%20%20%20%20vertical-align%3A%20middle%3B%5Cn%20%20%7D%5Cn%3C%2Fstyle%3E%5Cn%3Cbody%3E%5Cn%20%20%3Cdiv%3E%5Cn%20%20%20%20%3Cem%3E%E7%88%B1%E6%98%AF%E4%B8%80%E7%A7%8D%E7%97%85%EF%BC%8C%E4%BD%A0%E7%97%85%E7%9A%84%E4%B8%8D%E8%BD%BB%EF%BC%8C%E8%BF%98%E4%BB%8E%E6%9D%A5%E6%B2%A1%E6%9C%89%E5%A5%BD%E8%BF%87%E3%80%82%3C%2Fem%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Fbody%3E%22%2C%22id%22%3A%22YyVcZ%22%7D\"></card><p><br /></p><ul><li>当父元素是要 <strong><code>display : table-row</code></strong> ，子元素使用 <strong><code>display : table-cell</code></strong>  的时候。子元素是等高的</li><li>当父元素是要 <strong><code>display : table-row</code></strong> ，子元素使用 <strong><code>display : table-row</code></strong>  的时候。子元素是等宽的</li></ul><h3 id=\"a5bed4e2\">Grid布局（网格布局）</h3><blockquote><p>这种布局和 <strong><code>flex</code></strong> 布局很像，但是 <strong><code>grid</code></strong> 布局更倾向于二维布局。</p></blockquote><h4 id=\"df368884\">前言</h4><ul><li>在 <strong><code>Grid</code></strong> 布局中，采用布局的区域称之为<strong>&quot;容器&quot;</strong>，容器内采用网格布局的子元素称之为 <strong>&quot;项目&quot;</strong></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Carticle%3E%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%20%20%3Cp%3E%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E4%B8%80%E5%8F%8C%E4%BA%BA%3C%2Fp%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%20%20%3Cp%3E%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E4%B8%80%E5%8F%8C%E4%BA%BA%3C%2Fp%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20%3Cdiv%3E%5Cn%20%20%20%20%20%20%20%20%3Cp%3E%E4%B8%80%E7%94%9F%E4%B8%80%E4%B8%96%E4%B8%80%E5%8F%8C%E4%BA%BA%3C%2Fp%3E%5Cn%20%20%20%20%3C%2Fdiv%3E%5Cn%3C%2Farticle%3E%22%2C%22id%22%3A%220jRRQ%22%7D\"></card><blockquote><p><span class=\"lake-fontsize-12\">上面的 </span><span class=\"lake-fontsize-12\"><strong><code>article</code></strong></span><span class=\"lake-fontsize-12\"> 就可以作为一个</span><span class=\"lake-fontsize-12\"><strong>容器，</strong></span><span class=\"lake-fontsize-12\">作为他的子元素 </span><strong><code><span class=\"lake-fontsize-12\">div</span></code></strong> <span class=\"lake-fontsize-12\"> 便是 </span><span class=\"lake-fontsize-12\"><strong>项目 </strong></span><span class=\"lake-fontsize-12\">，但是作为子元素的子元素 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">便不是项目，项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的 </span><strong><code><span class=\"lake-fontsize-12\">p</span></code></strong> <span class=\"lake-fontsize-12\">元素就不是项目。 </span><strong><code><span class=\"lake-fontsize-12\">Grid</span></code></strong> <span class=\"lake-fontsize-12\"> 布局只对项目生效</span></p></blockquote><p><br /></p><ul><li><strong>行（row）与列（column）：</strong>正常的是横为行，竖为列</li><li><strong>单元格（cell）：</strong>行与列相交的地方，称之为<strong>单元格</strong></li><li><strong>网格线：</strong>划分单元格的线称之为<strong>网格线</strong></li></ul><p><br /></p><h4 id=\"1527f2de\">属性介绍</h4><h5 id=\"0e8a88a1\">开启grid布局</h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22display%3Agrid%20%2F*%E8%BF%99%E7%A7%8D%E5%85%83%E7%B4%A0%E7%8B%AC%E5%8D%A0%E4%B8%80%E8%A1%8C*%2F%5Cndisplay%3Ainline-grid%20%2F*%E8%BF%99%E7%A7%8D%E5%B8%83%E5%B1%80%E7%B1%BB%E4%BC%BC%E4%BA%8Einline-block*%2F%22%2C%22id%22%3A%22P3FV3%22%7D\"></card><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">注意，设为网格布局以后，容器子元素（项目）的 </span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\"><strong><code>float、display: inline-block、display: table-cell、vertical-align 和 column-*</code></strong></span><span class=\"lake-fontsize-12\" style=\"color: #F5222D;\">  等设置都将失效。</span></p></blockquote><p><br /></p><h5 id=\"fe36677d\">划分行与列布局</h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%2F*%E4%B8%8B%E9%9D%A2%E5%AE%9A%E4%B9%89%E6%98%AF%E5%AE%BD%E9%AB%98%E9%83%BD%E6%98%AF200px%E7%9A%84%E4%B8%89%E8%A1%8C%E4%B8%89%E5%88%97%E7%BD%91%E6%A0%BC*%2F%5Cngrid-template-columns%3A%20200px%20200px%20200px%3B%20%2F*%E8%BF%99%E9%87%8C%E7%9A%84%E5%8D%95%E4%BD%8D%E4%B8%8D%E4%BB%85%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E5%9B%BA%E5%AE%9A%E5%8D%95%E4%BD%8D%EF%BC%8C%E4%B9%9F%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E7%99%BE%E5%88%86%E6%AF%94*%2F%5Cngrid-template-rows%3A%20200px%20200px%20200px%3B%22%2C%22id%22%3A%22DryfO%22%7D\"></card><p> </p><h5 id=\"8b54c79e\">重复数值 <code>repeat()</code> </h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-template-columns%3A%20reqeat(3%2C200px)%3B%20%5Cngrid-template-rows%3A%20reqeat(3%2C200px)%3B%22%2C%22id%22%3A%228o8kb%22%7D\"></card><p><strong><code>repeat()</code></strong> 接受两个值，第一个值为重复的次数，第二个值是重复的数值。</p><p><br /></p><h5 id=\"80ae2394\">重复的次数自动填充</h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-template-columns%3A%20reqeat(auto-fill%2C200px)%3B%20%5Cngrid-template-rows%3A%20reqeat(3%2C200px)%3B%22%2C%22id%22%3A%22cA5Pa%22%7D\"></card><p><br /></p><blockquote><p><strong><code>auto-fill</code></strong> 可以按照重复的数值，将子元素铺满父元素，超出便会换行</p></blockquote><p><br /></p><h5 id=\"07b55829\">fr <span style=\"background-color: rgba(0, 0, 0, 0);\">关键词</span></h5><p>这关键词有点类似 <strong><code>flex</code></strong>  布局的 <strong><code>flex:1</code></strong> </p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-template-columns%3A%201fr%202fr%3B%20%2F*%202fr%E7%9B%B8%E5%BD%93%E4%BA%8E1fr%E7%9A%84%E4%B8%A4%E5%80%8D%20*%2F%22%2C%22id%22%3A%22LpbgJ%22%7D\"></card><p><br /></p><h5 id=\"e8bd0e48\">行间距、列间距</h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%20grid-row-gap%3A%2020px%3B%20%2F*%E8%A1%8C%E9%97%B4%E8%B7%9D*%2F%5Cngrid-column-gap%3A%2020px%3B%20%2F*%E5%88%97%E9%97%B4%E8%B7%9D*%2F%22%2C%22id%22%3A%22WcAub%22%7D\"></card><p><br /></p><h5 id=\"969e849d\">排列先后问题 <code>grid-auto-flow</code> </h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22grid-auto-flow%3A%20column%3B%5Cngrid-auto-flow%3Arow%20%2F*%E9%BB%98%E8%AE%A4*%2F%22%2C%22id%22%3A%22uR4qD%22%7D\"></card><p><br /></p><p>更详细的可以去看下阮一峰老师的<a href=\"http://www.ruanyifeng.com/blog/2019/03/grid-layout-tutorial.html\" target=\"_blank\"><strong>grid教程</strong></a></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:58:31.000Z",
    "deleted_at": null,
    "created_at": "2019-04-08T08:48:29.000Z",
    "updated_at": "2019-04-11T09:58:31.000Z",
    "published_at": "2019-04-11T09:58:31.000Z",
    "first_published_at": "2019-04-09T02:00:09.000Z",
    "word_count": 1583,
    "cover": null,
    "description": "tags: [ 文档排版布局 ]categories: 重学前端系列笔记----------------------浏览器默认排版 - 正常流浏览器默认的排版方式是，从左到右，从上到下。这种排版方式称之为正常流，它包含了顺次排布和折行等规则，这种规则跟我们平时正常的书写排版一样浏览器默认的文字...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1469346,
    "slug": "cfusxb",
    "title": "6. http协议",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags:  [http协议]<br />categories: 重学前端系列笔记<br />--------------------\n<a name=\"4505b70a\"></a>\n### 什么是http?\n\n> 简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们\n> HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。\n\n\n<a name=\"9e404cbd\"></a>\n### http协议的格式\n\n![](https://cdn.nlark.com/yuque/0/2019/png/221851/1554976686351-6ff8353a-0b2d-4147-8c6c-e6b46e286c3f.png)\n\n<a name=\"25717aa2\"></a>\n#### 其中 **request-method **代表是此次发送请求是什么方法\n* GET \n* POST \n* HEAD\n*  PUT \n* DELETE \n* CONNECT \n* OPTIONS \n* TRACE\n\n浏览器通过地址栏访问页面都是 GET 方法。表单提交默认是 POST 方法\n\nHEAD 则是跟 GET 类似，只返回请求头，多数由 JavaScript 发起\n\nPUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。<br /><br />CONNECT 现在多用于 HTTPS 和 WebSocket。<br /><br />OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。\n\n<a name=\"148be3df\"></a>\n#### Status Code （状态码）\n* 1xx：临时回应，表示客户端请继续\n* 2xx：请求成功。\n* 3xx: 表示请求的目标有变化，希望客户端进一步处理。\n* 4xx：客户端请求错误。\n* 5xx：服务端请求错误。\n\n<a name=\"be47bd27\"></a>\n#### 请求头\n![请求头.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554712749401-938ab3d8-393f-47e8-ae4f-11c55990401d.png#align=left&display=inline&height=407&name=%E8%AF%B7%E6%B1%82%E5%A4%B4.png&originHeight=407&originWidth=633&size=75594&status=done&width=633)\n\n<a name=\"dca6cb61\"></a>\n#### 响应头\n![响应头.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554712777314-1716a350-fb17-430e-9989-3ce5b4b56a47.png#align=left&display=inline&height=453&name=%E5%93%8D%E5%BA%94%E5%A4%B4.png&originHeight=453&originWidth=627&size=84667&status=done&width=627)\n\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags:  [http协议]</p><p>categories: 重学前端系列笔记</p><p>--------------------</p><h3 id=\"4505b70a\">什么是http?</h3><p><br /></p><blockquote><p>简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们</p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。</span></p></blockquote><p><br /></p><h3 id=\"9e404cbd\">http协议的格式</h3><p><br /></p><img src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554976686351-6ff8353a-0b2d-4147-8c6c-e6b46e286c3f.png\" style=\"max-width: 600px;\" /><p><br /></p><p><br /></p><h4 id=\"25717aa2\"><span>其中 </span><strong>request-method </strong><span>代表是此次发送请求是什么方法</span></h4><ul><li><span>GET </span></li><li><span>POST </span></li><li>HEAD</li><li> PUT </li><li><span>DELETE </span></li><li>CONNECT </li><li><span>OPTIONS </span></li><li><span>TRACE</span></li></ul><p><br /></p><p>浏览器通过地址栏访问页面都是 GET 方法。表单提交默认是 POST 方法</p><p><br /></p><p>HEAD 则是跟 GET 类似，只返回请求头，多数由 <span>JavaScript </span><span>发起</span></p><p><br /></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">CONNECT 现在多用于 HTTPS 和 WebSocket。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。</span></p><p><br /></p><h4 id=\"148be3df\">Status Code （状态码）</h4><ul><li><span>1xx：临时回应，表示客户端请继续</span></li><li>2xx：请求成功。</li><li>3xx: 表示请求的目标有变化，希望客户端进一步处理。</li><li>4xx：客户端请求错误。</li><li>5xx：服务端请求错误。</li></ul><p><br /></p><h4 id=\"be47bd27\">请求头</h4><p><img alt=\"请求头.png\" title=\"请求头.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554712749401-938ab3d8-393f-47e8-ae4f-11c55990401d.png#align=left&amp;display=inline&amp;height=407&amp;name=%E8%AF%B7%E6%B1%82%E5%A4%B4.png&amp;originHeight=407&amp;originWidth=633&amp;size=75594&amp;status=done&amp;width=633\" style=\"max-width: 600px; width: 633px;\" /></p><p><br /></p><h4 id=\"dca6cb61\">响应头</h4><p><img alt=\"响应头.png\" title=\"响应头.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554712777314-1716a350-fb17-430e-9989-3ce5b4b56a47.png#align=left&amp;display=inline&amp;height=453&amp;name=%E5%93%8D%E5%BA%94%E5%A4%B4.png&amp;originHeight=453&amp;originWidth=627&amp;size=84667&amp;status=done&amp;width=627\" style=\"max-width: 600px; width: 627px;\" /></p><p><br /></p><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags:  [http协议]<cursor /></p><p>categories: 重学前端系列笔记</p><p>--------------------</p><h3 id=\"4505b70a\">什么是http?</h3><p><br /></p><blockquote><p>简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们</p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">HTTP 协议是基于 TCP 协议出现的，对 TCP 协议来说，TCP 协议是一条双向的通讯通道，HTTP 在 TCP 的基础上，规定了 Request-Response 的模式。这个模式决定了通讯必定是由浏览器端首先发起的。</span></p></blockquote><p><br /></p><h3 id=\"9e404cbd\">http协议的格式</h3><p><br /></p><card type=\"block\" name=\"mindmap\" value=\"data:%7B%22id%22%3A%22kuwOK%22%2C%22graphData%22%3A%7B%22roots%22%3A%5B%7B%22label%22%3A%22HTTP%E5%8D%8F%E8%AE%AE%22%2C%22children%22%3A%5B%7B%22label%22%3A%22Request%22%2C%22side%22%3A%22right%22%2C%22id%22%3A%22b8d74ffa%22%2C%22children%22%3A%5B%7B%22id%22%3A%22c13fb1e9%22%2C%22label%22%3A%22request%20line%22%2C%22children%22%3A%5B%7B%22id%22%3A%22bb9cb5ce%22%2C%22label%22%3A%22method%22%2C%22side%22%3A%22right%22%2C%22hierarchy%22%3A4%2C%22parent%22%3A%22c13fb1e9%22%2C%22width%22%3A59.025390625%2C%22height%22%3A23%2C%22x%22%3A354.8046875%2C%22y%22%3A-168%7D%2C%7B%22id%22%3A%22528d4d00%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22path%22%2C%22hierarchy%22%3A4%2C%22parent%22%3A%22c13fb1e9%22%2C%22width%22%3A42.35546875%2C%22height%22%3A23%2C%22x%22%3A346.4697265625%2C%22y%22%3A-141%7D%2C%7B%22id%22%3A%222cd20f46%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22version%22%2C%22hierarchy%22%3A4%2C%22parent%22%3A%22c13fb1e9%22%2C%22width%22%3A57.68359375%2C%22height%22%3A23%2C%22x%22%3A354.1337890625%2C%22y%22%3A-114%7D%5D%2C%22side%22%3A%22right%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22b8d74ffa%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A73.0390625%2C%22height%22%3A31%2C%22x%22%3A252.7724609375%2C%22y%22%3A-141%7D%2C%7B%22id%22%3A%22b7fef410%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22head%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22b8d74ffa%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.6953125%2C%22height%22%3A31%2C%22x%22%3A235.1005859375%2C%22y%22%3A-81%7D%2C%7B%22id%22%3A%22206e9d8e%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22body%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22b8d74ffa%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.021484375%2C%22height%22%3A31%2C%22x%22%3A234.763671875%2C%22y%22%3A-46%7D%5D%2C%22hierarchy%22%3A2%2C%22parent%22%3A%222a07c73a%22%2C%22shape%22%3A%22mind-first-sub%22%2C%22width%22%3A79.14453125%2C%22height%22%3A31%2C%22x%22%3A134.6806640625%2C%22y%22%3A-93.5%7D%2C%7B%22label%22%3A%22Response%22%2C%22side%22%3A%22right%22%2C%22id%22%3A%22f6549fcd%22%2C%22children%22%3A%5B%7B%22id%22%3A%22f1ca0587%22%2C%22label%22%3A%22request%20line%22%2C%22side%22%3A%22right%22%2C%22children%22%3A%5B%7B%22id%22%3A%22e40ce380%22%2C%22label%22%3A%22version%22%2C%22hierarchy%22%3A4%2C%22side%22%3A%22right%22%2C%22parent%22%3A%22f1ca0587%22%2C%22width%22%3A57.68359375%2C%22height%22%3A23%2C%22x%22%3A365.0302734375%2C%22y%22%3A3%7D%2C%7B%22id%22%3A%220beaa43e%22%2C%22label%22%3A%22status%20code%22%2C%22hierarchy%22%3A4%2C%22side%22%3A%22right%22%2C%22parent%22%3A%22f1ca0587%22%2C%22width%22%3A80.37109375%2C%22height%22%3A23%2C%22x%22%3A376.3740234375%2C%22y%22%3A30%7D%2C%7B%22id%22%3A%2237782077%22%2C%22label%22%3A%22status%20text%22%2C%22hierarchy%22%3A4%2C%22side%22%3A%22right%22%2C%22parent%22%3A%22f1ca0587%22%2C%22width%22%3A73.69140625%2C%22height%22%3A23%2C%22x%22%3A373.0341796875%2C%22y%22%3A57%7D%5D%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22f6549fcd%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A73.0390625%2C%22height%22%3A31%2C%22x%22%3A263.6689453125%2C%22y%22%3A30%7D%2C%7B%22id%22%3A%2232966f18%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22head%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22f6549fcd%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.6953125%2C%22height%22%3A31%2C%22x%22%3A245.9970703125%2C%22y%22%3A90%7D%2C%7B%22id%22%3A%220b81f415%22%2C%22side%22%3A%22right%22%2C%22label%22%3A%22body%22%2C%22hierarchy%22%3A3%2C%22parent%22%3A%22f6549fcd%22%2C%22shape%22%3A%22mind-second-sub%22%2C%22width%22%3A37.021484375%2C%22height%22%3A31%2C%22x%22%3A245.66015625%2C%22y%22%3A125%7D%5D%2C%22hierarchy%22%3A2%2C%22parent%22%3A%222a07c73a%22%2C%22shape%22%3A%22mind-first-sub%22%2C%22width%22%3A90.041015625%2C%22height%22%3A31%2C%22x%22%3A140.12890625%2C%22y%22%3A77.5%7D%5D%2C%22id%22%3A%222a07c73a%22%2C%22shape%22%3A%22mind-root%22%2C%22hierarchy%22%3A1%2C%22width%22%3A142.216796875%2C%22height%22%3A46%2C%22x%22%3A-8%2C%22y%22%3A-8%7D%5D%7D%2C%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554976686351-6ff8353a-0b2d-4147-8c6c-e6b46e286c3f.png%22%2C%22matrix%22%3A%5B1.5000000000000004%2C0%2C0%2C0%2C1.5000000000000004%2C0%2C121.09116908482144%2C263.53571428571433%2C1%5D%2C%22height%22%3A481%7D\"></card><p><br /></p><p><br /></p><h4 id=\"25717aa2\"><span>其中 </span><strong>request-method </strong><span>代表是此次发送请求是什么方法</span></h4><ul><li><span>GET </span></li><li><span>POST </span></li><li>HEAD</li><li> PUT </li><li><span>DELETE </span></li><li>CONNECT </li><li><span>OPTIONS </span></li><li><span>TRACE</span></li></ul><p><br /></p><p>浏览器通过地址栏访问页面都是 GET 方法。表单提交默认是 POST 方法</p><p><br /></p><p>HEAD 则是跟 GET 类似，只返回请求头，多数由 <span>JavaScript </span><span>发起</span></p><p><br /></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">PUT 和 DELETE 分别表示添加资源和删除资源，但是实际上这只是语义上的一种约定，并没有强约束。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">CONNECT 现在多用于 HTTPS 和 WebSocket。</span></p><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span><span class=\"lake-fontsize-10\" style=\"color: #222222;\">OPTIONS 和 TRACE 一般用于调试，多数线上服务都不支持。</span></p><p><br /></p><h4 id=\"148be3df\">Status Code （状态码）</h4><ul><li><span>1xx：临时回应，表示客户端请继续</span></li><li>2xx：请求成功。</li><li>3xx: 表示请求的目标有变化，希望客户端进一步处理。</li><li>4xx：客户端请求错误。</li><li>5xx：服务端请求错误。</li></ul><p><br /></p><h4 id=\"be47bd27\">请求头</h4><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554712749401-938ab3d8-393f-47e8-ae4f-11c55990401d.png%22%2C%22originWidth%22%3A633%2C%22originHeight%22%3A407%2C%22name%22%3A%22%E8%AF%B7%E6%B1%82%E5%A4%B4.png%22%2C%22size%22%3A75594%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A633%2C%22height%22%3A407%7D\"></card></p><p><br /></p><h4 id=\"dca6cb61\">响应头</h4><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554712777314-1716a350-fb17-430e-9989-3ce5b4b56a47.png%22%2C%22originWidth%22%3A627%2C%22originHeight%22%3A453%2C%22name%22%3A%22%E5%93%8D%E5%BA%94%E5%A4%B4.png%22%2C%22size%22%3A84667%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A627%2C%22height%22%3A453%7D\"></card></p><p><br /></p><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:58:06.000Z",
    "deleted_at": null,
    "created_at": "2019-04-03T08:24:12.000Z",
    "updated_at": "2019-04-11T09:58:06.000Z",
    "published_at": "2019-04-11T09:58:06.000Z",
    "first_published_at": "2019-04-03T08:25:08.000Z",
    "word_count": 351,
    "cover": null,
    "description": "tags:  [http协议]categories: 重学前端系列笔记--------------------什么是http?简称“超文本传输协议”,是一种用来在Web上传输文件的基础协议，最典型的是在浏览器和服务器之间传递以至于上网人员可以浏览他们HTTP 协议是基于 TCP 协议出现的，对...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1468656,
    "slug": "vtgdtr",
    "title": "5. 浏览器渲染与加载优化",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [浏览器渲染 ,加载优化]<br />categories: 重学前端系列笔记<br />----------------\n<a name=\"5f6dca38\"></a>\n### 浏览器解析网页过程 \n1. 解析DOM树，生成 domTree\n1. 解析CSS树，生成 cssTree\n1. 根据domTree上的节点，以及 cssTree 上的属性合成，\n1. 一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度\n1. 合成之后，再绘制到界面上\n> **在网页中浏览器解析是从上往下，从左往右解析。遇到类似于网页请求的时候，就会阻塞页面。例如：图片请求，js加载。css加载。**\n\n\n**![tree.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1554277582503-3a35e42c-71d3-4aa4-b475-08c74bab3ca2.png#align=left&display=inline&height=420&name=tree.png&originHeight=810&originWidth=1440&size=216758&status=done&width=746)<br />**<br />**\n<a name=\"981b618c\"></a>\n### 优化加载速度\n<a name=\"57d92aca\"></a>\n#### （0）页面dom结构，尽量少嵌套元素。能用一个元素完成的排版，就不用两个\n<a name=\"a693339b\"></a>\n#### （1）js尽量写到body外\n<a name=\"78f0edcc\"></a>\n#### （2）css渲染，尽量别使用大规模的重绘，回流的样式\n> css优化渲染，可以参考，我之前写的 [前端性能之css渲染](https://www.hellomyblog.cn/2018/12/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93.html) 或者 [性能](https://wuxin.netlify.com/passages/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93/)\n\n<a name=\"40ebffe3\"></a>\n#### （4）图片如果可以的，能使用字体图标，就别使用雪碧图\n<a name=\"0d142347\"></a>\n#### （5）在写初始化样式的时候，能用标签，就别用通配符 `*`  \n<a name=\"70b12fd8\"></a>\n#### （6）资源压缩\n> 我们在做项目的时候，经常会将一些 JS 代码分文件分区块存贮，这样虽然方便后期维护，但是会造成多次请求。\n> **所以：**在保证不多次请求的前提下进行模块文件划分。一般是尽量一个 **`JS`** 文件 不超过500行，超过了就抽取成公共函数，暴露引用，这样方便维护。\n> 并且在上线的时候，使用混淆压缩文件体积，可以使请求资源变小\n\n\n**压缩还可以让后端启用**  **`g-zip`** ** **<br /><br />\n<a name=\"76486118\"></a>\n#### （7）文件异步加载，文件按需加载\n<a name=\"d62cf5ee\"></a>\n##### ① async\n* 这个属性是 H5 新增的属性，需要Chrome、FireFox、IE9+浏览器支持\n* async属性规定一旦脚本可用，则会异步执行<br />\n* async属性仅适用于外部脚本<br />\n* 如果是多个脚本，该方法不能保证脚本按顺序执行\n```html\n<script type=\"text/javascript\" src=\"xxx.js\" async=\"async\"></script>\n```\n\n<a name=\"89c8336e\"></a>\n##### ② **defer**\n* 兼容所有浏览器<br />\n* defer属性规定是否对脚本执行进行延迟，直到页面加载为止\n* 如果是多个脚本，该方法可以确保所有设置了defer属性的脚本按顺序执行<br />\n* 如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度<br />\n\n```html\n<script type=\"text/javascript\" src=\"xxx.js\" defer=\"defer\"></script>\n```\n\n<a name=\"a111ed08\"></a>\n##### ③ **动态创建script标签**\n> 通过window.onload方法确保页面加载完毕再将script标签插入到DOM\n\n\n```javascript\nfunctionaddScriptTag(src){\n    var script = document.createElement('script');\n    script.setAttribute(\"type\",\"text/javascript\");\n    script.src =src;\n \t\tdocument.body.appendChild(script);\n}\n  \nwindow.onload =function(){\n  addScriptTag(\"js/index.js\");\n}\n```\n\n<a name=\"21244bbb\"></a>\n##### `async` 与 `defer` 的区别：\n* defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行\n* async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关\n<a name=\"c5a971fc\"></a>\n#### （8）利用缓存\n<a name=\"1092fc71\"></a>\n##### ① 利用浏览器强缓存\n> 不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示 **`from disk cache`** ** `from memory cache`**\n\n\n\n<a name=\"0ee2c4fc\"></a>\n#### （9）使用CDN\n> 通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载\n\n\n\n",
    "body_draft": "",
    "body_html": "<p>tags: [浏览器渲染 ,加载优化]</p><p>categories: 重学前端系列笔记</p><p>----------------</p><h3 id=\"5f6dca38\">浏览器解析网页过程 </h3><ol start=\"1\"><li>解析DOM树，生成 domTree</li><li>解析CSS树，生成 cssTree</li><li>根据domTree上的节点，以及 cssTree 上的属性合成，</li><li>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度</li><li>合成之后，再绘制到界面上</li></ol><blockquote><p><span class=\"lake-fontsize-12\"><strong>在网页中浏览器解析是从上往下，从左往右解析。遇到类似于网页请求的时候，就会阻塞页面。例如：图片请求，js加载。css加载。</strong></span></p></blockquote><p><br /></p><p><span class=\"lake-fontsize-12\"><strong><img alt=\"tree.png\" title=\"tree.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1554277582503-3a35e42c-71d3-4aa4-b475-08c74bab3ca2.png#align=left&amp;display=inline&amp;height=420&amp;name=tree.png&amp;originHeight=810&amp;originWidth=1440&amp;size=216758&amp;status=done&amp;width=746\" style=\"max-width: 600px; width: 746px;\" /><br /></strong></span></p><p><span class=\"lake-fontsize-12\"><strong><br /></strong></span></p><h3 id=\"981b618c\">优化加载速度</h3><h4 id=\"57d92aca\">（0）页面dom结构，尽量少嵌套元素。能用一个元素完成的排版，就不用两个</h4><h4 id=\"a693339b\">（1）js尽量写到body外</h4><h4 id=\"78f0edcc\">（2）css渲染，尽量别使用大规模的重绘，回流的样式</h4><blockquote><p>css优化渲染，可以参考，我之前写的 <a href=\"https://www.hellomyblog.cn/2018/12/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93.html\" target=\"_blank\">前端性能之css渲染</a> 或者 <a href=\"https://wuxin.netlify.com/passages/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93/\" target=\"_blank\">性能</a></p></blockquote><h4 id=\"40ebffe3\">（4）图片如果可以的，能使用字体图标，就别使用雪碧图</h4><h4 id=\"0d142347\">（5）在写初始化样式的时候，能用标签，就别用通配符 <code>*</code>  </h4><h4 id=\"70b12fd8\">（6）资源压缩</h4><blockquote><p>我们在做项目的时候，经常会将一些 JS 代码分文件分区块存贮，这样虽然方便后期维护，但是会造成多次请求。</p><p><strong>所以：</strong><span class=\"lake-fontsize-14\">在保证不多次请求的前提下进行模块文件划分。一般是尽量一个 </span><span class=\"lake-fontsize-14\"><strong><code>JS</code></strong> 文件 不超过500行，超过了就抽取成公共函数，暴露引用，这样方便维护。</span></p><p><span class=\"lake-fontsize-14\">并且在上线的时候，使用混淆压缩文件体积，可以使请求资源变小</span></p></blockquote><p><br /></p><p><strong>压缩还可以让后端启用</strong>  <strong><code>g-zip</code></strong> <strong> </strong></p><p><span class=\"lake-fontsize-14\"><br /></span></p><h4 id=\"76486118\">（7）文件异步加载，文件按需加载</h4><h5 id=\"d62cf5ee\">① async</h5><ul><li>这个属性是 H5 新增的属性，<span style=\"color: #4A4A4A;\">需要Chrome、FireFox、IE9+浏览器支持</span></li><li><span style=\"color: #4A4A4A;\"><span>async属性规定一旦脚本可用，则会异步执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>async属性仅适用于外部脚本</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法不能保证脚本按顺序执行</span></span></li></ul><pre data-lang=\"html\"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot; async=&quot;async&quot;&gt;&lt;/script&gt;</code></pre><p><br /></p><h5 id=\"89c8336e\">② <strong>defer</strong></h5><ul><li><span style=\"color: #4A4A4A;\"><span>兼容所有浏览器</span></span><br /></li><li>defer属性规定是否对脚本执行进行延迟，直到页面加载为止</li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法可以确保所有设置了defer属性的脚本按顺序执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度</span></span><br /></li><p><br /></p></ul><pre data-lang=\"html\"><code>&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot; defer=&quot;defer&quot;&gt;&lt;/script&gt;</code></pre><p><br /></p><h5 id=\"a111ed08\">③ <strong>动态创建script标签</strong></h5><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #4A4A4A;\">通过window.onload方法确保页面加载完毕再将script标签插入到DOM</span></p></blockquote><p><br /></p><pre data-lang=\"javascript\"><code>functionaddScriptTag(src){\n    var script = document.createElement('script');\n    script.setAttribute(&quot;type&quot;,&quot;text/javascript&quot;);\n    script.src =src;\n \t\tdocument.body.appendChild(script);\n}\n  \nwindow.onload =function(){\n  addScriptTag(&quot;js/index.js&quot;);\n}</code></pre><p><br /></p><h5 id=\"21244bbb\"><code>async</code> 与 <code>defer</code> 的区别：</h5><ul><li>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行</li><li>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</li></ul><h4 id=\"c5a971fc\">（8）利用缓存</h4><h5 id=\"1092fc71\">① 利用浏览器强缓存<br /></h5><blockquote><p>不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示 <strong><code>from disk cache</code></strong>  <strong> </strong>或  <strong> <code>from memory cache</code></strong></p></blockquote><p><br /></p><p><br /></p><h4 id=\"0ee2c4fc\">（9）使用CDN</h4><blockquote><p>通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载</p></blockquote><p><br /></p><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags: [浏览器渲染 ,<cursor />加载优化]</p><p>categories: 重学前端系列笔记</p><p>----------------</p><h3 id=\"5f6dca38\">浏览器解析网页过程 </h3><ol start=\"1\"><li>解析DOM树，生成 domTree</li><li>解析CSS树，生成 cssTree</li><li>根据domTree上的节点，以及 cssTree 上的属性合成，</li><li>一个可选的步骤是对位图进行合成，这会极大地增加后续绘制的速度</li><li>合成之后，再绘制到界面上</li></ol><blockquote><p><span class=\"lake-fontsize-12\"><strong>在网页中浏览器解析是从上往下，从左往右解析。遇到类似于网页请求的时候，就会阻塞页面。例如：图片请求，js加载。css加载。</strong></span></p></blockquote><p><br /></p><p><span class=\"lake-fontsize-12\"><strong><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1554277582503-3a35e42c-71d3-4aa4-b475-08c74bab3ca2.png%22%2C%22originWidth%22%3A1440%2C%22originHeight%22%3A810%2C%22name%22%3A%22tree.png%22%2C%22size%22%3A216758%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A746%2C%22height%22%3A420%7D\"></card><br /></strong></span></p><p><span class=\"lake-fontsize-12\"><strong><br /></strong></span></p><h3 id=\"981b618c\">优化加载速度</h3><h4 id=\"57d92aca\">（0）页面dom结构，尽量少嵌套元素。能用一个元素完成的排版，就不用两个</h4><h4 id=\"a693339b\">（1）js尽量写到body外</h4><h4 id=\"78f0edcc\">（2）css渲染，尽量别使用大规模的重绘，回流的样式</h4><blockquote><p>css优化渲染，可以参考，我之前写的 <a href=\"https://www.hellomyblog.cn/2018/12/24/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93.html\" target=\"_blank\">前端性能之css渲染</a> 或者 <a href=\"https://wuxin.netlify.com/passages/%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%B9%8Bcss%E6%B8%B2%E6%9F%93/\" target=\"_blank\">性能</a></p></blockquote><h4 id=\"40ebffe3\">（4）图片如果可以的，能使用字体图标，就别使用雪碧图</h4><h4 id=\"0d142347\">（5）在写初始化样式的时候，能用标签，就别用通配符 <code>*</code>  </h4><h4 id=\"70b12fd8\">（6）资源压缩</h4><blockquote><p>我们在做项目的时候，经常会将一些 JS 代码分文件分区块存贮，这样虽然方便后期维护，但是会造成多次请求。</p><p><strong>所以：</strong><span class=\"lake-fontsize-14\">在保证不多次请求的前提下进行模块文件划分。一般是尽量一个 </span><span class=\"lake-fontsize-14\"><strong><code>JS</code></strong> 文件 不超过500行，超过了就抽取成公共函数，暴露引用，这样方便维护。</span></p><p><span class=\"lake-fontsize-14\">并且在上线的时候，使用混淆压缩文件体积，可以使请求资源变小</span></p></blockquote><p><br /></p><p><strong>压缩还可以让后端启用</strong>  <strong><code>g-zip</code></strong> <strong> </strong></p><p><span class=\"lake-fontsize-14\"><br /></span></p><h4 id=\"76486118\">（7）文件异步加载，文件按需加载</h4><h5 id=\"d62cf5ee\">① async</h5><ul><li>这个属性是 H5 新增的属性，<span style=\"color: #4A4A4A;\">需要Chrome、FireFox、IE9+浏览器支持</span></li><li><span style=\"color: #4A4A4A;\"><span>async属性规定一旦脚本可用，则会异步执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>async属性仅适用于外部脚本</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法不能保证脚本按顺序执行</span></span></li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20type%3D%5C%22text%2Fjavascript%5C%22%20src%3D%5C%22xxx.js%5C%22%20async%3D%5C%22async%5C%22%3E%3C%2Fscript%3E%22%2C%22id%22%3A%22dd0bu%22%7D\"></card><p><br /></p><h5 id=\"89c8336e\">② <strong>defer</strong></h5><ul><li><span style=\"color: #4A4A4A;\"><span>兼容所有浏览器</span></span><br /></li><li>defer属性规定是否对脚本执行进行延迟，直到页面加载为止</li><li><span style=\"color: #4A4A4A;\"><span>如果是多个脚本，该方法可以确保所有设置了defer属性的脚本按顺序执行</span></span><br /></li><li><span style=\"color: #4A4A4A;\"><span>如果脚本不会改变文档的内容，可将defer属性加入到script标签中，以便加快处理文档的速度</span></span><br /></li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22html%22%2C%22code%22%3A%22%3Cscript%20type%3D%5C%22text%2Fjavascript%5C%22%20src%3D%5C%22xxx.js%5C%22%20defer%3D%5C%22defer%5C%22%3E%3C%2Fscript%3E%22%2C%22id%22%3A%220bXpU%22%7D\"></card><p><br /></p><h5 id=\"a111ed08\">③ <strong>动态创建script标签</strong></h5><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #4A4A4A;\">通过window.onload方法确保页面加载完毕再将script标签插入到DOM</span></p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22functionaddScriptTag(src)%7B%5Cn%20%20%20%20var%20script%20%3D%20document.createElement('script')%3B%5Cn%20%20%20%20script.setAttribute(%5C%22type%5C%22%2C%5C%22text%2Fjavascript%5C%22)%3B%5Cn%20%20%20%20script.src%20%3Dsrc%3B%5Cn%20%5Ct%5Ctdocument.body.appendChild(script)%3B%5Cn%7D%5Cn%20%20%5Cnwindow.onload%20%3Dfunction()%7B%5Cn%20%20addScriptTag(%5C%22js%2Findex.js%5C%22)%3B%5Cn%7D%22%2C%22id%22%3A%22wNqio%22%7D\"></card><p><br /></p><h5 id=\"21244bbb\"><code>async</code> 与 <code>defer</code> 的区别：</h5><ul><li>defer是在HTML解析完之后才会执行，如果是多个，按照加载的顺序依次执行</li><li>async是在加载完之后立即执行，如果是多个，执行顺序和加载顺序无关</li></ul><h4 id=\"c5a971fc\">（8）利用缓存</h4><h5 id=\"1092fc71\">① 利用浏览器强缓存<br /></h5><blockquote><p>不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码，并且size显示 <strong><code>from disk cache</code></strong>  <strong> </strong>或  <strong> <code>from memory cache</code></strong></p></blockquote><p><br /></p><p><br /></p><h4 id=\"0ee2c4fc\">（9）使用CDN</h4><blockquote><p>通过将静态资源(例如javascript，css，图片等等）缓存到离用户很近的相同网络运营商的CDN节点上，不但能提升用户的访问速度，还能节省服务器的带宽消耗，降低负载</p></blockquote><p><br /></p><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:57:56.000Z",
    "deleted_at": null,
    "created_at": "2019-04-03T07:15:52.000Z",
    "updated_at": "2019-04-11T09:57:56.000Z",
    "published_at": "2019-04-11T09:57:56.000Z",
    "first_published_at": "2019-04-03T07:16:17.000Z",
    "word_count": 916,
    "cover": null,
    "description": "tags: [浏览器渲染 ,加载优化]categories: 重学前端系列笔记----------------浏览器解析网页过程 解析DOM树，生成 domTree解析CSS树，生成 cssTree根据domTree上的节点，以及 cssTree 上的属性合成，一个可选的步骤是对位图进行合成，...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1455644,
    "slug": "csekvc",
    "title": "4. css语法中常见的@规则符",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags:  [css规则符]<br />categories: 重学前端系列笔记<br />---------------\n<a name=\"602fe697\"></a>\n### （0）@charset （规定页面使用什么格式）\n> 这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果\n\n\n```css\n@charset \"UTF-8\";\n```\n\n<a name=\"6b36b468\"></a>\n### （1）@import（用来引入文件）\n> 这个是用来引入另外一个 css 文件到当前文件内。除了页面的 [@charset](#) 标识，其余的都会引入，就相当于复制\n\n\n```css\n/* 两种引入方式 */\n@import \"/css/base.css\"\n@import url(\"/css/base.css\")\n  \n\n@import [ <url> | <string> ]\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;\n```\n<a name=\"92afc589\"></a>\n### （2）@media（用来判断设备类型）\n> 它能够对设备的类型进行一些判断。在 media 的区块内。是普通规则列表。\n\n\n```css\n@media print{\n\theader{\n   font-size:13pt; \n  }\n}\n@media screen{\n\thtml{\n   font-size:50px; \n  }\n}\n\n```\n\n<a name=\"ab5d596d\"></a>\n### （3）@page（分页媒体访问网页时的表现设置）\n> page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。\n\n\n```css\n@page {\n  size: 8.5in 11in;\n  margin: 10%;\n  @top-left {\n    content: \"Hamlet\";\n  }\n  @top-right {\n    content: \"Page \" counter(page);\n  }\n}\n\n```\n\n<a name=\"7722807a\"></a>\n### （4）@counter-style（定义列表样式）\n\n```css\n\n@counter-style count-style{\n\t  system:cyclic/numeric/alphabetic/symbolic/additive/[fixed ?]/[ extends ]; /*这个定义算法*/\n    range:auto/数字范围 ; /*使用范围*/;\n    symbols：符号; or additive-symbols: 符号;\n    prefix：前缀;\n    suffix  : 后缀;\n    pad:补零策略;\n  \tnegative：负数策略;\n    fallback:出错后的默认值;\n  \tspeakas:语音策略;\n}\n```\n具体的可以看 [CSDN参数属性](https://blog.csdn.net/chy555chy/article/details/79928389)，或者可以看 [MDN详解](https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style)\n\n<a name=\"cdea5a28\"></a>\n### （5）@keyframes（定义关键帧动画）\n> 这个可能是比较熟悉了，定义关键帧动画。著名的 [animate.css](https://daneden.github.io/animate.css/)，就是使用这个定义的多达几十种动画\n> \n\n```css\n/* 定义 */\n@keyframes animateName {\n\tfrom {\n    left: 0;\n    top: 0;\n  }\n  to {\n    left: 100px;\n    top: 100px;\n  }\n}\n\n/*使用*/\n.userAnimate{\n\tanimation:animateName .5s ease-in infinite;\n}\n```\n\n<a name=\"b4364690\"></a>\n### （6）@fontface（定义字体）\n> 著名的 icon字体图标，就是使用这个定义的。\n\n\n```css\n@font-face {\n  font-family: Gentium;\n  src: url(http://example.com/fonts/Gentium.woff);\n}\np { \n  font-family: Gentium, serif; \n}\n```\n\n<a name=\"1086e109\"></a>\n### （7）@supports（判断环境）\n> support 检查环境的特性，它与 media 比较类似\n\n<a name=\"55be0195\"></a>\n### （8）@namespace（设置命名空间）\n> 用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。\n\n\n*****这个还没搞懂用法，暂时先记下\n\n<a name=\"7bb5a181\"></a>\n### （9）@viewport（设置视口特性）\n> 用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。\n\n\n\n大概的就是这些了。有其他的话，之后再做补充吧。\n",
    "body_draft": "",
    "body_html": "<p>tags:  [css规则符]</p><p><span style=\"background-color: \"rgba(0, 0, 0, 0)\";\">categories: 重学前端系列笔记</span></p><p>---------------</p><h3 id=\"602fe697\">（0）@charset （规定页面使用什么格式）</h3><blockquote><p>这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@charset &quot;UTF-8&quot;;</code></pre><p><br /></p><h3 id=\"6b36b468\">（1）@import（用来引入文件）</h3><blockquote><p>这个是用来引入另外一个 css 文件到当前文件内。除了页面的 <a href=\"#\">@charset</a> 标识，其余的都会引入，就相当于复制</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>/* 两种引入方式 */\n@import &quot;/css/base.css&quot;\n@import url(&quot;/css/base.css&quot;)\n  \n\n@import [ &lt;url&gt; | &lt;string&gt; ]\n        [ supports( [ &lt;supports-condition&gt; | &lt;declaration&gt; ] ) ]?\n        &lt;media-query-list&gt;? ;</code></pre><h3 id=\"92afc589\">（2）@media（用来判断设备类型）</h3><blockquote><p>它能够对设备的类型进行一些判断。在 media 的区块内。是普通规则列表。</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@media print{\n\theader{\n   font-size:13pt; \n  }\n}\n@media screen{\n\thtml{\n   font-size:50px; \n  }\n}\n</code></pre><p><br /></p><h3 id=\"ab5d596d\">（3）@page（分页媒体访问网页时的表现设置）</h3><blockquote><p>page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@page {\n  size: 8.5in 11in;\n  margin: 10%;\n  @top-left {\n    content: &quot;Hamlet&quot;;\n  }\n  @top-right {\n    content: &quot;Page &quot; counter(page);\n  }\n}\n</code></pre><p><br /></p><h3 id=\"7722807a\">（4）@counter-style（定义列表样式）</h3><p><br /></p><pre data-lang=\"css\"><code>\n@counter-style count-style{\n\t  system:cyclic/numeric/alphabetic/symbolic/additive/[fixed ?]/[ extends ]; /*这个定义算法*/\n    range:auto/数字范围 ; /*使用范围*/;\n    symbols：符号; or additive-symbols: 符号;\n    prefix：前缀;\n    suffix  : 后缀;\n    pad:补零策略;\n  \tnegative：负数策略;\n    fallback:出错后的默认值;\n  \tspeakas:语音策略;\n}</code></pre><p>具体的可以看 <a href=\"https://blog.csdn.net/chy555chy/article/details/79928389\" target=\"_blank\">CSDN参数属性</a>，或者可以看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style\" target=\"_blank\">MDN详解</a></p><p><br /></p><h3 id=\"cdea5a28\">（5）@keyframes（定义关键帧动画）</h3><blockquote><p>这个可能是比较熟悉了，定义关键帧动画。著名的<span class=\"lake-fontsize-14\"> </span><a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\"><span class=\"lake-fontsize-14\">animate.css</span></a>，就是使用这个定义的多达几十种动画</p><p><br /></p></blockquote><pre data-lang=\"css\"><code>/* 定义 */\n@keyframes animateName {\n\tfrom {\n    left: 0;\n    top: 0;\n  }\n  to {\n    left: 100px;\n    top: 100px;\n  }\n}\n\n/*使用*/\n.userAnimate{\n\tanimation:animateName .5s ease-in infinite;\n}</code></pre><p><br /></p><h3 id=\"b4364690\">（6）@fontface（定义字体）</h3><blockquote><p>著名的 <span class=\"lake-fontsize-12\" style=\"color: #FA541C;\">icon字体图标，</span><span class=\"lake-fontsize-11\" style=\"color: #000000;\">就是使用这个定义的。</span></p></blockquote><p><br /></p><pre data-lang=\"css\"><code>@font-face {\n  font-family: Gentium;\n  src: url(http://example.com/fonts/Gentium.woff);\n}\np { \n  font-family: Gentium, serif; \n}</code></pre><p><br /></p><h3 id=\"1086e109\">（7）@supports（判断环境）</h3><blockquote><p>support 检查环境的特性，它与 media 比较类似</p></blockquote><h3 id=\"55be0195\">（8）@namespace（设置命名空间）</h3><blockquote><p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p></blockquote><p><br /></p><p><span class=\"lake-fontsize-16\" style=\"color: #F5222D;\"><strong>*</strong></span>这个还没搞懂用法，暂时先记下</p><p><br /></p><h3 id=\"7bb5a181\">（9）@viewport（设置视口特性）</h3><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。</span></p></blockquote><p><br /></p><p><br /></p><p>大概的就是这些了。有其他的话，之后再做补充吧。</p>",
    "body_lake": "<!doctype lake><p>tags:  [css规则符]<cursor /></p><p><span style=\"background-color: rgba(0, 0, 0, 0);\">categories: 重学前端系列笔记</span></p><p>---------------</p><h3 id=\"602fe697\">（0）@charset （规定页面使用什么格式）</h3><blockquote><p>这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40charset%20%5C%22UTF-8%5C%22%3B%22%2C%22id%22%3A%22tY0sA%22%7D\"></card><p><br /></p><h3 id=\"6b36b468\">（1）@import（用来引入文件）</h3><blockquote><p>这个是用来引入另外一个 css 文件到当前文件内。除了页面的 <card type=\"inline\" name=\"mention\" value=\"data:%7B%22login%22%3A%22%22%2C%22name%22%3A%22charset%22%7D\"></card> 标识，其余的都会引入，就相当于复制</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%2F*%20%E4%B8%A4%E7%A7%8D%E5%BC%95%E5%85%A5%E6%96%B9%E5%BC%8F%20*%2F%5Cn%40import%20%5C%22%2Fcss%2Fbase.css%5C%22%5Cn%40import%20url(%5C%22%2Fcss%2Fbase.css%5C%22)%5Cn%20%20%5Cn%5Cn%40import%20%5B%20%3Curl%3E%20%7C%20%3Cstring%3E%20%5D%5Cn%20%20%20%20%20%20%20%20%5B%20supports(%20%5B%20%3Csupports-condition%3E%20%7C%20%3Cdeclaration%3E%20%5D%20)%20%5D%3F%5Cn%20%20%20%20%20%20%20%20%3Cmedia-query-list%3E%3F%20%3B%22%2C%22id%22%3A%22MCDu0%22%7D\"></card><h3 id=\"92afc589\">（2）@media（用来判断设备类型）</h3><blockquote><p>它能够对设备的类型进行一些判断。在 media 的区块内。是普通规则列表。</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40media%20print%7B%5Cn%5Ctheader%7B%5Cn%20%20%20font-size%3A13pt%3B%20%5Cn%20%20%7D%5Cn%7D%5Cn%40media%20screen%7B%5Cn%5Cthtml%7B%5Cn%20%20%20font-size%3A50px%3B%20%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22id%22%3A%22T7ey8%22%7D\"></card><p><br /></p><h3 id=\"ab5d596d\">（3）@page（分页媒体访问网页时的表现设置）</h3><blockquote><p>page 用于分页媒体访问网页时的表现设置，页面是一种特殊的盒模型结构，除了页面本身，还可以设置它周围的盒。</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40page%20%7B%5Cn%20%20size%3A%208.5in%2011in%3B%5Cn%20%20margin%3A%2010%25%3B%5Cn%20%20%40top-left%20%7B%5Cn%20%20%20%20content%3A%20%5C%22Hamlet%5C%22%3B%5Cn%20%20%7D%5Cn%20%20%40top-right%20%7B%5Cn%20%20%20%20content%3A%20%5C%22Page%20%5C%22%20counter(page)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22id%22%3A%224Mq8C%22%7D\"></card><p><br /></p><h3 id=\"7722807a\">（4）@counter-style（定义列表样式）</h3><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%5Cn%40counter-style%20count-style%7B%5Cn%5Ct%20%20system%3Acyclic%2Fnumeric%2Falphabetic%2Fsymbolic%2Fadditive%2F%5Bfixed%20%3F%5D%2F%5B%20extends%20%5D%3B%20%2F*%E8%BF%99%E4%B8%AA%E5%AE%9A%E4%B9%89%E7%AE%97%E6%B3%95*%2F%5Cn%20%20%20%20range%3Aauto%2F%E6%95%B0%E5%AD%97%E8%8C%83%E5%9B%B4%20%3B%20%2F*%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4*%2F%3B%5Cn%20%20%20%20symbols%EF%BC%9A%E7%AC%A6%E5%8F%B7%3B%20or%20additive-symbols%3A%20%E7%AC%A6%E5%8F%B7%3B%5Cn%20%20%20%20prefix%EF%BC%9A%E5%89%8D%E7%BC%80%3B%5Cn%20%20%20%20suffix%20%20%3A%20%E5%90%8E%E7%BC%80%3B%5Cn%20%20%20%20pad%3A%E8%A1%A5%E9%9B%B6%E7%AD%96%E7%95%A5%3B%5Cn%20%20%5Ctnegative%EF%BC%9A%E8%B4%9F%E6%95%B0%E7%AD%96%E7%95%A5%3B%5Cn%20%20%20%20fallback%3A%E5%87%BA%E9%94%99%E5%90%8E%E7%9A%84%E9%BB%98%E8%AE%A4%E5%80%BC%3B%5Cn%20%20%5Ctspeakas%3A%E8%AF%AD%E9%9F%B3%E7%AD%96%E7%95%A5%3B%5Cn%7D%22%2C%22id%22%3A%227LVbX%22%7D\"></card><p>具体的可以看 <a href=\"https://blog.csdn.net/chy555chy/article/details/79928389\" target=\"_blank\">CSDN参数属性</a>，或者可以看 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/@counter-style\" target=\"_blank\">MDN详解</a></p><p><br /></p><h3 id=\"cdea5a28\">（5）@keyframes（定义关键帧动画）</h3><blockquote><p>这个可能是比较熟悉了，定义关键帧动画。著名的<span class=\"lake-fontsize-14\"> </span><a href=\"https://daneden.github.io/animate.css/\" target=\"_blank\"><span class=\"lake-fontsize-14\">animate.css</span></a>，就是使用这个定义的多达几十种动画</p><p><br /></p></blockquote><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%2F*%20%E5%AE%9A%E4%B9%89%20*%2F%5Cn%40keyframes%20animateName%20%7B%5Cn%5Ctfrom%20%7B%5Cn%20%20%20%20left%3A%200%3B%5Cn%20%20%20%20top%3A%200%3B%5Cn%20%20%7D%5Cn%20%20to%20%7B%5Cn%20%20%20%20left%3A%20100px%3B%5Cn%20%20%20%20top%3A%20100px%3B%5Cn%20%20%7D%5Cn%7D%5Cn%5Cn%2F*%E4%BD%BF%E7%94%A8*%2F%5Cn.userAnimate%7B%5Cn%5Ctanimation%3AanimateName%20.5s%20ease-in%20infinite%3B%5Cn%7D%22%2C%22id%22%3A%22PFCDC%22%7D\"></card><p><br /></p><h3 id=\"b4364690\">（6）@fontface（定义字体）</h3><blockquote><p>著名的 <span class=\"lake-fontsize-12\" style=\"color: #FA541C;\">icon字体图标，</span><span class=\"lake-fontsize-11\" style=\"color: #000000;\">就是使用这个定义的。</span></p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22css%22%2C%22code%22%3A%22%40font-face%20%7B%5Cn%20%20font-family%3A%20Gentium%3B%5Cn%20%20src%3A%20url(http%3A%2F%2Fexample.com%2Ffonts%2FGentium.woff)%3B%5Cn%7D%5Cnp%20%7B%20%5Cn%20%20font-family%3A%20Gentium%2C%20serif%3B%20%5Cn%7D%22%2C%22id%22%3A%22FckuY%22%7D\"></card><p><br /></p><h3 id=\"1086e109\">（7）@supports（判断环境）</h3><blockquote><p>support 检查环境的特性，它与 media 比较类似</p></blockquote><h3 id=\"55be0195\">（8）@namespace（设置命名空间）</h3><blockquote><p>用于跟 XML 命名空间配合的一个规则，表示内部的 CSS 选择器全都带上特定命名空间。</p></blockquote><p><br /></p><p><span class=\"lake-fontsize-16\" style=\"color: #F5222D;\"><strong>*</strong></span>这个还没搞懂用法，暂时先记下</p><p><br /></p><h3 id=\"7bb5a181\">（9）@viewport（设置视口特性）</h3><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">用于设置视口的一些特性，不过兼容性目前不是很好，多数时候被 html 的 meta 代替。</span></p></blockquote><p><br /></p><p><br /></p><p>大概的就是这些了。有其他的话，之后再做补充吧。</p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:57:40.000Z",
    "deleted_at": null,
    "created_at": "2019-04-01T02:31:09.000Z",
    "updated_at": "2019-04-11T09:57:40.000Z",
    "published_at": "2019-04-11T09:57:40.000Z",
    "first_published_at": "2019-04-01T02:41:00.000Z",
    "word_count": 652,
    "cover": null,
    "description": "tags:  [css规则符]categories: 重学前端系列笔记---------------（0）@charset （规定页面使用什么格式）这个是标识 css 解析是按照什么字符格式解析。一般出现在css文件的最顶部。这个规则只在给出语法解析阶段前使用，并不影响页面上的展示效果@cha...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1445868,
    "slug": "htkygc",
    "title": "3. 所知道的全部对象类型",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags:  [JavaScript对象类型]<br />categories: 重学前端系列笔记<br />-------------\n<a name=\"b58e8814\"></a>\n### 宿主对象: 由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。\n*  **`JavaScript`**  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器提供了 **`location`** ** **，**`Window`** 、**`Document`** 等 **API** 都是宿主环境提供的宿主对象。\n* 其中 **`window`**`JavaScript`** 这门语言。\n*  **`JavaScript`** 标准中规定了全局对象属性，**w3c** 的各种标准中规定了 **`window`** 对象的其它属性。\n* 宿主对象也分为固有的和用户可创建的两种，比如 **`document.createElement`**  就可以创建一些 dom 对象。\n* 浏览器也会提供一些构造器，通过 **`new`**`Dom`**`New Image`**`Img`**`Dom`** 对象\n\n<a name=\"4e6b882b\"></a>\n### 内置对象：由 JavaScript 语言提供的对象。\n<a name=\"0cfe2bfe\"></a>\n#### （0）固有对象：由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。\n> 固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“**类**”其实就是固有对象的一种。\n\n<a name=\"6d4a04a5\"></a>\n#### （1）原生对象：可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。\n**原生的对象有：**<br />![6cb1df319bbc7c7f948acfdb9ffd99d0.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1553847843535-34b058d8-e34f-4ed8-9995-7aa56263e437.png#align=left&display=inline&height=273&name=6cb1df319bbc7c7f948acfdb9ffd99d0.png&originHeight=375&originWidth=988&size=110828&status=done&width=720)\n\n在使用这些对象的时候，可以通过 **`New`**  关键字创建新对象。\n<a name=\"99e0367e\"></a>\n##### 用对象来模拟函数与构造器：函数对象与构造器对象\n> 这类对象具有私有字段 [**[call]] 和 [[construct]]**，其中 \n> * [[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换\n* 任何对象只需要实现 **[[call]]**函数对象**，可以作为函数去调用\n* 而如果它能实现 **[[construct]]**，它就是一个**构造器对象**，可以作为构造器被调用。\n\n\n<a name=\"0c56e77d\"></a>\n#### 函数对象调用与构造器调用\n```javascript\nfunction f(){\n    return 1;\n}\nlet v = f(); // 把 f 作为函数调用\nlet o = new f(); // 把 f 作为构造器调用\n\n```\n\n我们大致的可以理解 **[[construct]] **的执行过程为\n* 以 Object.protoype 为原型创建一个新对象；\n* 以新对象为 this，执行函数的 [[call]]；\n* 如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。\n* **一定程度上，new创造的对象及属性，构造器之外是无法访问的，在一定程度上可以实现“私有”**\n\n**对于有 `JS` 解析引擎的地方，只要字段正常。宿主对象及内置对象也可以模仿函数对象及构造器对象。**\n\n```javascript\n// 内置对象\nlet time = new Date;\n//或者\nlet time = Date();\n// 宿主对象，在浏览器可以使用Image对象\nlet img = new Image; // 可以得到一个img Dom对象\nlet img = Image() //会抛出错误\n```\n\n<a name=\"1256caf1\"></a>\n#### *注意：     ES6语法创建的函数，仅仅是函数，是不能作为构造器使用的   \n```javascript\nnew (date=>{}) // error\n```\n\n<a name=\"73bf6b4f\"></a>\n#### （2）普通对象：由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。\n**例：**\n```javascript\nlet Child = (){};\nlet childItem = new Child\n```\n<a name=\"0d98c747\"></a>\n### 其他\n> 除了上述的对象，有一些对象跟正常的对象有很大的区别，\n> 它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同\n\n\n* **`Array`**`Array`**`length`**  属性根据最大的下标自动发生变化。\n* **`Object.prototype`** ：作为所有正常对象的默认原型，不能再给它设置原型了。\n* **`String`**`String`**  的正整数属性访问会去字符串里查找。\n* **`Arguments`**`arguments`**  的非负整数型下标属性跟对应的变量联动。\n* 模块的 **`namespace`**  对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。\n* 类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。\n* **`bind`**`function`** ：跟原来的函数相关联。\n\n",
    "body_draft": "",
    "body_html": "<p>tags:  [JavaScript对象类型]</p><p>categories: 重学前端系列笔记</p><p>-------------</p><h3 id=\"b58e8814\">宿主对象: <span class=\"lake-fontsize-10\" style=\"color: #222222;\">由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</span></h3><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><code>JavaScript</code></strong><span>  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器提供了 </span><strong><code>location</code></strong><span> </span><strong> </strong><span>，</span><strong><code>Window</code></strong><span> 、</span><strong><code>Document</code></strong><span> 等 </span><strong>API</strong><span> 都是宿主环境提供的宿主对象。</span></li><li>其中 <strong><code>window</code></strong> 对象上提供的属性，一部分来自浏览器本身，一部分来自 <strong><code>JavaScript</code></strong> 这门语言。</li><li> <strong><code>JavaScript</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">标准中规定了全局对象属性，</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">w3c</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 的各种标准中规定了</span> <strong><code>window</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象的其它属性。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">宿主对象也分为固有的和用户可创建的两种，比如 </span><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">document.createElement</span></code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 就可以创建一些 dom 对象。</span></li><li>浏览器也会提供一些构造器，通过 <strong><code>new</code></strong>  的方法，创建一个 <strong><code>Dom</code></strong>  对象，例如可以通过  <strong><code>New Image</code></strong> 的形式可以创造 <strong><code>Img</code></strong> 的 <strong><code>Dom</code></strong> 对象</li></ul><p><br /></p><h3 id=\"4e6b882b\">内置对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由 JavaScript 语言提供的对象。</span></h3><h4 id=\"0cfe2bfe\">（0）固有对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</span></h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #222222;\">固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“</span><span class=\"lake-fontsize-12\"><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">类</span></strong></span><span class=\"lake-fontsize-12\" style=\"color: #222222;\">”其实就是固有对象的一种。</span></p></blockquote><h4 id=\"6d4a04a5\">（1）原生对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</span></h4><p><strong>原生的对象有：</strong></p><p><img alt=\"6cb1df319bbc7c7f948acfdb9ffd99d0.png\" title=\"6cb1df319bbc7c7f948acfdb9ffd99d0.png\" src=\"https://cdn.nlark.com/yuque/0/2019/png/221851/1553847843535-34b058d8-e34f-4ed8-9995-7aa56263e437.png#align=left&amp;display=inline&amp;height=273&amp;name=6cb1df319bbc7c7f948acfdb9ffd99d0.png&amp;originHeight=375&amp;originWidth=988&amp;size=110828&amp;status=done&amp;width=720\" style=\"max-width: 600px; width: 720px;\" /></p><p><br /></p><p>在使用这些对象的时候，可以通过 <strong><code>New</code></strong>  关键字创建新对象。</p><h5 id=\"99e0367e\">用对象来模拟函数与构造器：函数对象与构造器对象</h5><blockquote><p>这类对象具有私有字段 [<strong>[call]] 和 </strong><strong>[[construct]]</strong>，其中 </p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换</span></li><li>任何对象只需要实现 <strong>[[call]]</strong>，它就是一个<strong>函数对象</strong>，可以作为函数去调用</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">而如果它能实现 </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]]</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，它就是一个</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">构造器对象</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，可以作为构造器被调用。</span></li></ul></blockquote><p><br /></p><h4 id=\"0c56e77d\">函数对象调用与构造器调用</h4><pre data-lang=\"javascript\"><code>function f(){\n    return 1;\n}\nlet v = f(); // 把 f 作为函数调用\nlet o = new f(); // 把 f 作为构造器调用\n</code></pre><p><br /></p><p>我们大致的可以理解<span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]] </span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">的执行过程为</span></p><ul><li>以 Object.protoype 为原型创建一个新对象；</li><li>以新对象为 this，执行函数的 [[call]]；</li><li>如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li><li><strong>一定程度上，new创造的对象及属性，构造器之外是无法访问的，在一定程度上可以实现“私有”</strong></li></ul><p><br /></p><p><strong><span>对于有 </span></strong><strong><code>JS</code></strong><strong><span> 解析引擎的地方，只要字段正常。宿主对象及内置对象也可以模仿函数对象及构造器对象。</span></strong></p><p><br /></p><pre data-lang=\"javascript\"><code>// 内置对象\nlet time = new Date;\n//或者\nlet time = Date();\n// 宿主对象，在浏览器可以使用Image对象\nlet img = new Image; // 可以得到一个img Dom对象\nlet img = Image() //会抛出错误</code></pre><p><br /></p><h4 id=\"1256caf1\"><span style=\"color: #F5222D;\">*</span><span style=\"color: #F5222D;\">注意：</span><span style=\"color: #FFFFFF;\">  </span><span style=\"color: #FFFFFF; background-color: #003A8C;\">   ES6语法创建的函数，仅仅是函数，是不能作为构造器使用的   </span></h4><pre data-lang=\"javascript\"><code>new (date=&gt;{}) // error</code></pre><p><br /></p><h4 id=\"73bf6b4f\">（2）普通对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</span></h4><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">例：</span></strong></p><pre data-lang=\"javascript\"><code>let Child = (){};\nlet childItem = new Child</code></pre><h3 id=\"0d98c747\">其他</h3><blockquote><p>除了上述的对象，有一些对象跟正常的对象有很大的区别，</p><p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同</p></blockquote><p><br /></p><ul><li><strong><code>Array</code></strong> ：<strong><code>Array</code></strong>  的 <strong><code>length</code></strong>  属性根据最大的下标自动发生变化。</li><li><strong><code>Object.prototype</code></strong> ：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li><strong><code>String</code></strong> ：为了支持下标运算，<strong><code>String</code></strong>  的正整数属性访问会去字符串里查找。</li><li><strong><code>Arguments</code></strong> ：<strong><code>arguments</code></strong>  的非负整数型下标属性跟对应的变量联动。</li><li>模块的 <strong><code>namespace</code></strong>  对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li><strong><code>bind</code></strong>  后的 <strong><code>function</code></strong> ：跟原来的函数相关联。</li></ul><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags:  [JavaScript对象类型]<cursor /></p><p>categories: 重学前端系列笔记</p><p>-------------</p><h3 id=\"b58e8814\">宿主对象: <span class=\"lake-fontsize-10\" style=\"color: #222222;\">由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。</span></h3><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><code>JavaScript</code></strong><span>  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器提供了 </span><strong><code>location</code></strong><span> </span><strong> </strong><span>，</span><strong><code>Window</code></strong><span> 、</span><strong><code>Document</code></strong><span> 等 </span><strong>API</strong><span> 都是宿主环境提供的宿主对象。</span></li><li>其中 <strong><code>window</code></strong> 对象上提供的属性，一部分来自浏览器本身，一部分来自 <strong><code>JavaScript</code></strong> 这门语言。</li><li> <strong><code>JavaScript</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">标准中规定了全局对象属性，</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">w3c</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 的各种标准中规定了</span> <strong><code>window</code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象的其它属性。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">宿主对象也分为固有的和用户可创建的两种，比如 </span><strong><code><span class=\"lake-fontsize-10\" style=\"color: #222222;\">document.createElement</span></code></strong> <span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 就可以创建一些 dom 对象。</span></li><li>浏览器也会提供一些构造器，通过 <strong><code>new</code></strong>  的方法，创建一个 <strong><code>Dom</code></strong>  对象，例如可以通过  <strong><code>New Image</code></strong> 的形式可以创造 <strong><code>Img</code></strong> 的 <strong><code>Dom</code></strong> 对象</li></ul><p><br /></p><h3 id=\"4e6b882b\">内置对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由 JavaScript 语言提供的对象。</span></h3><h4 id=\"0cfe2bfe\">（0）固有对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由标准规定，随着 JavaScript 运行时创建而自动创建的对象实例。</span></h4><blockquote><p><span class=\"lake-fontsize-12\" style=\"color: #222222;\">固有对象在任何 JS 代码执行前就已经被创建出来了，它们通常扮演者类似基础库的角色。我们前面提到的“</span><span class=\"lake-fontsize-12\"><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">类</span></strong></span><span class=\"lake-fontsize-12\" style=\"color: #222222;\">”其实就是固有对象的一种。</span></p></blockquote><h4 id=\"6d4a04a5\">（1）原生对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">可以由用户通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</span></h4><p><strong>原生的对象有：</strong></p><p><card type=\"inline\" name=\"image\" value=\"data:%7B%22src%22%3A%22https%3A%2F%2Fcdn.nlark.com%2Fyuque%2F0%2F2019%2Fpng%2F221851%2F1553847843535-34b058d8-e34f-4ed8-9995-7aa56263e437.png%22%2C%22originWidth%22%3A988%2C%22originHeight%22%3A375%2C%22name%22%3A%226cb1df319bbc7c7f948acfdb9ffd99d0.png%22%2C%22size%22%3A110828%2C%22display%22%3A%22inline%22%2C%22align%22%3A%22left%22%2C%22linkTarget%22%3A%22_blank%22%2C%22status%22%3A%22done%22%2C%22width%22%3A720%2C%22height%22%3A273%7D\"></card></p><p><br /></p><p>在使用这些对象的时候，可以通过 <strong><code>New</code></strong>  关键字创建新对象。</p><h5 id=\"99e0367e\">用对象来模拟函数与构造器：函数对象与构造器对象</h5><blockquote><p>这类对象具有私有字段 [<strong>[call]] 和 </strong><strong>[[construct]]</strong>，其中 </p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[call]] 私有字段必须是一个引擎中定义的函数，需要接受 this 值和调用参数，并且会产生域的切换</span></li><li>任何对象只需要实现 <strong>[[call]]</strong>，它就是一个<strong>函数对象</strong>，可以作为函数去调用</li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">而如果它能实现 </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]]</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，它就是一个</span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">构造器对象</span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">，可以作为构造器被调用。</span></li></ul></blockquote><p><br /></p><h4 id=\"0c56e77d\">函数对象调用与构造器调用</h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22function%20f()%7B%5Cn%20%20%20%20return%201%3B%5Cn%7D%5Cnlet%20v%20%3D%20f()%3B%20%2F%2F%20%E6%8A%8A%20f%20%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%5Cnlet%20o%20%3D%20new%20f()%3B%20%2F%2F%20%E6%8A%8A%20f%20%E4%BD%9C%E4%B8%BA%E6%9E%84%E9%80%A0%E5%99%A8%E8%B0%83%E7%94%A8%5Cn%22%2C%22id%22%3A%22hyxlj%22%7D\"></card><p><br /></p><p>我们大致的可以理解<span class=\"lake-fontsize-10\" style=\"color: #222222;\"> </span><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">[[construct]] </span></strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">的执行过程为</span></p><ul><li>以 Object.protoype 为原型创建一个新对象；</li><li>以新对象为 this，执行函数的 [[call]]；</li><li>如果 [[call]] 的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li><li><strong>一定程度上，new创造的对象及属性，构造器之外是无法访问的，在一定程度上可以实现“私有”</strong></li></ul><p><br /></p><p><strong><span>对于有 </span></strong><strong><code>JS</code></strong><strong><span> 解析引擎的地方，只要字段正常。宿主对象及内置对象也可以模仿函数对象及构造器对象。</span></strong></p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%5Cnlet%20time%20%3D%20new%20Date%3B%5Cn%2F%2F%E6%88%96%E8%80%85%5Cnlet%20time%20%3D%20Date()%3B%5Cn%2F%2F%20%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8Image%E5%AF%B9%E8%B1%A1%5Cnlet%20img%20%3D%20new%20Image%3B%20%2F%2F%20%E5%8F%AF%E4%BB%A5%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AAimg%20Dom%E5%AF%B9%E8%B1%A1%5Cnlet%20img%20%3D%20Image()%20%2F%2F%E4%BC%9A%E6%8A%9B%E5%87%BA%E9%94%99%E8%AF%AF%22%2C%22id%22%3A%224TY2S%22%7D\"></card><p><br /></p><h4 id=\"1256caf1\"><span style=\"color: #F5222D;\">*</span><span style=\"color: #F5222D;\">注意：</span><span style=\"color: #FFFFFF;\">  </span><span style=\"color: #FFFFFF; background-color: #003A8C;\">   ES6语法创建的函数，仅仅是函数，是不能作为构造器使用的   </span></h4><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22new%20(date%3D%3E%7B%7D)%20%2F%2F%20error%22%2C%22id%22%3A%22oKAPT%22%7D\"></card><p><br /></p><h4 id=\"73bf6b4f\">（2）普通对象：<span class=\"lake-fontsize-10\" style=\"color: #222222;\">由{}语法、Object 构造器或者 class 关键字定义类创建的对象，它能够被原型继承。</span></h4><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">例：</span></strong></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20Child%20%3D%20()%7B%7D%3B%5Cnlet%20childItem%20%3D%20new%20Child%22%2C%22id%22%3A%22fZxf9%22%7D\"></card><h3 id=\"0d98c747\">其他</h3><blockquote><p>除了上述的对象，有一些对象跟正常的对象有很大的区别，</p><p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同</p></blockquote><p><br /></p><ul><li><strong><code>Array</code></strong> ：<strong><code>Array</code></strong>  的 <strong><code>length</code></strong>  属性根据最大的下标自动发生变化。</li><li><strong><code>Object.prototype</code></strong> ：作为所有正常对象的默认原型，不能再给它设置原型了。</li><li><strong><code>String</code></strong> ：为了支持下标运算，<strong><code>String</code></strong>  的正整数属性访问会去字符串里查找。</li><li><strong><code>Arguments</code></strong> ：<strong><code>arguments</code></strong>  的非负整数型下标属性跟对应的变量联动。</li><li>模块的 <strong><code>namespace</code></strong>  对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li><li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li><li><strong><code>bind</code></strong>  后的 <strong><code>function</code></strong> ：跟原来的函数相关联。</li></ul><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:57:23.000Z",
    "deleted_at": null,
    "created_at": "2019-03-29T06:16:46.000Z",
    "updated_at": "2019-04-11T09:57:23.000Z",
    "published_at": "2019-04-11T09:57:23.000Z",
    "first_published_at": "2019-03-29T09:28:22.000Z",
    "word_count": 1068,
    "cover": null,
    "description": "tags:  [JavaScript对象类型]categories: 重学前端系列笔记-------------宿主对象: 由 JavaScript 宿主环境提供的对象，它们的行为完全由宿主环境决定。 JavaScript  可以运行在很多地方，但是跟我们打交道时间最长的就是浏览器。其中浏览器...",
    "custom_description": null,
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1437597,
    "slug": "rfa6hf",
    "title": "2. 重新熟悉 javascript 对象",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags:  [JavaScript对象]<br />categories: 重学前端系列笔记<br />------------\n<a name=\"5ebfcf66\"></a>\n### JavaScript 是面向对象还是基于对象？\n要想弄懂这个，就得搞清楚，什么是面向对象？\n<a name=\"78ad2473\"></a>\n#### 什么是对象？\n* 之前有说过，对象是一切有形无形物体的总称。\n* 一切的编程语言最开始都是基于人类思想思维演变而来的，在人类思维中\n> 对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。\n> 在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。\n\n\n**这样可以总结出以下的对象特征**\n1. 一个可以触摸或者可以看见的东西\n1. 人的智力可以理解的东西\n1. 可以指导思考或行动（进行想象或施加动作）的东西\n\n<a name=\"24743cc9\"></a>\n#### 怎么描述对象\n以上的总结来自  Grady Booch 的**《面向对象程序分析与设计》**根据上面的总结，由此可以得出两种描述的方式：\n* 一种就是使用类的方式，描述一类事物。然后一个个的挂载到描述的类上，挂载的事物可以继承原定的类的属性及方法，同时也可以有自己特定的方法及属性。使用这种的有，C/C++/JAVA/汇编\n> **eg：**还是拿水果举例，水果是一些事物总称，公共特点就是能吃，好吃。可以补充营养。。。。，梨子，苹果都是属于水果，那么可以归类于水果这个类上，但是每种水果有自己的一些特性。\n\n\n```javascript\n// 创建一个水果的类\nclass Fruit {\n  // 构造器\n  constructor(color,type) {\n      this.color = color;\n      this.type = type ;\n  },\n  // 作用：营养\n\taction:nutrition,\n  // 使用方法：吃\n  instructions:eat\n};\n// 描述一个苹果\nclass apple extends Fruit {\n  constructor(color, type) {\n \t\t super(color, type);\n\t},\n   // 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n   // 颜色:暗红\n   color: DarkRed,\n   // 特点:脆\n   feature: brittle,\n}\n```\n     \n* 还有一种就是原型的方式。简略的描述一个事物，之后可以慢慢的对他进行丰满的描述，这些之后丰满的描述都是挂载在最原始描述的原型上。\n\n```javascript\n// 创建一个原始对象\nlet Apple = (){\n\t// 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n};\n// 给苹果这个对象添加个吃的方法。\nApple.prototype.eat = function () {\n  console.log(\"我要吧这个苹果吃完\")\n};\n```\n\n> 但是在创造 **`JavaScript`**`JavaScript`**`Java`**`new`**`this`**`Java`** 。\n\n\n<a name=\"1022a402\"></a>\n#### JavaScript 的对象特征\n从 Grandy Booch《面向对象分析与设计》可以总结出所有的语言对象应该都具有以下特征\n* 对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。\n* 对象有状态：对象具有状态，同一对象可能处于不同状态之下。\n* 对象具有行为：即对象的状态，可能因为它的行为产生变迁。\n\n从第一个特征来看，**`JavaScript`**  中的对象。即使是具有相同属性的，也不是相同的\n\n```javascript\n let a = {\n   title: \"我要吃素\",\n };\nlet b = {\n    title: \"我要吃素\",\n};\nconsole.log(b === a) // 结果：false\n```\n这个为啥是 **`false`**  呢，学过 **`JavaScript`**  的都知道**堆**和**栈**的存在，（~~堆栈思想应该也是窃取其他语言的吧，小声比比~~）。简单数据类型存在**堆**中，复杂数据类型存在**栈**中，如果是**复杂数据浅拷贝**的话，一般是将**引用地址存在堆上**\n\n第二个特征和第三个特征来看，在 **`JavaScript`** 中，就抽象成了属性，不管是普通的属性还是函数，都是属于JavaScript的属性这个类别。\n\n```javascript\nlet test = { \n\tcode: 1,\n  fun () {\n\t   console.log(this.d);\n  }\n}\n```\n上述代码中，code 和 fun 都是属于普通的属性。<br />**在实现了对象基本特征的基础上，**`**JavaScript**` ** 中对象独有的特色是：对象具有高度的动态性，这是因为 **`**JavaScript**` ** 赋予了使用者在运行时为对象添改状态和行为的能力。**<br />**\n<a name=\"74dd9583\"></a>\n#### JavaScript 对象的属性类别\n<a name=\"f3142db4\"></a>\n##### （0）数据属性\n* **value：就是属性的值。**\n* **writable：**决定属性能否被赋值。\n* **enumerable：**决定 for in 能否枚举该属性。\n* **configurable：**决定该属性能否被删除或者改变特征值。\n<a name=\"fc50eb8e\"></a>\n##### （1）访问器属性（getter/setter）\n* **getter：**函数或 undefined，在取属性值时被调用。\n* **setter：**函数或 undefined，在设置属性值时被调用。\n* **enumerable：**决定 for in 能否枚举该属性。\n* **configurable：**决定该属性能否被删除或者改变特征值。\n\n     访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。<br />**那我们怎么查看一个对象的数据属性呢？**\n\n查看属性 **`Object.getOwnPropertyDescriptor`** \n```javascript\n    let test = { a: 1 };\n    test.b = 2;\n    //a 和 b 皆为数据属性\n    console.log( Object.getOwnPropertyDescriptor(test,\"a\") ) // {value: 1, writable: true, enumerable: true, configurable: true}\n    console.log( Object.getOwnPropertyDescriptor(test,\"b\") ) // {value: 2, writable: true, enumerable: true, configurable: true}\n```\n\n改变属性：**`Object.defineProperty`** \n\n```javascript\nlet test = { a: 1 };\n// 改变数据属性\nObject.defineProperty(test,\"a\",{value: 1, writable: false, enumerable: false, configurable: false });\n// 获取改变之后的数据属性\nconsole.log( Object.getOwnPropertyDescriptor(test,\"b\") ) // {value: 1, writable: false, enumerable: false, configurable: false }}\n```\n\n<a name=\"bafbe962\"></a>\n##### 当然在创建对象的时候，也可以使用 get 和 set 关键字来创建访问器属性\n\n```javascript\n    let test = { \n      get a() { \n        return 1 \n      } \n    };\n    console.log(test.a); // 1\n```\n\n",
    "body_draft": "",
    "body_html": "<p>tags:  [JavaScript对象]</p><p>categories: 重学前端系列笔记</p><p>------------</p><h3 id=\"5ebfcf66\">JavaScript 是面向对象还是基于对象？</h3><p>要想弄懂这个，就得搞清楚，什么是面向对象？</p><h4 id=\"78ad2473\">什么是对象？</h4><ul><li>之前有说过，对象是一切有形无形物体的总称。</li><li>一切的编程语言最开始都是基于人类思想思维演变而来的，在人类思维中</li></ul><blockquote><p><span class=\"lake-fontsize-11\">对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。</span></p><p><span class=\"lake-fontsize-11\" style=\"color: #222222;\">在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。</span></p></blockquote><p><br /></p><p><strong>这样可以总结出以下的对象特征</strong></p><ol start=\"1\"><li>一个可以触摸或者可以看见的东西</li><li>人的智力可以理解的东西</li><li>可以指导思考或行动（进行想象或施加动作）的东西</li></ol><p><br /></p><h4 id=\"24743cc9\">怎么描述对象</h4><p>以上的总结来自  Grady Booch 的<strong>《面向对象程序分析与设计》</strong><span>根据上面的总结，由此可以得出两种描述的方式：</span></p><ul><li>一种就是使用类的方式，描述一类事物。然后一个个的挂载到描述的类上，挂载的事物可以继承原定的类的属性及方法，同时也可以有自己特定的方法及属性。使用这种的有，C/C++/JAVA/汇编</li></ul><blockquote><p><strong>eg：</strong>还是拿水果举例，水果是一些事物总称，公共特点就是能吃，好吃。可以补充营养。。。。，梨子，苹果都是属于水果，那么可以归类于水果这个类上，但是每种水果有自己的一些特性。</p></blockquote><p><br /></p><pre data-lang=\"javascript\"><code>// 创建一个水果的类\nclass Fruit {\n  // 构造器\n  constructor(color,type) {\n      this.color = color;\n      this.type = type ;\n  },\n  // 作用：营养\n\taction:nutrition,\n  // 使用方法：吃\n  instructions:eat\n};\n// 描述一个苹果\nclass apple extends Fruit {\n  constructor(color, type) {\n \t\t super(color, type);\n\t},\n   // 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n   // 颜色:暗红\n   color: DarkRed,\n   // 特点:脆\n   feature: brittle,\n}</code></pre><ul><p>     </p><li>还有一种就是原型的方式。简略的描述一个事物，之后可以慢慢的对他进行丰满的描述，这些之后丰满的描述都是挂载在最原始描述的原型上。</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>// 创建一个原始对象\nlet Apple = (){\n\t// 形状: 椭圆\n\t shape:oval,\n  // 种类: 苹果\n   type:apple,\n};\n// 给苹果这个对象添加个吃的方法。\nApple.prototype.eat = function () {\n  console.log(&quot;我要吧这个苹果吃完&quot;)\n};</code></pre><p><br /></p><blockquote><p>但是在创造 <strong><code>JavaScript</code></strong> 之初，<strong><code>JavaScript</code></strong> 之父的公司要求模仿 <strong><code>Java</code></strong> ，于是在原本的原型基础上，引入 <strong><code>new</code></strong> 关键字，以及 <strong><code>this</code></strong>  的概念特性。使之更像 <strong><code>Java</code></strong> 。</p></blockquote><p><br /></p><h4 id=\"1022a402\">JavaScript 的对象特征</h4><p>从 Grandy Booch《面向对象分析与设计》可以总结出所有的语言对象应该都具有以下特征</p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象有状态：对象具有状态，同一对象可能处于不同状态之下。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有行为：即对象的状态，可能因为它的行为产生变迁。</span></li></ul><p><br /></p><p>从第一个特征来看，<strong><code>JavaScript</code></strong>  中的对象。即使是具有相同属性的，也不是相同的</p><p><br /></p><pre data-lang=\"javascript\"><code> let a = {\n   title: &quot;我要吃素&quot;,\n };\nlet b = {\n    title: &quot;我要吃素&quot;,\n};\nconsole.log(b === a) // 结果：false</code></pre><p>这个为啥是 <strong><code>false</code></strong>  呢，学过 <strong><code>JavaScript</code></strong>  的都知道<strong>堆</strong>和<strong>栈</strong>的存在，（<del>堆栈思想应该也是窃取其他语言的吧，小声比比</del><span>）。</span>简单数据类型存在<strong>堆</strong>中，复杂数据类型存在<strong>栈</strong>中，如果是<strong>复杂数据浅拷贝</strong>的话，一般是将<strong>引用地址存在堆上</strong></p><p><br /></p><p>第二个特征和第三个特征来看，在 <strong><code>JavaScript</code></strong> 中，就抽象成了属性，不管是普通的属性还是函数，都是属于JavaScript的属性这个类别。</p><p><br /></p><pre data-lang=\"javascript\"><code>let test = { \n\tcode: 1,\n  fun () {\n\t   console.log(this.d);\n  }\n}</code></pre><p>上述代码中，code 和 fun 都是属于普通的属性。</p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">在实现了对象基本特征的基础上，</span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 中对象独有的特色是：对象具有高度的动态性，这是因为 </span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 赋予了使用者在运行时为对象添改状态和行为的能力。</span></strong></p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span></strong></p><h4 id=\"74dd9583\">JavaScript 对象的属性类别</h4><h5 id=\"f3142db4\">（0）数据属性</h5><ul><li><strong>value：就是属性的值。</strong></li><li><strong>writable：</strong>决定属性能否被赋值。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><h5 id=\"fc50eb8e\">（1）访问器属性（getter/setter）</h5><ul><li><strong>getter：</strong>函数或 undefined，在取属性值时被调用。</li><li><strong>setter：</strong>函数或 undefined，在设置属性值时被调用。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><p>     访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><p><strong>那我们怎么查看一个对象的数据属性呢？</strong></p><p><br /></p><p>查看属性 <strong><code>Object.getOwnPropertyDescriptor</code></strong> </p><pre data-lang=\"javascript\"><code>    let test = { a: 1 };\n    test.b = 2;\n    //a 和 b 皆为数据属性\n    console.log( Object.getOwnPropertyDescriptor(test,&quot;a&quot;) ) // {value: 1, writable: true, enumerable: true, configurable: true}\n    console.log( Object.getOwnPropertyDescriptor(test,&quot;b&quot;) ) // {value: 2, writable: true, enumerable: true, configurable: true}</code></pre><p><br /></p><p>改变属性：<strong><code>Object.defineProperty</code></strong> </p><p><br /></p><pre data-lang=\"javascript\"><code>let test = { a: 1 };\n// 改变数据属性\nObject.defineProperty(test,&quot;a&quot;,{value: 1, writable: false, enumerable: false, configurable: false });\n// 获取改变之后的数据属性\nconsole.log( Object.getOwnPropertyDescriptor(test,&quot;b&quot;) ) // {value: 1, writable: false, enumerable: false, configurable: false }}</code></pre><p><br /></p><h5 id=\"bafbe962\">当然在创建对象的时候，也可以使用 get 和 set 关键字来创建访问器属性</h5><p><br /></p><pre data-lang=\"javascript\"><code>    let test = { \n      get a() { \n        return 1 \n      } \n    };\n    console.log(test.a); // 1</code></pre><p><br /></p>",
    "body_lake": "<!doctype lake><p>tags:  [JavaScript对象]<cursor /></p><p>categories: 重学前端系列笔记</p><p>------------</p><h3 id=\"5ebfcf66\">JavaScript 是面向对象还是基于对象？</h3><p>要想弄懂这个，就得搞清楚，什么是面向对象？</p><h4 id=\"78ad2473\">什么是对象？</h4><ul><li>之前有说过，对象是一切有形无形物体的总称。</li><li>一切的编程语言最开始都是基于人类思想思维演变而来的，在人类思维中</li></ul><blockquote><p><span class=\"lake-fontsize-11\">对象这一概念在人类的幼儿期形成，这远远早于我们编程逻辑中常用的值、过程等概念。</span></p><p><span class=\"lake-fontsize-11\" style=\"color: #222222;\">在幼年期，我们总是先认识到某一个苹果能吃（这里的某一个苹果就是一个对象），继而认识到所有的苹果都可以吃（这里的所有苹果，就是一个类），再到后来我们才能意识到三个苹果和三个梨之间的联系，进而产生数字“3”（值）的概念。</span></p></blockquote><p><br /></p><p><strong>这样可以总结出以下的对象特征</strong></p><ol start=\"1\"><li>一个可以触摸或者可以看见的东西</li><li>人的智力可以理解的东西</li><li>可以指导思考或行动（进行想象或施加动作）的东西</li></ol><p><br /></p><h4 id=\"24743cc9\">怎么描述对象</h4><p>以上的总结来自  Grady Booch 的<strong>《面向对象程序分析与设计》</strong><span>根据上面的总结，由此可以得出两种描述的方式：</span></p><ul><li>一种就是使用类的方式，描述一类事物。然后一个个的挂载到描述的类上，挂载的事物可以继承原定的类的属性及方法，同时也可以有自己特定的方法及属性。使用这种的有，C/C++/JAVA/汇编</li></ul><blockquote><p><strong>eg：</strong>还是拿水果举例，水果是一些事物总称，公共特点就是能吃，好吃。可以补充营养。。。。，梨子，苹果都是属于水果，那么可以归类于水果这个类上，但是每种水果有自己的一些特性。</p></blockquote><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E6%B0%B4%E6%9E%9C%E7%9A%84%E7%B1%BB%5Cnclass%20Fruit%20%7B%5Cn%20%20%2F%2F%20%E6%9E%84%E9%80%A0%E5%99%A8%5Cn%20%20constructor(color%2Ctype)%20%7B%5Cn%20%20%20%20%20%20this.color%20%3D%20color%3B%5Cn%20%20%20%20%20%20this.type%20%3D%20type%20%3B%5Cn%20%20%7D%2C%5Cn%20%20%2F%2F%20%E4%BD%9C%E7%94%A8%EF%BC%9A%E8%90%A5%E5%85%BB%5Cn%5Ctaction%3Anutrition%2C%5Cn%20%20%2F%2F%20%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%EF%BC%9A%E5%90%83%5Cn%20%20instructions%3Aeat%5Cn%7D%3B%5Cn%2F%2F%20%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%AA%E8%8B%B9%E6%9E%9C%5Cnclass%20apple%20extends%20Fruit%20%7B%5Cn%20%20constructor(color%2C%20type)%20%7B%5Cn%20%5Ct%5Ct%20super(color%2C%20type)%3B%5Cn%5Ct%7D%2C%5Cn%20%20%20%2F%2F%20%E5%BD%A2%E7%8A%B6%3A%20%E6%A4%AD%E5%9C%86%5Cn%5Ct%20shape%3Aoval%2C%5Cn%20%20%2F%2F%20%E7%A7%8D%E7%B1%BB%3A%20%E8%8B%B9%E6%9E%9C%5Cn%20%20%20type%3Aapple%2C%5Cn%20%20%20%2F%2F%20%E9%A2%9C%E8%89%B2%3A%E6%9A%97%E7%BA%A2%5Cn%20%20%20color%3A%20DarkRed%2C%5Cn%20%20%20%2F%2F%20%E7%89%B9%E7%82%B9%3A%E8%84%86%5Cn%20%20%20feature%3A%20brittle%2C%5Cn%7D%22%2C%22id%22%3A%22eEEe6%22%7D\"></card><ul><p>     </p><li>还有一种就是原型的方式。简略的描述一个事物，之后可以慢慢的对他进行丰满的描述，这些之后丰满的描述都是挂载在最原始描述的原型上。</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%A7%8B%E5%AF%B9%E8%B1%A1%5Cnlet%20Apple%20%3D%20()%7B%5Cn%5Ct%2F%2F%20%E5%BD%A2%E7%8A%B6%3A%20%E6%A4%AD%E5%9C%86%5Cn%5Ct%20shape%3Aoval%2C%5Cn%20%20%2F%2F%20%E7%A7%8D%E7%B1%BB%3A%20%E8%8B%B9%E6%9E%9C%5Cn%20%20%20type%3Aapple%2C%5Cn%7D%3B%5Cn%2F%2F%20%E7%BB%99%E8%8B%B9%E6%9E%9C%E8%BF%99%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%B7%BB%E5%8A%A0%E4%B8%AA%E5%90%83%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82%5CnApple.prototype.eat%20%3D%20function%20()%20%7B%5Cn%20%20console.log(%5C%22%E6%88%91%E8%A6%81%E5%90%A7%E8%BF%99%E4%B8%AA%E8%8B%B9%E6%9E%9C%E5%90%83%E5%AE%8C%5C%22)%5Cn%7D%3B%22%2C%22id%22%3A%22MM6KQ%22%7D\"></card><p><br /></p><blockquote><p>但是在创造 <strong><code>JavaScript</code></strong> 之初，<strong><code>JavaScript</code></strong> 之父的公司要求模仿 <strong><code>Java</code></strong> ，于是在原本的原型基础上，引入 <strong><code>new</code></strong> 关键字，以及 <strong><code>this</code></strong>  的概念特性。使之更像 <strong><code>Java</code></strong> 。</p></blockquote><p><br /></p><h4 id=\"1022a402\">JavaScript 的对象特征</h4><p>从 Grandy Booch《面向对象分析与设计》可以总结出所有的语言对象应该都具有以下特征</p><ul><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象有状态：对象具有状态，同一对象可能处于不同状态之下。</span></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">对象具有行为：即对象的状态，可能因为它的行为产生变迁。</span></li></ul><p><br /></p><p>从第一个特征来看，<strong><code>JavaScript</code></strong>  中的对象。即使是具有相同属性的，也不是相同的</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20let%20a%20%3D%20%7B%5Cn%20%20%20title%3A%20%5C%22%E6%88%91%E8%A6%81%E5%90%83%E7%B4%A0%5C%22%2C%5Cn%20%7D%3B%5Cnlet%20b%20%3D%20%7B%5Cn%20%20%20%20title%3A%20%5C%22%E6%88%91%E8%A6%81%E5%90%83%E7%B4%A0%5C%22%2C%5Cn%7D%3B%5Cnconsole.log(b%20%3D%3D%3D%20a)%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9Afalse%22%2C%22id%22%3A%22gJz0j%22%7D\"></card><p>这个为啥是 <strong><code>false</code></strong>  呢，学过 <strong><code>JavaScript</code></strong>  的都知道<strong>堆</strong>和<strong>栈</strong>的存在，（<del>堆栈思想应该也是窃取其他语言的吧，小声比比</del><span>）。</span>简单数据类型存在<strong>堆</strong>中，复杂数据类型存在<strong>栈</strong>中，如果是<strong>复杂数据浅拷贝</strong>的话，一般是将<strong>引用地址存在堆上</strong></p><p><br /></p><p>第二个特征和第三个特征来看，在 <strong><code>JavaScript</code></strong> 中，就抽象成了属性，不管是普通的属性还是函数，都是属于JavaScript的属性这个类别。</p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20test%20%3D%20%7B%20%5Cn%5Ctcode%3A%201%2C%5Cn%20%20fun%20()%20%7B%5Cn%5Ct%20%20%20console.log(this.d)%3B%5Cn%20%20%7D%5Cn%7D%22%2C%22id%22%3A%22PsqPU%22%7D\"></card><p>上述代码中，code 和 fun 都是属于普通的属性。</p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">在实现了对象基本特征的基础上，</span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 中对象独有的特色是：对象具有高度的动态性，这是因为 </span></strong><code><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\">JavaScript</span></strong></code> <strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"> 赋予了使用者在运行时为对象添改状态和行为的能力。</span></strong></p><p><strong><span class=\"lake-fontsize-10\" style=\"color: #222222;\"><br /></span></strong></p><h4 id=\"74dd9583\">JavaScript 对象的属性类别</h4><h5 id=\"f3142db4\">（0）数据属性</h5><ul><li><strong>value：就是属性的值。</strong></li><li><strong>writable：</strong>决定属性能否被赋值。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><h5 id=\"fc50eb8e\">（1）访问器属性（getter/setter）</h5><ul><li><strong>getter：</strong>函数或 undefined，在取属性值时被调用。</li><li><strong>setter：</strong>函数或 undefined，在设置属性值时被调用。</li><li><strong>enumerable：</strong>决定 for in 能否枚举该属性。</li><li><strong>configurable：</strong>决定该属性能否被删除或者改变特征值。</li></ul><p>     访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p><p><strong>那我们怎么查看一个对象的数据属性呢？</strong></p><p><br /></p><p>查看属性 <strong><code>Object.getOwnPropertyDescriptor</code></strong> </p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20%20%20%20let%20test%20%3D%20%7B%20a%3A%201%20%7D%3B%5Cn%20%20%20%20test.b%20%3D%202%3B%5Cn%20%20%20%20%2F%2Fa%20%E5%92%8C%20b%20%E7%9A%86%E4%B8%BA%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%5Cn%20%20%20%20console.log(%20Object.getOwnPropertyDescriptor(test%2C%5C%22a%5C%22)%20)%20%2F%2F%20%7Bvalue%3A%201%2C%20writable%3A%20true%2C%20enumerable%3A%20true%2C%20configurable%3A%20true%7D%5Cn%20%20%20%20console.log(%20Object.getOwnPropertyDescriptor(test%2C%5C%22b%5C%22)%20)%20%2F%2F%20%7Bvalue%3A%202%2C%20writable%3A%20true%2C%20enumerable%3A%20true%2C%20configurable%3A%20true%7D%22%2C%22id%22%3A%22o9Xau%22%7D\"></card><p><br /></p><p>改变属性：<strong><code>Object.defineProperty</code></strong> </p><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20test%20%3D%20%7B%20a%3A%201%20%7D%3B%5Cn%2F%2F%20%E6%94%B9%E5%8F%98%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%5CnObject.defineProperty(test%2C%5C%22a%5C%22%2C%7Bvalue%3A%201%2C%20writable%3A%20false%2C%20enumerable%3A%20false%2C%20configurable%3A%20false%20%7D)%3B%5Cn%2F%2F%20%E8%8E%B7%E5%8F%96%E6%94%B9%E5%8F%98%E4%B9%8B%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E5%B1%9E%E6%80%A7%5Cnconsole.log(%20Object.getOwnPropertyDescriptor(test%2C%5C%22b%5C%22)%20)%20%2F%2F%20%7Bvalue%3A%201%2C%20writable%3A%20false%2C%20enumerable%3A%20false%2C%20configurable%3A%20false%20%7D%7D%22%2C%22id%22%3A%22oxUDt%22%7D\"></card><p><br /></p><h5 id=\"bafbe962\">当然在创建对象的时候，也可以使用 get 和 set 关键字来创建访问器属性</h5><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20%20%20%20let%20test%20%3D%20%7B%20%5Cn%20%20%20%20%20%20get%20a()%20%7B%20%5Cn%20%20%20%20%20%20%20%20return%201%20%5Cn%20%20%20%20%20%20%7D%20%5Cn%20%20%20%20%7D%3B%5Cn%20%20%20%20console.log(test.a)%3B%20%2F%2F%201%22%2C%22id%22%3A%22mfeB6%22%7D\"></card><p><br /></p>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:57:12.000Z",
    "deleted_at": null,
    "created_at": "2019-03-27T15:57:18.000Z",
    "updated_at": "2019-04-11T09:57:13.000Z",
    "published_at": "2019-04-11T09:57:12.000Z",
    "first_published_at": "2019-03-27T15:58:11.000Z",
    "word_count": 1465,
    "cover": "",
    "description": "tags:  [JavaScript对象]categories: 重学前端系列笔记------------JavaScript 是面向对象还是基于对象？要想弄懂这个，就得搞清楚，什么是面向对象？什么是对象？之前有说过，对象是一切有形无形物体的总称。一切的编程语言最开始都是基于人类思想思维演变而...",
    "custom_description": "",
    "_serializer": "v2.doc_detail"
  },
  {
    "id": 1432513,
    "slug": "wuxin",
    "title": "1. 重新认识 JavaScript 类型",
    "book_id": 251144,
    "book": {
      "id": 251144,
      "type": "Book",
      "slug": "nb",
      "name": "个人知识体系重建",
      "user_id": 221851,
      "description": "在看 witter 大神的《重学前端》有感，简单记录一下笔记。每天一篇笔记，搞懂一个知识点",
      "creator_id": 221851,
      "public": 1,
      "items_count": 8,
      "likes_count": 0,
      "watches_count": 3,
      "content_updated_at": "2019-04-11T09:58:31.790Z",
      "updated_at": "2019-04-11T09:58:31.000Z",
      "created_at": "2019-03-27T03:12:47.000Z",
      "namespace": "wuxintomgxue/nb",
      "user": {
        "id": 221851,
        "type": "User",
        "login": "wuxintomgxue",
        "name": "无心",
        "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
        "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
        "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
        "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
        "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
        "books_count": 1,
        "public_books_count": 1,
        "followers_count": 0,
        "following_count": 0,
        "created_at": "2018-12-08T15:44:23.000Z",
        "updated_at": "2019-04-11T01:48:58.000Z",
        "_serializer": "v2.user"
      },
      "_serializer": "v2.book"
    },
    "user_id": 221851,
    "creator": {
      "id": 221851,
      "type": "User",
      "login": "wuxintomgxue",
      "name": "无心",
      "description": "没啥好介绍，就是个普通的代码搬运工。从代码的这头搬运到那头",
      "avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png",
      "large_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_320,h_320",
      "medium_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_160,h_160",
      "small_avatar_url": "https://cdn.nlark.com/yuque/0/2018/png/221851/1544284103639-6b48c531-d511-407a-9654-3c0148cd04c9.png?x-oss-process=image/resize,m_fill,w_80,h_80",
      "books_count": 1,
      "public_books_count": 1,
      "followers_count": 0,
      "following_count": 0,
      "created_at": "2018-12-08T15:44:23.000Z",
      "updated_at": "2019-04-11T01:48:58.000Z",
      "_serializer": "v2.user"
    },
    "format": "lake",
    "body": "tags: [JavaScript数据类型]<br />categories: 重学前端系列笔记<br />--------------\n<a name=\"df368884\"></a>\n### 前言\n最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。\n<a name=\"49448199\"></a>\n### 补充*\n* 变量声明跟赋值，是两个概念。\n* **`let a`** 是属于变量声明阶段，这个阶段所有的变量的值都是 **`undefined`** 。**`a = 12`**`JS`** 解析引擎。这个变量是什么类型以及它的值多少。\n<a name=\"2746c81b\"></a>\n### JavaScript现有常见类型\n* Null\n* Undefined\n* String\n* Boolean\n* Number\n* Symbol\n* Object\n\n现在JavaScript常见类型是这么多，其中只有 `Symbol`  是 `ES6` 新提出来的，其余都是 `ES6` 之前早就熟悉的类\n<a name=\"c23f5abf\"></a>\n#### （0）Null\n* 这个类型表示：**定义了但是为空**\n* Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。\n<a name=\"357bda8a\"></a>\n#### （1）Undefined\n* 这个类型表示：**变量定义了但是未赋值**\n* 任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值\n* 它同样的表示一个变量的值，它并非一个关键词，这是 `JavaScript`  语言公认的设计失误之一，所以，所以，我们为了避免无意中被篡改，我建议使用 `void 0` 来来获取 `Nudefined` 值。\n* 它与 `Null` 的不同就是，`Null` 是 `JavaScript` 的关键字，在开发中可以自由的获取 `Null` 类型的变量\n<a name=\"f9369aa0\"></a>\n#### （2）Boolean\n* 这个类型表示：**逻辑上的真和假**\n* 它有两个值：`true` 和 `false` \n* 它属于 `JavaScript` 中的内置对象，可以通过 `new` 关键词创造实例对象\n<a name=\"ece22d59\"></a>\n#### （3）String\n* 这个类型表示：表示文本数据\n* 这个类型具有长度单位的，最大的长度 **`2^53-1`** ，\n* 这个 `String` 并非文本意义的字符串，而是字符串的 `UTF16` 编码，我们日常操作字符使用的 `length` `charAt` 都是针对 `UTF16` 编码\n* 字符串的最大长度是受经过 `UTF16` 编码之后的字符长度限制\n<a name=\"932cf868\"></a>\n#### 补充编码知识\n> Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。\n\n<a name=\"a887f81c\"></a>\n#### （4）Number\n* 这个类型表示：通常意义的数字类型\n* 它是 `JavaScript` 的内置对象，可以通过 `new` 关键字创造实例\n* 它类型有 `**2^64-2^53+3**` 个值\n* 在为了避免计算的时候出错，借鉴生活中的数学，引入了 `NaN` (这个可以用来检测是否为数字类型)、Infinity(正无穷大)、-Infinity(负无穷大)\n* 在加减法中 **-0**+0 **没有很大的区别，但是在除法中就会很大的区别了\n\n```javascript\nconsole.log(.00001 / -0); //结果：-Infinity\nconsole.log(.00000000001 / 0); //结果: Infinity\n```\n\n* 根据双精度浮点数的定义，Number 类型中有效的整数范围是-0x1fffffffffffff 至0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。所以在非整数面前是无法使用 `==` 或者 `===` 进行比较的\n\n```javascript\nconsole.log( .1 + .2 == .3 ); //结果：false;\nconsole.log(.1 + .2);  // 结果：0.30000000000000004\n```\n* 正确的比较两边数值是否相等，应该比较左右两边差的绝对值是否小于最小精度\n\n```javascript\nconsole.log(Math.abs(.1 + .2 - .3) <=Number.EPSILON); // true\n```\n\n> **Number.EPSILON**ES6 **Number **的一个常量。\n> **Number.EPSILON** 实际上是 **JavaScript** 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。\n\n<a name=\"780b6ec0\"></a>\n#### （5）Object\n* 这个类型表示：**对象**，它是一切有形和无形物体的总称\n* 它是属性的集合，是 **`key-value`** 结构\n* **key : **可以是字符串类型。也可以是symbol类型\n* **value :**可以是字符串，可以是数值类型。也可以是对象类型\n<a name=\"c91ff6ed\"></a>\n#### （6）Symbol\n* 这个类型是 `**ES6**` 新增的一个类型。其实说实话，到现在还不太清楚这个类型的作用，以及用法\n* 它是一切非字符串的对象 key 的集合\n* Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等\n\n```javascript\n// 创建 Symbol 类型\nlet symbol = Symbol(\"其实，我是一个好人\");\nconsole.log(symbol)\n```\n\n* 这个类型还是有很多不懂，之后有了新收获，再过来更新吧\n<a name=\"f3c723ec\"></a>\n### 类型转换\n<a name=\"2f9540a5\"></a>\n#### （0）string → Number(字符串转成数值类型)\n* 常见都是借助 `JavaScript` 中的内置方法进行转换，例如 `**parseInt**`  `**parseFloat**` 都是将字符串转化成数值类型。但是  `**parseInt**` 是遇到非数值就停下，而** ** `**parseFloat**` 遇到不属于数字行列才会停，\n* `**parseInt**` `**parseFloat**`  转化的字符串，如果第一个字符不是数字的话，就会返回 **NaN**\n* 除了上述的两种，还有 **`JavaScript`**Math  **NaN **\n* 还有一种就是利用装箱操作，利用 **`Number`**NaN**\n* 如果字符串的字符都是数字。那么可以使用四则运算，也可以进行隐士转换\n\n```javascript\n console.log(parseInt(\"6340.54\")); // 结果:6340\n console.log(parseFloat(\"4.648781655wr我是1\"));结果:4.648781655\n console.log(Number(\"2.2.22\")); // 结果:NaN\n console.log(Number(\"5464646\")) // 结果: 5464646\n```\n\n<a name=\"6c2395fb\"></a>\n#### （1）Number → string (数字转化成字符串)\n* 字符串拼接\n\n```javascript\nlet str = 121343454545;\nstr = str+ \"\";\nconsole.log(typeof(str)) // 结果：string\n```\n\n* 装箱转换\n```javascript\nlet str = 13243545646;\nconsole.log( typeof( String(str) ) ) // 结果：string \n```\n\n<a name=\"0e1aa6d1\"></a>\n#### （2）装箱操作转换\n* 在 `**JavaScript**` 中，类型之间存在装箱转换操作\n\n```javascript\n let str = 1323;\n console.log(typeof (String(str))); // string\n console.log(typeof (Symbol(str))) // symbol\n```\n\n<a name=\"f0dde815\"></a>\n### 其他的数据类型\n* **`List`**  和  **`Record`** ： 用于描述函数传参过程。\n* `**Set**` ：主要用于解释字符集等。\n* **`Completion Record`** ：用于描述异常、跳出等语句执行过程。\n* **`Reference`** ：用于描述对象属性访问、delete 等。\n* **`Property Descriptor`** ：用于描述对象的属性。\n* **`Lexical Environment`**  和  **`Environment Record`** ：用于描述变量和作用域。\n* **`Data Block`** ：用于描述二进制数据。\n<a name=\"7aa17298\"></a>\n### 程序 = 算法 + 数据结构\n",
    "body_draft": "",
    "body_html": "<p>tags: [JavaScript数据类型]</p><p>categories: 重学前端系列笔记</p><p>--------------</p><h3 id=\"df368884\">前言</h3><p>最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。</p><h3 id=\"49448199\">补充<span style=\"color: #F5222D;\">*</span></h3><ul><li><span class=\"lake-fontsize-12\">变量声明跟赋值，是两个概念。</span></li><li><span class=\"lake-fontsize-12\"><strong><code>let a</code></strong> 是属于变量声明阶段，这个阶段所有的变量的值都是 </span><strong><code><span class=\"lake-fontsize-12\">undefined</span></code></strong> <span class=\"lake-fontsize-12\">。</span><strong><code><span class=\"lake-fontsize-12\">a = 12</span></code></strong> 是赋值阶段，这个阶段是告诉 <strong><code>JS</code></strong> 解析引擎。这个变量是什么类型以及它的值多少。</li></ul><h3 id=\"2746c81b\">JavaScript现有常见类型</h3><ul><li>Null</li><li>Undefined</li><li>String</li><li>Boolean</li><li>Number</li><li>Symbol</li><li>Object</li></ul><p>现在JavaScript常见类型是这么多，其中只有 <code>Symbol</code>  是 <code>ES6</code> 新提出来的，其余都是 <code>ES6</code> 之前早就熟悉的类</p><h4 id=\"c23f5abf\">（0）Null</h4><ul><li>这个类型表示：<strong>定义了但是为空</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</span></li></ul><h4 id=\"357bda8a\">（1）Undefined</h4><ul><li>这个类型表示：<strong>变量定义了但是未赋值</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值</span></li><li>它同样的表示一个变量的值，它并非一个关键词，这是 <code>JavaScript</code>  语言公认的设计失误之一，所以，所以，我们为了避免无意中被篡改，我建议使用 <code>void 0</code> 来来获取 <code>Nudefined</code> 值。</li><li>它与 <code>Null</code> 的不同就是，<code>Null</code> 是 <code>JavaScript</code> 的关键字，在开发中可以自由的获取 <code>Null</code> 类型的变量</li></ul><h4 id=\"f9369aa0\">（2）Boolean</h4><ul><li>这个类型表示：<strong>逻辑上的真和假</strong></li><li>它有两个值：<code>true</code> 和 <code>false</code> </li><li>它属于 <code>JavaScript</code> 中的内置对象，可以通过 <code>new</code> 关键词创造实例对象</li></ul><h4 id=\"ece22d59\">（3）String</h4><ul><li>这个类型表示：表示文本数据</li><li>这个类型具有长度单位的，最大的长度 <strong><code>2^53-1</code></strong> ，</li><li>这个 <code>String</code> 并非文本意义的字符串，而是字符串的 <code>UTF16</code> 编码，我们日常操作字符使用的 <code>length</code> <code>charAt</code> 都是针对 <code>UTF16</code> 编码</li><li>字符串的最大长度是受经过 <code>UTF16</code> 编码之后的字符长度限制</li></ul><h4 id=\"932cf868\">补充编码知识</h4><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。</span></p></blockquote><h4 id=\"a887f81c\">（4）Number</h4><ul><li>这个类型表示：通常意义的数字类型</li><li>它是 <code>JavaScript</code> 的内置对象，可以通过 <code>new</code> 关键字创造实例</li><li>它类型有 <code><strong>2^64-2^53+3</strong></code> 个值</li><li>在为了避免计算的时候出错，借鉴生活中的数学，引入了 <code>NaN</code> (这个可以用来检测是否为数字类型)、Infinity(正无穷大)、-Infinity(负无穷大)</li><li>在加减法中 <strong>-0</strong>和<strong>+0 </strong>没有很大的区别，但是在除法中就会很大的区别了</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>console.log(.00001 / -0); //结果：-Infinity\nconsole.log(.00000000001 / 0); //结果: Infinity</code></pre><p><br /></p><ul><li>根据双精度浮点数的定义，Number 类型中有效的整数范围是-0x1fffffffffffff 至0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。所以在非整数面前是无法使用 <code>==</code> 或者 <code>===</code> 进行比较的</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>console.log( .1 + .2 == .3 ); //结果：false;\nconsole.log(.1 + .2);  // 结果：0.30000000000000004</code></pre><ul><li>正确的比较两边数值是否相等，应该比较左右两边差的绝对值是否小于最小精度</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>console.log(Math.abs(.1 + .2 - .3) &lt;=Number.EPSILON); // true</code></pre><p><br /></p><blockquote><p><strong><span>Number.EPSILON</span></strong> 它是 <strong>ES6 </strong>新出的一个挂载在 <strong>Number </strong>的一个常量。</p><p><strong><span>N</span></strong><strong><span>u</span></strong><strong>mber.EPSILON</strong><span> </span><span class=\"lake-fontsize-12\">实际上是 </span><strong><span class=\"lake-fontsize-12\" style=\"color: #333333;\">JavaScript</span></strong><span class=\"lake-fontsize-12\"> 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</span></p></blockquote><h4 id=\"780b6ec0\">（5）Object</h4><ul><li>这个类型表示：<strong>对象</strong>，它是一切有形和无形物体的总称</li><li>它是属性的集合，是 <strong><code>key-value</code></strong> 结构</li><li><strong>key : </strong>可以是字符串类型。也可以是symbol类型</li><li><strong>value :</strong>可以是字符串，可以是数值类型。也可以是对象类型</li></ul><h4 id=\"c91ff6ed\">（6）Symbol</h4><ul><li>这个类型是 <code><strong>ES6</strong></code> 新增的一个类型。其实说实话，到现在还不太清楚这个类型的作用，以及用法</li><li>它是一切非字符串的对象 key 的集合</li><li>Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>// 创建 Symbol 类型\nlet symbol = Symbol(&quot;其实，我是一个好人&quot;);\nconsole.log(symbol)</code></pre><p><br /></p><ul><li>这个类型还是有很多不懂，之后有了新收获，再过来更新吧</li></ul><h3 id=\"f3c723ec\">类型转换</h3><h4 id=\"2f9540a5\">（0）string → Number(<span>字符串转成数值类型</span>)</h4><ul><li>常见都是借助 <code>JavaScript</code> 中的内置方法进行转换，例如 <code><strong>parseInt</strong></code>  <code><strong>parseFloat</strong></code> 都是将字符串转化成数值类型。但是  <code><strong>parseInt</strong></code> 是遇到非数值就停下，而<strong> </strong> <code><strong>parseFloat</strong></code> 遇到不属于数字行列才会停，</li><li><code><strong>parseInt</strong></code> <code><strong>parseFloat</strong></code>  转化的字符串，如果第一个字符不是数字的话，就会返回 <strong>NaN</strong></li><li>除了上述的两种，还有 <strong><code>JavaScript</code></strong> 内置的 <strong>Math  </strong>方法也可以隐式的转化成数值，但是依然是如果第一个字符不是数值的话，就会返回 <strong>NaN </strong></li><li>还有一种就是利用装箱操作，利用 <strong><code>Number</code></strong> 进行转换，这个转换的好处就是，只要转换的字符不属于数值类型的，都会返回 <strong>NaN</strong></li><li>如果字符串的字符都是数字。那么可以使用四则运算，也可以进行隐士转换</li></ul><p><br /></p><pre data-lang=\"javascript\"><code> console.log(parseInt(&quot;6340.54&quot;)); // 结果:6340\n console.log(parseFloat(&quot;4.648781655wr我是1&quot;));结果:4.648781655\n console.log(Number(&quot;2.2.22&quot;)); // 结果:NaN\n console.log(Number(&quot;5464646&quot;)) // 结果: 5464646</code></pre><p><br /></p><h4 id=\"6c2395fb\">（1）Number → string (数字转化成字符串)</h4><ul><li>字符串拼接</li><p><br /></p></ul><pre data-lang=\"javascript\"><code>let str = 121343454545;\nstr = str+ &quot;&quot;;\nconsole.log(typeof(str)) // 结果：string</code></pre><p><br /></p><ul><li>装箱转换</li></ul><pre data-lang=\"javascript\"><code>let str = 13243545646;\nconsole.log( typeof( String(str) ) ) // 结果：string </code></pre><p><br /></p><h4 id=\"0e1aa6d1\">（2）装箱操作转换</h4><ul><li>在 <code><strong>JavaScript</strong></code> 中，类型之间存在装箱转换操作</li><p><br /></p></ul><pre data-lang=\"javascript\"><code> let str = 1323;\n console.log(typeof (String(str))); // string\n console.log(typeof (Symbol(str))) // symbol</code></pre><p><br /></p><h3 id=\"f0dde815\">其他的数据类型</h3><ul><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">List</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">： 用于描述函数传参过程。</span></li><li><code><strong><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Set</span></strong></code> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：主要用于解释字符集等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Completion Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述异常、跳出等语句执行过程。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Reference</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象属性访问、delete 等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Property Descriptor</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象的属性。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Lexical Environment</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Environment Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述变量和作用域。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Data Block</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述二进制数据。</span></li></ul><h3 id=\"7aa17298\">程序 = 算法 + 数据结构</h3>",
    "body_lake": "<!doctype lake><p>tags: [JavaScript数据类型]<cursor /></p><p>categories: 重学前端系列笔记</p><p>--------------</p><h3 id=\"df368884\">前言</h3><p>最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。</p><h3 id=\"49448199\">补充<span style=\"color: #F5222D;\">*</span></h3><ul><li><span class=\"lake-fontsize-12\">变量声明跟赋值，是两个概念。</span></li><li><span class=\"lake-fontsize-12\"><strong><code>let a</code></strong> 是属于变量声明阶段，这个阶段所有的变量的值都是 </span><strong><code><span class=\"lake-fontsize-12\">undefined</span></code></strong> <span class=\"lake-fontsize-12\">。</span><strong><code><span class=\"lake-fontsize-12\">a = 12</span></code></strong> 是赋值阶段，这个阶段是告诉 <strong><code>JS</code></strong> 解析引擎。这个变量是什么类型以及它的值多少。</li></ul><h3 id=\"2746c81b\">JavaScript现有常见类型</h3><ul><li>Null</li><li>Undefined</li><li>String</li><li>Boolean</li><li>Number</li><li>Symbol</li><li>Object</li></ul><p>现在JavaScript常见类型是这么多，其中只有 <code>Symbol</code>  是 <code>ES6</code> 新提出来的，其余都是 <code>ES6</code> 之前早就熟悉的类</p><h4 id=\"c23f5abf\">（0）Null</h4><ul><li>这个类型表示：<strong>定义了但是为空</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Null 类型也只有一个值，就是 null，它的语义表示空值，与 undefined 不同，null 是 JavaScript 关键字，所以在任何代码中，你都可以放心用 null 关键字来获取 null 值。</span></li></ul><h4 id=\"357bda8a\">（1）Undefined</h4><ul><li>这个类型表示：<strong>变量定义了但是未赋值</strong></li><li><span class=\"lake-fontsize-10\" style=\"color: #222222;\">任何变量在赋值前是 Undefined 类型、值为 undefined，一般我们可以用全局变量 undefined（就是名为 undefined 的这个变量）来表达这个值</span></li><li>它同样的表示一个变量的值，它并非一个关键词，这是 <code>JavaScript</code>  语言公认的设计失误之一，所以，所以，我们为了避免无意中被篡改，我建议使用 <code>void 0</code> 来来获取 <code>Nudefined</code> 值。</li><li>它与 <code>Null</code> 的不同就是，<code>Null</code> 是 <code>JavaScript</code> 的关键字，在开发中可以自由的获取 <code>Null</code> 类型的变量</li></ul><h4 id=\"f9369aa0\">（2）Boolean</h4><ul><li>这个类型表示：<strong>逻辑上的真和假</strong></li><li>它有两个值：<code>true</code> 和 <code>false</code> </li><li>它属于 <code>JavaScript</code> 中的内置对象，可以通过 <code>new</code> 关键词创造实例对象</li></ul><h4 id=\"ece22d59\">（3）String</h4><ul><li>这个类型表示：表示文本数据</li><li>这个类型具有长度单位的，最大的长度 <strong><code>2^53-1</code></strong> ，</li><li>这个 <code>String</code> 并非文本意义的字符串，而是字符串的 <code>UTF16</code> 编码，我们日常操作字符使用的 <code>length</code> <code>charAt</code> 都是针对 <code>UTF16</code> 编码</li><li>字符串的最大长度是受经过 <code>UTF16</code> 编码之后的字符长度限制</li></ul><h4 id=\"932cf868\">补充编码知识</h4><blockquote><p><span class=\"lake-fontsize-10\" style=\"color: #222222;\">Note：现行的字符集国际标准，字符是以 Unicode 的方式表示的，每一个 Unicode 的码点表示一个字符，理论上，Unicode 的范围是无限的。UTF 是 Unicode 的编码方式，规定了码点在计算机中的表示方法，常见的有 UTF16 和 UTF8。 Unicode 的码点通常用 U+??? 来表示，其中 ??? 是十六进制的码点值。 0-65536（U+0000 - U+FFFF）的码点被称为基本字符区域（BMP）。</span></p></blockquote><h4 id=\"a887f81c\">（4）Number</h4><ul><li>这个类型表示：通常意义的数字类型</li><li>它是 <code>JavaScript</code> 的内置对象，可以通过 <code>new</code> 关键字创造实例</li><li>它类型有 <code><strong>2^64-2^53+3</strong></code> 个值</li><li>在为了避免计算的时候出错，借鉴生活中的数学，引入了 <code>NaN</code> (这个可以用来检测是否为数字类型)、Infinity(正无穷大)、-Infinity(负无穷大)</li><li>在加减法中 <strong>-0</strong>和<strong>+0 </strong>没有很大的区别，但是在除法中就会很大的区别了</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(.00001%20%2F%20-0)%3B%20%2F%2F%E7%BB%93%E6%9E%9C%EF%BC%9A-Infinity%5Cnconsole.log(.00000000001%20%2F%200)%3B%20%2F%2F%E7%BB%93%E6%9E%9C%3A%20Infinity%22%2C%22id%22%3A%222GSmE%22%7D\"></card><p><br /></p><ul><li>根据双精度浮点数的定义，Number 类型中有效的整数范围是-0x1fffffffffffff 至0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。所以在非整数面前是无法使用 <code>==</code> 或者 <code>===</code> 进行比较的</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(%20.1%20%2B%20.2%20%3D%3D%20.3%20)%3B%20%2F%2F%E7%BB%93%E6%9E%9C%EF%BC%9Afalse%3B%5Cnconsole.log(.1%20%2B%20.2)%3B%20%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9A0.30000000000000004%22%2C%22id%22%3A%22nUCC9%22%7D\"></card><ul><li>正确的比较两边数值是否相等，应该比较左右两边差的绝对值是否小于最小精度</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22console.log(Math.abs(.1%20%2B%20.2%20-%20.3)%20%3C%3DNumber.EPSILON)%3B%20%2F%2F%20true%22%2C%22id%22%3A%22ratOY%22%7D\"></card><p><br /></p><blockquote><p><strong><span>Number.EPSILON</span></strong> 它是 <strong>ES6 </strong>新出的一个挂载在 <strong>Number </strong>的一个常量。</p><p><strong><span>N</span></strong><strong><span>u</span></strong><strong>mber.EPSILON</strong><span> </span><span class=\"lake-fontsize-12\">实际上是 </span><strong><span class=\"lake-fontsize-12\" style=\"color: #333333;\">JavaScript</span></strong><span class=\"lake-fontsize-12\"> 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</span></p></blockquote><h4 id=\"780b6ec0\">（5）Object</h4><ul><li>这个类型表示：<strong>对象</strong>，它是一切有形和无形物体的总称</li><li>它是属性的集合，是 <strong><code>key-value</code></strong> 结构</li><li><strong>key : </strong>可以是字符串类型。也可以是symbol类型</li><li><strong>value :</strong>可以是字符串，可以是数值类型。也可以是对象类型</li></ul><h4 id=\"c91ff6ed\">（6）Symbol</h4><ul><li>这个类型是 <code><strong>ES6</strong></code> 新增的一个类型。其实说实话，到现在还不太清楚这个类型的作用，以及用法</li><li>它是一切非字符串的对象 key 的集合</li><li>Symbol 可以具有字符串类型的描述，但是即使描述相同，Symbol 也不相等</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%2F%2F%20%E5%88%9B%E5%BB%BA%20Symbol%20%E7%B1%BB%E5%9E%8B%5Cnlet%20symbol%20%3D%20Symbol(%5C%22%E5%85%B6%E5%AE%9E%EF%BC%8C%E6%88%91%E6%98%AF%E4%B8%80%E4%B8%AA%E5%A5%BD%E4%BA%BA%5C%22)%3B%5Cnconsole.log(symbol)%22%2C%22id%22%3A%22Wj6ur%22%7D\"></card><p><br /></p><ul><li>这个类型还是有很多不懂，之后有了新收获，再过来更新吧</li></ul><h3 id=\"f3c723ec\">类型转换</h3><h4 id=\"2f9540a5\">（0）string → Number(<span>字符串转成数值类型</span>)</h4><ul><li>常见都是借助 <code>JavaScript</code> 中的内置方法进行转换，例如 <code><strong>parseInt</strong></code>  <code><strong>parseFloat</strong></code> 都是将字符串转化成数值类型。但是  <code><strong>parseInt</strong></code> 是遇到非数值就停下，而<strong> </strong> <code><strong>parseFloat</strong></code> 遇到不属于数字行列才会停，</li><li><code><strong>parseInt</strong></code> <code><strong>parseFloat</strong></code>  转化的字符串，如果第一个字符不是数字的话，就会返回 <strong>NaN</strong></li><li>除了上述的两种，还有 <strong><code>JavaScript</code></strong> 内置的 <strong>Math  </strong>方法也可以隐式的转化成数值，但是依然是如果第一个字符不是数值的话，就会返回 <strong>NaN </strong></li><li>还有一种就是利用装箱操作，利用 <strong><code>Number</code></strong> 进行转换，这个转换的好处就是，只要转换的字符不属于数值类型的，都会返回 <strong>NaN</strong></li><li>如果字符串的字符都是数字。那么可以使用四则运算，也可以进行隐士转换</li></ul><p><br /></p><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20console.log(parseInt(%5C%226340.54%5C%22))%3B%20%2F%2F%20%E7%BB%93%E6%9E%9C%3A6340%5Cn%20console.log(parseFloat(%5C%224.648781655wr%E6%88%91%E6%98%AF1%5C%22))%3B%E7%BB%93%E6%9E%9C%3A4.648781655%5Cn%20console.log(Number(%5C%222.2.22%5C%22))%3B%20%2F%2F%20%E7%BB%93%E6%9E%9C%3ANaN%5Cn%20console.log(Number(%5C%225464646%5C%22))%20%2F%2F%20%E7%BB%93%E6%9E%9C%3A%205464646%22%2C%22id%22%3A%22lsAeE%22%7D\"></card><p><br /></p><h4 id=\"6c2395fb\">（1）Number → string (数字转化成字符串)</h4><ul><li>字符串拼接</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20str%20%3D%20121343454545%3B%5Cnstr%20%3D%20str%2B%20%5C%22%5C%22%3B%5Cnconsole.log(typeof(str))%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9Astring%22%2C%22id%22%3A%22BG9HY%22%7D\"></card><p><br /></p><ul><li>装箱转换</li></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22let%20str%20%3D%2013243545646%3B%5Cnconsole.log(%20typeof(%20String(str)%20)%20)%20%2F%2F%20%E7%BB%93%E6%9E%9C%EF%BC%9Astring%20%22%2C%22id%22%3A%22D50Bv%22%7D\"></card><p><br /></p><h4 id=\"0e1aa6d1\">（2）装箱操作转换</h4><ul><li>在 <code><strong>JavaScript</strong></code> 中，类型之间存在装箱转换操作</li><p><br /></p></ul><card type=\"block\" name=\"codeblock\" value=\"data:%7B%22mode%22%3A%22javascript%22%2C%22code%22%3A%22%20let%20str%20%3D%201323%3B%5Cn%20console.log(typeof%20(String(str)))%3B%20%2F%2F%20string%5Cn%20console.log(typeof%20(Symbol(str)))%20%2F%2F%20symbol%22%2C%22id%22%3A%22UJhlC%22%7D\"></card><p><br /></p><h3 id=\"f0dde815\">其他的数据类型</h3><ul><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">List</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">： 用于描述函数传参过程。</span></li><li><code><strong><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Set</span></strong></code> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：主要用于解释字符集等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Completion Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述异常、跳出等语句执行过程。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Reference</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象属性访问、delete 等。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Property Descriptor</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述对象的属性。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Lexical Environment</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\"> 和  </span><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Environment Record</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述变量和作用域。</span></li><li><strong><code><span class=\"lake-fontsize-9\" style=\"color: #222222;\">Data Block</span></code></strong> <span class=\"lake-fontsize-9\" style=\"color: #222222;\">：用于描述二进制数据。</span></li></ul><h3 id=\"7aa17298\">程序 = 算法 + 数据结构</h3>",
    "public": 1,
    "status": 1,
    "likes_count": 0,
    "comments_count": 0,
    "content_updated_at": "2019-04-11T09:57:02.000Z",
    "deleted_at": null,
    "created_at": "2019-03-27T03:12:47.000Z",
    "updated_at": "2019-04-11T09:57:02.000Z",
    "published_at": "2019-04-11T09:57:02.000Z",
    "first_published_at": "2019-03-27T03:22:53.000Z",
    "word_count": 1684,
    "cover": "",
    "description": "tags: [JavaScript数据类型]categories: 重学前端系列笔记--------------前言最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。补充*变量声明跟赋值，是两个概念。let a 是属于变量...",
    "custom_description": "前言最新在看witter大神的专栏《重学前端》，感慨颇多，收益也颇多。觉得自己该重建一下前端的知识体系，所以跟着写下这个笔记。",
    "_serializer": "v2.doc_detail"
  }
]