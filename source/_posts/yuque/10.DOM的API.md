
---
title: 10.DOM的API
date: 2019-04-15 09:50:41 +0800
tags: [DOM的API]  
categories: 重学前端系列笔记
cover: "https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555293932589-c499b920-7e29-4340-847f-940e83b14666.jpeg"
---

<a name="df368884"></a>
### 前言
我们前端所操控的方法 **`API`** 总的来说分两大类
* **浏览器对象模型：**就是我们经常依赖的环境-浏览器。浏览器会提供一些  **`API`** ，方便我们操作，但是并不是所有的方法都是标准里面的，需要区分哪些是浏览器这个环境提供的，哪些是 **`ECMA`** 标准里面的
* **文档对象模型：**也就是我们经常使用的 **`DOM API`** ，用来操作页面元素
<a name="1301fe28"></a>
## DOM的API分类
* **节点**：节点操作
* **事件**：触发或者监听方面的 `API` 
* **`Range`** ：操作文字方面的 `API` 
* **遍历 ：**遍历 `DOM` 需要的 `API` 
<a name="21b9f161"></a>
### 节点API
<a name="a6967bfc"></a>
#### Node节点
![6e278e450d8cc7122da3616fd18b9cf6.png](https://cdn.nlark.com/yuque/0/2019/png/221851/1555299624515-0b283c44-3013-45f3-a03a-84102129c400.png#align=left&display=inline&height=495&name=6e278e450d8cc7122da3616fd18b9cf6.png&originHeight=634&originWidth=955&size=96882&status=done&width=746)

> 一般来说。我们工作中经常碰到的有两种节点：文本节点或者元素节点


<a name="ec4b57af"></a>
#### 元素节点关系API
* **`parentNode`** :可以获取父级元素节点
* **`childNodes`** :可以获取子级所有节点，包括元素节点，文本节点
* **`firstChild`** :可以获取当前元素的第一个节点，一般是文本节点
* **`lastChild`** ：可以获取当前元素的最后一个节点，一般是文本节点
* **`nextSibling`** ：可以获取当前元素同级的下一个节点，一般是文本节点
* **`previousSibling`** ：可以获取当前元素同级的上一个节点，一般是文本节点
<a name="e057f953"></a>
#### 元素操作API
* **`appendChild`** ：这个是追加子元素
* **`insertBefore`** ：这个是在指定元素之前插入元素
```javascript
var insertedNode = parentNode.insertBefore(newNode, referenceNode);
/** 
* parentNode:要插入的父节点
* newNode: 用于插入的节点
* referenceNode: 要插入在什么节点之前
*/
```
* **`removeChild`** ：移除指定元素
* **`replaceChild`** ：替换指定元素节点
```javascript
var replacedNode = parentNode.replaceChild(newChild, oldChild);
/** replacedNode为返回被替换掉的节点。
*如果 newChild 以及在页面的dom元素内，会从原来的位置删除，移动到要替换的位置
*/
```
* **`cloneNode`**`true Or false`**`false`** 
<a name="9ed04098"></a>
#### 创建节点API
* **`createElement`** ：创建指定的元素节点
* **`createTextNode`** ：创建指定的文本节点
* **`createCDATASection`** ：可以创建CDATA 区段节点，该方法返回 CDATASection 对象。
```javascript
createCDATASection(data) // data:字符串，这个字符串为节点规定数据。
```
* **`createComment`** ： 可创建注释节点, 并插入HTML文档
* **`createProcessingInstruction`** ：创建一个新的处理指令节点，并返回
```javascript
var docu = new DOMParser().parseFromString('<xml></xml>',  "application/xml")
var pi = docu.createProcessingInstruction('xml-stylesheet', 'href="mycss.css" type="text/css"');
docu.insertBefore(pi, docu.firstChild);
alert(new XMLSerializer().serializeToString(docu));
// 弹出框内容: <?xml-stylesheet href="mycss.css" type="text/css"?><xml/>
```
* **`createDocumentFragment`** ：创建一个新的空白的文档片段
> 通常的用例是创建文档片段，将元素附加到文档片段，然后将文档片段附加到DOM树。在DOM树中，文档片段被其所有的子元素所代替。文档片段存在于内存中，并不在DOM树中，所以将子元素插入到文档片段时不会引起页面回流（对元素位置和几何上的计算）。因此，使用文档片段通常会带来更好的性能。

```javascript
let fragment = document.createDocumentFragment();
```

* **`createDocumentType`** ：创建一个 DocumentType 节点
<a name="f56853d9"></a>
#### 属性操作API
* **`getAttribute` ：**获取指定元素上指定的属性
* **`setAttribute` ：**设置指定元素上指定的属性<br />
* **`removeAttribute` ：**移除指定元素上指定的属性
* **`hasAttribute` ：**判断指定元素上是否有指定的属性

如果追求性能，可以把Attribute 当作节点
* **`getAttributeNode`** 
* **`setAttributeNode` **
<a name="5c5c679f"></a>
### 事件API
<a name="89a275cc"></a>
#### （0）鼠标事件
* **`mousedown`** ：鼠标的键钮被按下。
* **`mouseup`** ：鼠标的键钮被释放弹起。
* **`click`** ：单击鼠标的键钮。
* **`dblclick`** ：在单个元素上单击两次鼠标的指针设备按钮 (通常是小鼠的主按钮) 时。
* **`contextmenu`**  ：弹出右键菜单。
* **`mouseover`** ：鼠标移到目标的上方。
* **`mouseout`** ：鼠标移出目标的上方。
* **`mousemove`** ：鼠标在目标的上方移动。
<a name="f35f8583"></a>
#### （1）键盘事件
<a name="e17fc0b0"></a>
#### （2）****页面事件****
<a name="2015eb00"></a>
#### （3）表单事件
<a name="4cec4a1d"></a>
#### （4）剪贴板事件
<a name="15aac593"></a>
#### （5）打印事件
<a name="a566118f"></a>
#### （6）拖动事件
<a name="1e6ba787"></a>
#### （7）多媒体（Media）事件
<a name="797b0edc"></a>
#### （8）动画事件
<a name="7e2f3f3a"></a>
#### （9）过渡事件
<a name="1c960ba0"></a>
#### （10）其他事件
<a name="7df1cf45"></a>
### Range  API
<a name="54898fa9"></a>
### 遍历

