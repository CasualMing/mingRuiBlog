
---
title: 16. javascript执行顺序
date: 2019-04-28 11:46:22 +0800
tags: [词法,转载]
categories: 重学前端系列笔记
cover: "https://cdn.nlark.com/yuque/0/2019/jpeg/221851/1555489235300-77ec8cfd-2be0-448e-a3d3-9dead9ff2d33.jpeg"
---
<a name="UTtjo"></a>
## 前言
当我们接到一段 **`JavaScript`** 代码的时候，传递给 **`JavaScript`** 引擎要求其执行。在遇到事件的时候，会继续将其中的一些事件代码交给 **`JavaScript`** 引擎执行，当然也会提供一些 **`API`** 给 **`JavaScript`** 引擎，这样的 **`API`** 允许引擎在特定时机执行某段代码。<br />我们可以理解为 **`JavaScript`** 引擎存在于内存中，它一直在运转，在等待着我们将 **`JavaScript`** 片段代码或者事件交给它进行执行处理，但是页面一般同时会有很多代码需要执行，那么就需要指定一个顺序。
<a name="V4h8r"></a>
### 宏任务与微任务
> 我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。

**`JavaScript`** 引擎一直在等待着宿主分配宏观任务，这个等待分配，然后执行代码的过程，称之为 **`evenLoop`** 
```javascript
// 伪代码表述简单的evenLoop
while(true) {
    r = wait(); // 等待宿主分配任务 
    execute(r); // 分配任务之后，执行该任务
}
```
当然在等待以及执行的时候，还有其他的过程，像是检查任务队列，判断任务是否达到执行时机，判断同步的上一个任务是不是执行完毕等等。<br />而宏任务的队列就是事件循环。而 **`JavaScript`** 在执行宏观任务的时候，如果这个任务是异步的， **`JavaScript`** 要保证异步代码在一个宏观任务中执行，那么宏观任务中就有微任务队列<br />有了宏任务以及微任务概念之后，就可以理解，引擎产生的任务会在任务尾部添加微任务。而宿主产生的任务会直接扔在宏任务内
<a name="SF2yN"></a>
### promise
```javascript
var promise = new Promise(function(resolve, reject){
  console.log("a");
  resolve();
})
promise.then(function(){
	console.log("b");
});
console.log("c");
// 打印的顺序是。acb;
```
上面的运行结果之所是 **`acb`** 是因为 **`new`** 一个构造函数，会执行构造函数内的函数，然后虽然 **`console.log("c")`** 在 **`.then()`** 后面，但是因为 **`resolve()`** 是异步的。所以会先打印 **`c`** 

